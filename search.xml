<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Billboard与施密特正交</title>
      <link href="/posts/21880.html"/>
      <url>/posts/21880.html</url>
      
        <content type="html"><![CDATA[<p>在游戏开发的过程中，Billboard的一般做法是通过view和up两个向量构建一个旋转矩阵，从而调整sprite facing使其与观察空间某个向量对齐（up / normal），而众所周知构建一个旋转矩阵需要三个正交基，但我们现在就只有view和up两个基，还不正交，所以免不了要用叉乘对原来这两个二维基向量进行“升维”<br><img src="https://pic1.zhimg.com/v2-2aa2974b4f4e2453d64d6f092c64874c_r.jpg" alt="图源《入门精要》P236"></p><p>具体步骤是，先用 up×view 算出 right，构建出一个临时的坐标空间；然后再以这个临时空间为参考系，用 normal×right 算出up’，再在这由两个向量张成的二维平面上再做一次升维。<br><img src="https://pic2.zhimg.com/v2-489e0c0eaf32ee770910181a24416bb1_b.jpg" alt></p><p>因为这样得到的三个基向量可以保证相互正交，所以像这样构建旋转矩阵是非常合理的。</p><p>这是叉乘的做法。</p><p>但我们又知道，旋转矩阵之所以要用三个正交基去构建，是因为他本身就是一个标准正交矩阵，而在 <script type="math/tex">\mathbb{R}^3</script> 找一个平面的正交基可以使用施密特正交化，那上面提到的叉乘这种做法又和施密特正交有什么关系呢？</p><p>我们不妨由公式做一些简单的推导</p><p>假设有 <script type="math/tex">view=(v_1,v_2,v_3)</script> ， <script type="math/tex">up=(u_1,u_2,u_3)</script></p><p>依据叉乘公式<br><img src="https://pic1.zhimg.com/v2-c5539c4fdf899fc5db1d232d815f7e80_r.jpg" alt></p><p>和施密特正交化公式<br><img src="https://pic3.zhimg.com/v2-3bf334c20621874c34ecb10c324fbaea_b.jpg" alt></p><p>叉乘法先求 right 再求 up’<br><img src="https://pic1.zhimg.com/v2-389362a2f79ed82486876a1403c9b5c8_r.jpg" alt></p><p>而施密特正交化结果：<br><img src="https://pic4.zhimg.com/v2-2d5c863ccfa708d78ae212e9e005931b_r.jpg" alt></p><p>类似的可以求出 right，可以发现两个结果差了一个模长的平方倍，如果进行正交化的几个基均为标准基（即模长均为 1），那么这两个结果应该是一模一样的</p><p>两种方法的区别在于</p><p>1、叉乘法有先后顺序，而施密特正交化没有</p><p>2、叉乘法可以理解为升维，而施密特则可以理解为投影（本来也是这么推出来的，感兴趣可以看看下面这篇）</p><p>而从实践的角度，显然叉乘法更为直观…. 所以这篇文章只是提供了一种另类的理解方式，把两个看似无关的东西联系在了一起（就摁水）</p><p>大概就酱、</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blogs </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的URP仿原神角色渲染</title>
      <link href="/posts/44076.html"/>
      <url>/posts/44076.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从去年到现在学习TA已经大概有半年多了，最近也开始逐渐意识到要去做一些自己的实践，于是经过一个礼拜左右时间的研究学习，通过这样一个仿原神渲染的尝试，对之前卡渲的一些理论做了一下初步的实现。<br>不得不说，“只有实践才能出真知”这句话真的太对了，之前看RTR之类资料的时候觉得这块不过如此，而只有到真正自己上手的时候才明白自己还有太多的东西浮于表面一知半解，包括哪些地方需要什么样的trick，哪里如何优化才能让代码的效率更高，还有最重要的自己定位bug解决bug的能力（别的不说，这甚至还是我第一次buildin转URP….）<br>套用之前看到的图就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/23115229/1651839535848-39172531-673e-41d9-b2ef-b03df653ec18.jpeg#averageHue=%23f9f9f7&amp;clientId=ua34e33ef-0961-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=321&amp;id=u0cfe0f80&amp;originHeight=519&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35183&amp;status=error&amp;style=none&amp;taskId=u8a3b84cb-bd4c-413e-b902-c6cdeda017f&amp;title=&amp;width=396" alt="C7DC53DDC05F7F8DF94122B40AAFE510.jpg"><br>我这辈子都搞不懂了…<br>所以就算整体做下来代码量就三四百行，这一个礼拜的学习对我自己而言收获还是挺大的，因此希望通过写这样一篇文章能对我自己的学习过程做一个记录。文章可能不会事无巨细面面俱到，过于拾人牙慧的东西我就直接把链接逐一贴出略过了，而相对的我会留下更多空间去记录自己的思考过程和踩坑经历（如果有哪里理解不到位的话，还请大佬在评论区指正补充）<br><a href="https://www.zhihu.com/column/c_1215952152252121088">从零开始的卡通渲染</a><br><a href="https://zhuanlan.zhihu.com/p/360229590">原神角色渲染Shader分析还原</a><br><a href="https://zhuanlan.zhihu.com/p/435005339">【Unity技术美术】 原神Shader渲染还原解析</a><br><a href="https://zhuanlan.zhihu.com/p/490406107">从仿原神角色渲染到MMD制作(小记)</a><br><a href="https://zhuanlan.zhihu.com/p/468209534">从零开始的原神角色渲染</a><br>那么话不多说让我们开始吧！</p><h1 id="风格分析"><a href="#风格分析" class="headerlink" title="风格分析"></a>风格分析</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p><strong>PBR、NPR与三渲二</strong><br>在喵刀老师去年JTRP教程的<a href="https://www.bilibili.com/video/BV1AA411A7RR?">20:19</a>处有详细说明，以下进行概括</p><blockquote><p>卡通渲染属于非真实感渲染（Non-photorealistic rendering，简称NPR）。对应的还有真实感渲染(Photorealistic rendering)。后者旨在渲染真实感的画面，而前者则追求更加有艺术感的画面效果，例如手绘风格的画面</p></blockquote><p>我们常说的PBR（Physically-based rendering）是一种以现实为参考的渲染方法，而NPR则是与PBR相对的概念，强调风格化，包括但不限于油画，铅笔画，水墨画等不同类型。三渲二属于NPR的一个子集，特指一些用3D手段还原2D赛璐璐风格的技法<br>三渲二的画面特点通常包含以下几点：</p><ul><li>阴影简单而主观</li><li>颜色信息单一，以大色块和硬边过渡为主</li><li>主要通过笔触感很强的勾线来凸显形状</li><li>特殊的脸部线条画法</li><li>条状高光，与光方向无关的边缘光</li><li>背光处理（能够大幅提升画面质感）</li><li>……</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651846151394-bf7eb62e-ab2b-4ddd-b450-66a3b0df95be.png#averageHue=%23a2a798&amp;clientId=ua34e33ef-0961-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=541&amp;id=ud1094521&amp;originHeight=676&amp;originWidth=1205&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1005285&amp;status=error&amp;style=none&amp;taskId=ucaf19f42-801f-4883-a17c-5d991962fee&amp;title=&amp;width=964" alt="P5KC{UFS3F8QO%E]_3IUAFV.png"><br>不同风格的三渲二作品<br><strong>赛璐璐，平涂与厚涂</strong><br>赛璐璐和厚涂的区别：<br>赛璐璐：特指一种颜色界限层次分明的上色风格，色块大，图层多，边缘锐利，大量出现在日本动画制作中，属于一种极端的平涂<br>厚涂：运用笔刷和技巧堆砌颜色，技术要求高，画面通常表现出立体感强、色彩丰富、质感厚实的特点</p><h2 id="原神的角色渲染"><a href="#原神的角色渲染" class="headerlink" title="原神的角色渲染"></a>原神的角色渲染</h2><p>原神的角色渲染还是有一部分继承了三蹦子的技术的，可以参考<a href="https://www.youtube.com/watch?v=egHSE0dpWRw&amp;t">官方古早的视频</a> 12:14-28:01 部分<br>由于能力有限，本次的还原并未涉及游戏内shader的截帧分析，所以说并不是真正意义上的还原，只是在基础的卡通渲染上加了一些自己的想法付诸实现<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651923548730-ddf02e16-237c-465d-b0c0-9b70e5509546.png#averageHue=%23fbfafa&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=558&amp;id=u8cc66437&amp;originHeight=698&amp;originWidth=1087&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=41672&amp;status=error&amp;style=none&amp;taskId=uc8bdea3c-916d-4ce0-9fbb-2c93cb22595&amp;title=&amp;width=869.6" alt="image.png"><br>目前实现的效果：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/23115229/1651921855335-17266abb-c68f-47d1-a4cc-5cb69209973d.gif#averageHue=%2395a5bc&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=384&amp;id=ufa511760&amp;originHeight=480&amp;originWidth=856&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1425130&amp;status=error&amp;style=none&amp;taskId=u759d9717-1fd2-4f13-a721-21e13401db0&amp;title=&amp;width=684.8" alt="2022.05.07阶段性成果GIF.gif"><br>肉眼可见的一堆问题……不过也只能这样了，期末周精力实在达不到，后续有更改会在这继续更新</p><h1 id="贴图分析"><a href="#贴图分析" class="headerlink" title="贴图分析"></a>贴图分析</h1><p>首先还是来看一下我们手上有哪些资源：<br>![B3<code>ITXZ%VD[UHSX(SJ_SV%E.png](https://cdn.nlark.com/yuque/0/2022/png/23115229/1651318026520-15c16f36-39b8-4a63-ad12-ee6c3b568ea2.png#averageHue=%23e6dfdb&amp;clientId=u7629753c-7c10-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=344&amp;id=u14700a1c&amp;originHeight=430&amp;originWidth=746&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=128738&amp;status=error&amp;style=none&amp;taskId=uea7e28db-b597-4b63-8cd4-e08c19a3784&amp;title=&amp;width=596.8)除了三张Diffuse是官方配布，其他均需要自行获取Body和Hair分别有一张LightMap（ILM），观察可知其四个通道分别为：R：高光范围![Y2N]F)$3E2]XCMCB[[XF8UR.png](https://cdn.nlark.com/yuque/0/2022/png/23115229/1651479545647-d4f2c8ad-8f22-49a3-8ca9-b32ee408c738.png#averageHue=%2392918e&amp;clientId=u161fa7aa-7488-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=390&amp;id=u4476adf6&amp;originHeight=488&amp;originWidth=1400&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=204119&amp;status=error&amp;style=none&amp;taskId=ud0cca84b-35fb-4760-b9e7-d09a0147abe&amp;title=&amp;width=1120)g：AO Mask（黑色-固定阴影，灰色-动态阴影，白色-完全亮部）![Z_</code>CW~J]2OV0L9W7O3XMN)K.png](<a href="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651479550305-7f5c3258-e017-45b6-a210-d1ad69a7a7e9.png#averageHue=%2371706e&amp;clientId=u161fa7aa-7488-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=390&amp;id=uf0c2bd44&amp;originHeight=487&amp;originWidth=1400&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=242700&amp;status=error&amp;style=none&amp;taskId=u8108bb07-f415-477f-8ba2-b092c0c7269&amp;title=&amp;width=1120">https://cdn.nlark.com/yuque/0/2022/png/23115229/1651479550305-7f5c3258-e017-45b6-a210-d1ad69a7a7e9.png#averageHue=%2371706e&amp;clientId=u161fa7aa-7488-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=390&amp;id=uf0c2bd44&amp;originHeight=487&amp;originWidth=1400&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=242700&amp;status=error&amp;style=none&amp;taskId=u8108bb07-f415-477f-8ba2-b092c0c7269&amp;title=&amp;width=1120</a>)<br>b：高光强度<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651479554404-c54d26d2-6763-4faa-926e-fc397c434d3f.png#averageHue=%2373716f&amp;clientId=u161fa7aa-7488-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=390&amp;id=uc105c6a8&amp;originHeight=488&amp;originWidth=1400&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=207626&amp;status=error&amp;style=none&amp;taskId=u69821579-129d-4a24-9326-95d986ae6fd&amp;title=&amp;width=1120" alt="%IZF}8KPNW$P@`M19U)W}CS.png"><br>a：Ramp阈值<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651319516359-1b6c8bd5-ac3a-4d1b-b58b-64f6b8d94fb3.png#averageHue=%23464544&amp;clientId=u7629753c-7c10-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=822&amp;id=u3d07533b&amp;originHeight=1028&amp;originWidth=1916&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=155059&amp;status=error&amp;style=none&amp;taskId=u300fe855-a98b-4372-b0c3-164e0c398a3&amp;title=&amp;width=1532.8" alt="`S[)1911T$~[%L_F2_IJRKN.png](https://cdn.nlark.com/yuque/0/2022/png/23115229/1651479558991-51b1bafb-2b62-4651-914a-503a43517149.png#averageHue=%2373716e&amp;clientId=u161fa7aa-7488-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=390&amp;id=u1405a4d5&amp;originHeight=488&amp;originWidth=1397&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=184386&amp;status=error&amp;style=none&amp;taskId=u196b5529-2088-462c-934d-83cb7970079&amp;title=&amp;width=1117.6)身体和头发分别对应两张Ramp图，每张ramp都分了冷色调和暖色调的渐变条带，有点像UE的Curve Atlas![K2}FGB3QNM~%52~TCHO8F5W.png](https://cdn.nlark.com/yuque/0/2022/png/23115229/1651319433368-28678456-7f62-4400-8b4a-f6c123931092.png#averageHue=%23444342&amp;clientId=u7629753c-7c10-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=822&amp;id=u656bc558&amp;originHeight=1027&amp;originWidth=1917&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=156316&amp;status=error&amp;style=none&amp;taskId=uab1301bd-4d2c-4ee9-ad2f-b3247bce2bc&amp;title=&amp;width=1533.6)![B`E$YE@LDE]R]%XG)VZB$3N.png"><br>不同角色的ramp的排列方式和条带数量都是有区别的，比如甘雨这套，body一共5种渐变色，hair有4种，而对于排列方式则大概分为两种，一种是256<em>16，暖8冷8（大概率有3像素以上的留白），另一种是20像素的，暖5</em>2 冷5*2，所以需要根据不同类型选择不同的采样方式，这个后面还会详细说到（或者可以直接使用曲线进行手动调色，自由度更高）<br>两种不同的ramp：</p><div class="table-container"><table><thead><tr><th><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651399873348-5740d8b7-28ea-4577-8c16-75a32fd2d7af.png#averageHue=%23edc5ba&amp;clientId=u161fa7aa-7488-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=295&amp;id=u626720d9&amp;originHeight=504&amp;originWidth=348&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=4801&amp;status=error&amp;style=none&amp;taskId=ua571be27-aecf-404e-8b18-022ee87aceb&amp;title=&amp;width=203.39999389648438" alt="Z5F%3HMBS73GAKH28H_DOYL.png"></th><th><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651399871157-1da1e910-e5e6-42c6-92ef-d538a70c965c.png#averageHue=%23726c79&amp;clientId=u161fa7aa-7488-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=293&amp;id=u29510ad8&amp;originHeight=408&amp;originWidth=283&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=3687&amp;status=error&amp;style=none&amp;taskId=u87a85abc-3a31-4d9c-8f8b-72cf11c461f&amp;title=&amp;width=203.40000915527344" alt="UT)O]9L3}LD%G$)BU2DDZA5.png"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>剩下还有两张，一张脸部SDF还有一张MetalMap，在做脸部阴影和身体身体金属部件高光的时候都会起到特殊的作用，也是等到后面提到了再说吧<br>关于贴图设置，除了Diffuse图和Ramp图，其他全部取消勾选sRGB，法线图（如果有的话）纹理类型选择Normal Map，SDF纹理压缩设置为None（UE改成灰阶），不然会有很难看的锯齿<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1665816267313-38100aaa-cbf3-44d2-b455-86e6356b82aa.png#averageHue=%23393737&amp;clientId=u8171bcba-2b22-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=410&amp;id=u8ec54953&amp;originHeight=456&amp;originWidth=360&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=67817&amp;status=error&amp;style=none&amp;taskId=ua54cd393-5b7f-49d6-ab66-7b705fd2638&amp;title=&amp;width=324" alt="RM`B1{(Y0J51REWIN@R`@@A.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1665816310467-2520ae9f-0b8f-40fc-929f-89e1c494b19a.png#averageHue=%23272626&amp;clientId=u8171bcba-2b22-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=410&amp;id=u7a5fd35b&amp;originHeight=558&amp;originWidth=472&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36726&amp;status=error&amp;style=none&amp;taskId=u8d1fd4fa-5f9f-4658-bee4-1ec45c74819&amp;title=&amp;width=347" alt="(6O{`_13IR61NCSLR~8854A.png"></p><h1 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h1><p>那么现在就让我们开始正式的代码编写。<br>首先来看描边。描边通常是卡通角色渲染中拿到模型后第一件需要处理的事情，一方面是因为它极其基础，另一方面也是因为它有可能会影响后续其他效果的调整（如边缘光的粗细），这里虽然采用的还是传统的背面法线外扩的方式，但是我有对其中几个经典的问题进行了改进，如下：</p><ul><li>描边粗细随摄像机远近发生变化</li><li>硬表面描边断裂</li><li>视口比例修正</li></ul><p>第一个问题是因为，我们一般的法线外扩都是在视口空间完成的，最终渲染到屏幕之前，硬件底层还会帮我们做一步透视除法（即除w将坐标映射到$[-1,1]$的NDC空间），要想保持描边粗细不变，我们就必须在外扩距离的基础上乘上w来消除它的影响<br>第二个问题也老生常谈了，问题出在模型本身的法线都是垂直于当三角网格所在平面的，一个顶点可能会依据邻接的三角面选择多个法线方向，而法线外扩通常在顶点着色器就完成了全部的处理，那么这时候就需要我们提前对模型进行法线上的合并。详细的做法可以参考喵刀老师的文章：<br><a href="https://zhuanlan.zhihu.com/p/107664564">【Job/Toon Shading Workflow】自动生成硬表面模型Outline Normal</a><br>有几个小点需要注意的是，文中提到的 JOBS 是引擎基于ECS的一套多线程管理系统，需要提前在Package Manager中进行环境的配置，这里建议直接向manifest.json文件中添加”com.unity.collections”: “0.17.0-preview.18”，以安装相关插件，因为entity在直接安装的过程中很有可能发生版本不兼容等各种问题，我在这上面折腾了好久，最后还是google找到了适合自己的解决方案……<br>喵刀老师的这个方法的话，是通过在模型导入的时候直接生成一个副本然后做模型后处理实现的，相比2173大佬的那个将平滑法线写入模型切线的编辑器工具，这个可以在引擎关闭时仍保留平滑法线的数据，方便了很多（当然也可以直接在dcc里写工具，只要能解决问题就行）<br>如果用的是喵刀老师的方法，需要注意一下顶点色通道的问题，因为官方给的模型的g通道原来用来控制Ramp偏移的，所以要避免这个问题，要么就用第二套顶点色，要么后面再自己开个参数手动控制偏移，不论哪种方法都造不成什么大问题<br>平滑法线输出如图，绿色代表左上，黄色代表右上，黑色左下，红色右下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651978474518-7ba1429f-9594-4567-8973-74733ba6dcd9.png#averageHue=%237d7d7d&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=431&amp;id=u46d1b954&amp;originHeight=865&amp;originWidth=812&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=196162&amp;status=error&amp;style=none&amp;taskId=u6b0d38af-3ef5-48a3-915c-c94881d26a4&amp;title=&amp;width=404.6000061035156" alt="C8`[`2K`@Z3OJTRAFKASM5E.png](https://cdn.nlark.com/yuque/0/2022/png/23115229/1651323197568-a1ea7dba-bbce-4d39-9747-5cccc51c447d.png#averageHue=%233f6eb5&amp;clientId=u7c9f8c6b-ad1f-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=313&amp;id=z9O3Q&amp;originHeight=391&amp;originWidth=849&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=81770&amp;status=error&amp;style=none&amp;taskId=u3869abc3-074f-4136-b08f-b9f90e88dcc&amp;title=&amp;width=679.2)最后一个问题，视口比例修正，这个就很简单了，直接拿参数算一下乘上去就好片元着色器部分代码如下：<figure class=" highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取预先烘焙进顶点色的切线空间平滑法线，修复描边断裂，同时避免蒙皮动画可能发生的错误描边</span></span><br><span class="line"><span class="comment">// UnpackNormalmapRGorAG会自动将RG变为AG，也就将顶点色控制描边粗细变化一并实现了</span></span><br><span class="line">half3 smoothNormal = <span class="built_in">normalize</span>(UnpackNormalmapRGorAG(v.color));</span><br><span class="line"><span class="comment">// 将法线从切线空间变换到世界空间</span></span><br><span class="line">float3x3 tangentTransform = float3x3(o.worldTangent, o.worldBiTangent, o.worldNormal);</span><br><span class="line">half3 worldOutlineNormal = <span class="built_in">normalize</span>(mul(smoothNormal, tangentTransform));</span><br><span class="line"><span class="comment">// 再从世界空间变换到裁剪空间，此处 * pos.w 是为了消除齐次除法的影响，使得在摄像机远近发生变化时，描边粗细保持不变</span></span><br><span class="line">half3 outlineNormal = TransformWorldToHClip(worldOutlineNormal) * pos.w;</span><br><span class="line"><span class="comment">// 求得屏幕宽高比，修正描边以适配窗口</span></span><br><span class="line"><span class="type">float</span> aspect = _ScreenParams.x / _ScreenParams.y;</span><br><span class="line">pos.xy += <span class="number">0.001</span> * _OutlineWidth * v.color.a * outlineNormal.xy * aspect * _EnableOutline;</span><br><span class="line">o.pos = pos;</span><br></pre></td></tr></table>效果：![M9TBJWGQ2[Q5R47ZTCLE[H1.png](https://cdn.nlark.com/yuque/0/2022/png/23115229/1651978398152-7c4ed2e8-d11b-410c-9179-626329d268d6.png#averageHue=%237b7b7a&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=421&amp;id=u16667bd3&amp;originHeight=834&amp;originWidth=753&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=173569&amp;status=error&amp;style=none&amp;taskId=u82cf9603-85f7-4c1b-8aab-276af66a698&amp;title=&amp;width=380.3999938964844)不处理![2YB$3YCNXNO$KMB`{FN~26O.png](https://cdn.nlark.com/yuque/0/2022/png/23115229/1651929637268-d5106fd2-3dc5-475a-8ecd-e5f21dd53b06.png#averageHue=%237d7d7d&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=413&amp;id=u24f47a4e&amp;originHeight=1198&amp;originWidth=1115&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=300940&amp;status=error&amp;style=none&amp;taskId=uf654991f-6f9a-4570-b098-c0743aaee7c&amp;title=&amp;width=384)模型后处理![%A5I[(@V6[8}Q_4$7](`3KG.png"><br>存进切线<br>可以看到平滑后还是有点效果的（再想把质量往上提的话就直接用p+吧hhh）<br>2021.05.08：<br>今天早上爬起来看了眼JTRP的Readme，里面中说平滑法线的这个流程已经失效了，但我2021.3.1f1c1 collection0.17.0-preview.18这个版本还可以用，应该就是包版本的问题</p><h1 id="Ramp"><a href="#Ramp" class="headerlink" title="Ramp"></a>Ramp</h1><p>接下来轮到漫反射<br>在常规的卡通渲染当中，一般都会通过冷暖色调分离、阴影边缘硬化等手段来使画面达到风格化的目的，而原神这种用ilm贴图配合ramp实现色调控制的方法，也是早在好几年前《GUILTY GEAR Xrd》就已经存在的思路。值得一提的是，三蹦子的ramp和原神这套虽然原理差不多，但有些地方还是有一定差别的（虽然不管怎么样最后都会有一定trick,,,）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651930115093-1246103f-0d0c-46c0-afb5-525f99f85602.png#averageHue=%237a756d&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;id=u4dfc96ee&amp;originHeight=217&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=error&amp;style=none&amp;taskId=u6db61e8b-8641-4a8f-86c5-03b065a4d01&amp;title=" alt><br>这里我就主要说一下甘雨的ramp图采样思路吧（不适用其他角色）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651480682206-a0971767-97c6-4c54-9296-0ce38b0d4c44.png#averageHue=%23185328&amp;clientId=udf4b8113-e78b-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=472&amp;id=ubc1bf4ee&amp;originHeight=590&amp;originWidth=1147&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=44172&amp;status=error&amp;style=none&amp;taskId=u88364dfb-142d-414a-9b44-14e6719e84e&amp;title=&amp;width=917.6" alt="GKX2HTD8~IN3EB6$N5ICVSX.png"><br>经过上面的贴图分析我们知道，我们采样的像素分为冷暖两种色调，以适应白天和夜晚不同的光线环境（实际上游戏里还有不同天气等诸多别的影响，不知道是用额外的ramp还是后处理实现的），那么我们要做的就是通过shader_feature来进行采样的切换。具体的采样方法上面这张图已经表示的非常清楚了，为了尽可能的采样到像素中间，以避免颜色的混杂，必须对采样方式实行精确的控制。这里有一点比较迷惑的是，甘雨LightMap的a通道看上去只分了三层，但是ramp却给了五个色带，多出来的那几个色带没看懂是用来干嘛的，所以我最后直接让lightmap自己选去了（将0-1灰度映射到1-5代入等差数列…），最后看起来也没什么太大的问题….<br>对于头发部分，因为头发部分只有4个色带，所以映射关系就是0-1到1-4，然后根据ps中观察到的渐变形态，主观的采样了第一和第三条，也不一定是正确答案<br>有了RampY，剩下的就简单了，RampX根据原来的lambert值，做smoothstep重映射，只保留0到一定数值的渐变，而大于这一数值的全部采样ramp最右边的颜色，这样一来就既可以保留阴影色的过渡，又可以形成硬边，将明暗很好的区分开来<br><a href="https://zhuanlan.zhihu.com/p/157758600">Shader实验室: smoothstep函数</a><br><a href="https://www.geogebra.org/classic/sw9mtpdd">GeoGebra Classic - GeoGebra</a><br>最后乘上AO和基础色，Ramp部分就基本完成了<br>ramp图第一行<br>代码：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">half4 ToonPassFrag(v2f i) : SV_TARGET</span><br><span class="line">&#123;</span><br><span class="line">    float4 BaseColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv) * _MainColor;</span><br><span class="line">    float4 LightMapColor = SAMPLE_TEXTURE2D(_LightMap, sampler_LightMap, i.uv);</span><br><span class="line">    Light mainLight = GetMainLight();</span><br><span class="line">    half4 LightColor = half4(mainLight.color, <span class="number">1.0</span>);</span><br><span class="line">    half3 lightDir = <span class="built_in">normalize</span>(mainLight.direction);</span><br><span class="line">    half3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos - i.worldPos);</span><br><span class="line">    half3 halfDir = <span class="built_in">normalize</span>(viewDir + lightDir);</span><br><span class="line"></span><br><span class="line">    half halfLambert = <span class="built_in">dot</span>(lightDir, i.worldNormal) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Base Ramp</span></span><br><span class="line">    <span class="comment">// 依据原来的lambert值，保留0到一定数值的smooth渐变，大于这一数值的全部采样ramp最右边的颜色，从而形成硬边</span></span><br><span class="line">    halfLambert = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, _ShadowSmooth, halfLambert);</span><br><span class="line">    <span class="comment">// 常暗阴影</span></span><br><span class="line">    <span class="type">float</span> ShadowAO = <span class="built_in">smoothstep</span>(<span class="number">0.1</span>, LightMapColor.g, <span class="number">0.7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> RampPixelX = <span class="number">0.00390625</span>;  <span class="comment">//0.00390625 = 1/256</span></span><br><span class="line">    <span class="type">float</span> RampPixelY = <span class="number">0.03125</span>;     <span class="comment">//0.03125 = 1/16/2   尽量采样到ramp条带的正中间，以避免精度误差</span></span><br><span class="line">    <span class="type">float</span> RampX, RampY;</span><br><span class="line">    <span class="comment">// 对X做一步Clamp，防止采样到边界</span></span><br><span class="line">    RampX = <span class="built_in">clamp</span>(halfLambert*ShadowAO, RampPixelX, <span class="number">1</span>-RampPixelX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灰度0.0-0.2  硬Ramp</span></span><br><span class="line">    <span class="comment">// 灰度0.2-0.4  软Ramp</span></span><br><span class="line">    <span class="comment">// 灰度0.4-0.6  金属层</span></span><br><span class="line">    <span class="comment">// 灰度0.6-0.8  布料层，主要为silk类</span></span><br><span class="line">    <span class="comment">// 灰度0.8-1.0  皮肤/头发层</span></span><br><span class="line">    <span class="comment">// 白天采样上半，晚上采样下半</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —</span></span><br><span class="line">    <span class="comment">// Base Ramp</span></span><br><span class="line">    <span class="keyword">if</span> (_IsNight == <span class="number">0.0</span>)</span><br><span class="line">        RampY = RampPixelY * (<span class="number">33</span> - <span class="number">2</span> * (LightMapColor.a * <span class="number">4</span> + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        RampY = RampPixelY * (<span class="number">17</span> - <span class="number">2</span> * (LightMapColor.a * <span class="number">4</span> + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    float2 RampUV = float2(RampX, RampY);</span><br><span class="line">    float4 rampColor = SAMPLE_TEXTURE2D(_RampMap, sampler_RampMap, RampUV);</span><br><span class="line">    half4 FinalRamp = lerp(rampColor * BaseColor * _ShadowColor, BaseColor, <span class="built_in">step</span>(_RampShadowRange, halfLambert * ShadowAO));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —</span></span><br><span class="line">    <span class="comment">// Hair Ramp</span></span><br><span class="line">    <span class="meta">#if _SHADERENUM_HAIR</span></span><br><span class="line">        <span class="keyword">if</span> (_IsNight == <span class="number">0.0</span>)</span><br><span class="line">            RampY = RampPixelY * (<span class="number">33</span> - <span class="number">2</span> * lerp(<span class="number">1</span>, <span class="number">3</span>, <span class="built_in">step</span>(<span class="number">0.5</span>, LightMapColor.a)));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            RampY = RampPixelY * (<span class="number">17</span> - <span class="number">2</span> * lerp(<span class="number">1</span>, <span class="number">3</span>, <span class="built_in">step</span>(<span class="number">0.5</span>, LightMapColor.a)));</span><br><span class="line">        RampUV = float2(RampX, RampY);</span><br><span class="line">        rampColor = SAMPLE_TEXTURE2D(_RampMap, sampler_RampMap, RampUV);</span><br><span class="line">        FinalRamp = lerp(rampColor * BaseColor * _ShadowColor, BaseColor, <span class="built_in">step</span>(_RampShadowRange, halfLambert * ShadowAO));</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">return</span> FinalRamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>效果：<br>![ZI398D)TP5PM$62<a href="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651941704059-c5b9d628-9546-4565-929a-ac9256f98fc0.png#averageHue=%23827d75&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=431&amp;id=ub864a92a&amp;originHeight=1186&amp;originWidth=1094&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=639886&amp;status=error&amp;style=none&amp;taskId=ue435b9e1-c006-429e-867d-ba70a989ae0&amp;title=&amp;width=398">L%0O$Y5.png</a></p><h1 id="SDF脸部阴影"><a href="#SDF脸部阴影" class="headerlink" title="SDF脸部阴影"></a>SDF脸部阴影</h1><p>SDF这一块其实没啥好说的，相关的学习资料有很多，实现的过程也非常简单（虽然我被各种向量点乘绕了好久hhh）大概的原理是用一张黑白高度图作为阴影阈值，与Front向量和Light向量的点积做比较，从而精确地控制光线在不同角度下脸部的阴影形状。采用这种方法，可以很好的代替原先修正面部法线的复杂流程，轻松达到平滑面部阴影过渡的效果<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651987091496-58b9a171-9c02-40a4-ab8d-cdcce967bca6.png#averageHue=%2378806e&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=244&amp;id=udbc09483&amp;originHeight=612&amp;originWidth=796&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=501190&amp;status=error&amp;style=none&amp;taskId=udb7df1b5-254f-43ed-bd30-477955a5e3c&amp;title=&amp;width=318" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651987115690-7d1f8129-d298-4fec-9630-86e5a085bbb8.png#averageHue=%23494852&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=361&amp;id=u8fa26799&amp;originHeight=451&amp;originWidth=300&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=116751&amp;status=error&amp;style=none&amp;taskId=u50759dd5-e8e6-4c45-bf00-9917b974afd&amp;title=&amp;width=240" alt="H8{J97U1(C`PMHV]N$Q2{3B.png"><br>   伦勃朗光<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651976175303-456ffa3e-9325-495b-81ca-c38962587212.png#averageHue=%238a97c4&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=154&amp;id=u851f4f84&amp;originHeight=192&amp;originWidth=222&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80309&amp;status=error&amp;style=none&amp;taskId=ufcd4b50e-b0ce-418a-b2ef-ad82e8f1128&amp;title=&amp;width=177.6" alt="K)WFF8Y@}6IE{)C2QH8H{W7.png">             <img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651986423484-b8969508-6808-4843-a1de-e39ec32854bc.png#averageHue=%23b9a5d5&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=153&amp;id=ub020cd91&amp;originHeight=408&amp;originWidth=434&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=249483&amp;status=error&amp;style=none&amp;taskId=u64935fbf-4937-4c53-9fa1-80b7e9e16c5&amp;title=&amp;width=163.1999969482422" alt="image.png"><br>不用之前                                                  用了之后<br>立竿见影！</p><h2 id="资产生成"><a href="#资产生成" class="headerlink" title="资产生成"></a>资产生成</h2><p>因为学校数字图像处理课期末大作业的缘故，我对这方面进行了比较详细的研究。一共分为两种方法，一种靠SDF程序化生成，另一种直接在csp或ps用等高线画。其中后者不会在此详细说明，详情可以参考如下教程<br><a href="https://www.bilibili.com/video/BV16y4y1x7J1?">【教程】使用csp等高线填充工具制作三渲二面部阴影贴图_哔哩哔哩_bilibili</a><br>这里就简单配合几张图说下SDF做这张贴图怎么做</p><h3 id="8ssedt"><a href="#8ssedt" class="headerlink" title="8ssedt"></a>8ssedt</h3><p>有关什么是SDF可以去看看GAMES202 p5，或者直接看我笔记上实时阴影的部分，简单来说，它就是通过一个场定义出了平面或空间中每个点距其最近物体的最短距离，其中，S虽然翻译过来是有向（signed），但实际上它是一个标量场，只不过通过正负号标识出了物体的内外而已<br><a href="https://zhuanlan.zhihu.com/p/464408139">GAMES202高质量实时渲染-个人笔记：实时阴影</a><br>在这里，SDF的主要应用体现在几何形变上<br>关于SDF图的生成有一种交8ssedt的算法，主要用到了动态规划的思想<br><a href="https://zhuanlan.zhihu.com/p/337944099">Signed Distance Field</a><br>可运行程序：<br><a href="https://zhuanlan.zhihu.com/p/356185096">如何快速生成混合卡通光照图</a><br>整个过程分成了两个grid来做，每个grid有2个pass，一趟做下来会进八次循环……<br>我配合着做了几张动图，可能会比较好理解一点：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/23115229/1651982961735-a28193ec-9f6a-4f8a-b6f5-7e57e55ba2fa.gif#averageHue=%23e3e2e2&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=804&amp;id=u73f09072&amp;originHeight=1005&amp;originWidth=977&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=1197566&amp;status=error&amp;style=none&amp;taskId=u706ea2f2-a7a6-4473-bfcb-72734202e31&amp;title=&amp;width=781.6" alt="pass1_gif.gif"><br>第二个Pass大差不差：<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/23115229/1651989081551-cc28d698-8029-44fb-9bdd-949fb06c9a2e.gif#averageHue=%23e3e0e0&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=804&amp;id=u7031a37a&amp;originHeight=1005&amp;originWidth=977&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=403144&amp;status=error&amp;style=none&amp;taskId=u6ab32609-6e3e-4cda-a2b2-e6d8bd4b4bc&amp;title=&amp;width=781.6" alt="pass2_gif.gif"><br>算法优化：<br><a href="https://www.jianshu.com/p/58271568781d">记一次代码优化(C++)</a></p><h3 id="二值图融合"><a href="#二值图融合" class="headerlink" title="二值图融合"></a>二值图融合</h3><p>到这里，有些人可能还不是很清楚我们要干嘛。其实我们最终的目的很简单，就是将下面这几张二值图融合起来，而融合的参照，或者说插值所要用到的权重，就是我们上面生成的SDF<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651985366801-4798909a-16fb-40fe-88a8-920738265dfd.png#averageHue=%23a4a3a3&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;id=u6056f2ce&amp;originHeight=168&amp;originWidth=1090&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=26217&amp;status=error&amp;style=none&amp;taskId=u03e07cb1-00ac-42c8-9615-b022403e943&amp;title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651989678888-7d41bb27-2539-4043-8c6c-838a3c4bb181.png#averageHue=%232e2323&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=509&amp;id=u02b4da07&amp;originHeight=636&amp;originWidth=748&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=102251&amp;status=error&amp;style=none&amp;taskId=ufd184701-ace7-409e-9dd0-89dafe7753d&amp;title=&amp;width=598.4" alt="blend.png"><br>试图解释…<br>还是直接上代码吧：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> scale = <span class="number">1.f</span> / (images.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">0</span>, i = images.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i, ++step)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; imageHeight; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; imageWidth; ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// lerp</span></span><br><span class="line">            <span class="type">int</span> sdf_index = y * imageWidth + x;</span><br><span class="line">            <span class="type">int</span> pixel_index = sdf_index * imageChannel;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> left_border_index = i;</span><br><span class="line">            <span class="type">int</span> right_border_index = i - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> sdf1 = images[left_border_index]-&gt;sdf[sdf_index] / <span class="number">255.f</span>;</span><br><span class="line">            <span class="type">float</span> sdf2 = images[right_border_index]-&gt;sdf[sdf_index] / <span class="number">255.f</span>;</span><br><span class="line">            sdf1 = <span class="number">2.f</span> * sdf1 - <span class="number">1.f</span>;</span><br><span class="line">            sdf2 = <span class="number">2.f</span> * sdf2 - <span class="number">1.f</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> left = step * scale;</span><br><span class="line">            <span class="type">float</span> right = (step + <span class="number">1</span>) * scale;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sdf1 * sdf2 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (right_border_index == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sdf1 &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; imageChannel; ++c)</span><br><span class="line">                            image[pixel_index + c] = <span class="number">255</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sdf1 &lt; 0 , sdf2 &gt; 0</span></span><br><span class="line">                <span class="type">float</span> totalDis = <span class="built_in">abs</span>(sdf1) + <span class="built_in">abs</span>(sdf2);</span><br><span class="line">                <span class="type">float</span> t = <span class="built_in">abs</span>(sdf2) / totalDis;</span><br><span class="line">                t = <span class="number">1</span> - t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; imageChannel; ++c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">float</span> dst = left * (<span class="number">1</span> - t) + (right * t);</span><br><span class="line">                    <span class="comment">// dst = std::pow(dst, 1 / 2.2f); // gamma for linear display</span></span><br><span class="line">                    image[pixel_index + c] = dst * <span class="number">255</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>看不懂可以去看下面这篇的后半部分<br><a href="https://blog.csdn.net/qjh5606/article/details/119958786">图形学基础|基于SDF的卡通阴影图_桑来93的博客-CSDN博客_sdf图</a></p><h2 id="使用贴图"><a href="#使用贴图" class="headerlink" title="使用贴图"></a>使用贴图</h2><p>最后终于到怎么使用阴影图了，老样子我还是把我参考的文章放在前面<br><a href="https://zhuanlan.zhihu.com/p/279334552">神作面部阴影渲染还原</a><br>核心代码就一行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">lerp</span>(BaseColor, ShadowColor, <span class="built_in">step</span>(FaceMap.r, <span class="number">1</span>-FdotL));</span><br></pre></td></tr></table></figure><br>一开始当 FdotL=0 时，脸上开始出现被照亮的区域，随着F和L的夹角减小，FdotL增大，1-FdotL减小，脸上越来越多的区域被判断为亮面，直到 FdotL=1 完全受光<br>在这之后，灯光向量通过RdotL=0的临界点，贴图UV进行一次翻转，以完全相反的过程重复一遍采样，即1-FdotL增大，阴影面积相应增加<br>伪代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (RdotL &lt; <span class="number">0</span>)</span><br><span class="line">FaceMap = FaceMap;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">FaceMap = FaceMapInverse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FaceMap.r &gt; <span class="number">1</span>-FdotL)</span><br><span class="line">    <span class="keyword">return</span> BaseColor;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ShadowColor;</span><br></pre></td></tr></table></figure><br>画了一张图描述这个过程，长下面这样：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651990428473-0f1604ee-cf57-4f8d-a3c5-08daa0fa8761.png#averageHue=%23eae9e9&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=394&amp;id=ua26cb363&amp;originHeight=492&amp;originWidth=1182&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=55257&amp;status=error&amp;style=none&amp;taskId=ub1dd3717-663d-42dd-897f-a9bf7526616&amp;title=&amp;width=945.6" alt="V%FB%610S$])5KSHM~WVQ4P.png"><br>到这一步，我们的效果就基本已经完成了，下面强调几个注意点<br>第一，贴图翻转是对UV进行水平翻转，不能在采样结果上做1-x运算，即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> FaceMap = <span class="built_in">lerp</span>(LightMapColor.r, <span class="number">1</span>-LightMapColor.r, <span class="built_in">step</span>(<span class="number">0</span>, RdotL)) * <span class="built_in">step</span>(<span class="number">0</span>, FdotL);</span><br></pre></td></tr></table></figure><br>第二，出现头发阴影与脸部阴影对不上的问题的时候，不能直接在采样数据上±Offset，会导致阴影跳变，解决方案是像雪羽大佬那样，构建一个旋转矩阵对灯管向量进行偏移<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> sinx = <span class="built_in">sin</span>(_FaceShadowOffset);</span><br><span class="line"><span class="type">float</span> cosx = <span class="built_in">cos</span>(_FaceShadowOffset);</span><br><span class="line">float2x2 rotationOffset1 = <span class="built_in">float2x2</span>(cosx, sinx, -sinx, cosx); <span class="comment">//顺时针偏移</span></span><br><span class="line">float2x2 rotationOffset2 = <span class="built_in">float2x2</span>(cosx, -sinx, sinx, cosx); <span class="comment">//逆时针偏移</span></span><br><span class="line">float2 FaceLightDir = <span class="built_in">lerp</span>(<span class="built_in">mul</span>(rotationOffset1, lightDir.xz), <span class="built_in">mul</span>(rotationOffset2, lightDir.xz), <span class="built_in">step</span>(<span class="number">0</span>, RdotL));</span><br></pre></td></tr></table></figure><br>第三，编写完代码之后通常会发现阴影会出现很难看的锯齿，这时候需要回到编辑器将贴图mipmap关掉，并将其类型设置为shadowmask<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651994895584-4d2b7677-87d5-44fa-8db5-0c0f727c3f71.png#averageHue=%234f4c4b&amp;clientId=u357d18e8-45ea-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=821&amp;id=u86b28548&amp;originHeight=1026&amp;originWidth=1921&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=838342&amp;status=error&amp;style=none&amp;taskId=u397a7a63-4808-40b9-98db-88e9f591333&amp;title=&amp;width=1536.8" alt="Z~%6V2}%MYHR{WV]1M88NJH.png"><br>大功告成！（完整代码在文章末尾）</p><h1 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h1><p>高光这里大量借鉴了清清的做法（链接在上面），分成了step高光，blinn-phong和matcap金属高光，不过目前好像在最后混合的时候出了点问题，以后有机会修一修吧（必须修！）<br>头发的高光也没特别细调，只是把blinn-phong和metal全关了稍微调了调裁边视角光，后面打算把各向异性也加上，期末周了真的顾不上……<br>代码（没什么借鉴意义）：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高光</span></span><br><span class="line">half4 BlinnPhongSpecular;</span><br><span class="line">half4 MetalSpecular;</span><br><span class="line">half4 StepSpecular;</span><br><span class="line">half4 FinalSpecular;</span><br><span class="line"><span class="comment">// ILM的R通道，灰色为裁边视角高光</span></span><br><span class="line">half StepMask = <span class="built_in">step</span>(<span class="number">0.2</span>, LightMapColor.r) - <span class="built_in">step</span>(<span class="number">0.8</span>, LightMapColor.r);</span><br><span class="line">StepSpecular = <span class="built_in">step</span>(<span class="number">1</span> - _StepSpecularGloss, saturate(<span class="built_in">dot</span>(i.worldNormal, viewDir))) * _StepSpecularIntensity * StepMask;</span><br><span class="line"><span class="comment">// ILM的R通道，白色为 Blinn-Phong + 金属高光</span></span><br><span class="line">half MetalMask = <span class="built_in">step</span>(<span class="number">0.9</span>, LightMapColor.r);</span><br><span class="line"><span class="comment">// Blinn-Phong</span></span><br><span class="line">BlinnPhongSpecular = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(i.worldNormal, halfDir)), _BlinnPhongSpecularGloss) * _BlinnPhongSpecularIntensity * MetalMask;</span><br><span class="line"><span class="comment">// 金属高光</span></span><br><span class="line">float2 MetalMapUV = mul((float3x3) UNITY_MATRIX_V, i.worldNormal).xy * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> MetalMap = SAMPLE_TEXTURE2D(_MetalMap, sampler_MetalMap, MetalMapUV).r;</span><br><span class="line">MetalMap = <span class="built_in">step</span>(_MetalSpecularGloss, MetalMap);</span><br><span class="line">MetalSpecular = MetalMap * _MetalSpecularIntensity * MetalMask;</span><br><span class="line">                </span><br><span class="line">FinalSpecular = StepSpecular + BlinnPhongSpecular + MetalSpecular;</span><br><span class="line">FinalSpecular = lerp(<span class="number">0</span>, BaseColor * FinalSpecular * _SpecularColor, LightMapColor.b) ;</span><br><span class="line">FinalSpecular *= halfLambert * ShadowAO * _EnableSpecular;</span><br></pre></td></tr></table></figure><br>效果：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651942862523-38ec19a2-9cac-44d7-a766-e7f7c0261b91.png#averageHue=%23a0c5d1&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=280&amp;id=udb83753a&amp;originHeight=421&amp;originWidth=559&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=316632&amp;status=error&amp;style=none&amp;taskId=u9c6397b3-40a5-4e61-8e12-dcc1dbfeb84&amp;title=&amp;width=372" alt="I5`S)JPI%`74U[M$J5I1`SB.png](https://cdn.nlark.com/yuque/0/2022/png/23115229/1651942798102-7e676721-91dd-4fdc-ace7-276e24029f92.png#averageHue=%23817d75&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=337&amp;id=u6f53203a&amp;originHeight=819&amp;originWidth=857&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=426443&amp;status=error&amp;style=none&amp;taskId=u424e449b-19d2-426c-9fc9-c43ef50661f&amp;title=&amp;width=352.6000061035156)![OF4G]%7__70EWC%Z4GFVVAC.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651942892590-d027cd81-6609-4575-872f-b44e798a520d.png#averageHue=%239fc6d2&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=250&amp;id=ua20fab94&amp;originHeight=478&amp;originWidth=703&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=419152&amp;status=error&amp;style=none&amp;taskId=ud911ff1b-cf73-4d2e-a109-13e35dab84b&amp;title=&amp;width=367.3999938964844" alt="DLWOSKR)VDW%{~}Z(A_N~6Q.png"><br>左图是单独调整的效果（叠加会爆白），右图是结合basecol调整后单独显示的结果（基本等于没有…）</p><h1 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h1><p>再来看边缘光部分，现在主流的边缘光实现方式基本就两种，一种菲涅尔，一种屏幕空间等距边缘光，当然也可以两种都用，但据我观察，原神的边缘光并不具备随视角变化而变化的特性，加上反而感觉有些画蛇添足，所以我这里就没加<br>屏幕空间等距边缘光的实现原理的话，可以参考下面这两篇文章，大概思路就是在原先模型深度的基础上沿法线方向外扩一段距离，再拿它和原深度值比较，二者深度差大于某个阈值的时候即判定为边缘<br><a href="https://zhuanlan.zhihu.com/p/365339160">Unity URP Shader 与 HLSL 自学笔记六 等宽屏幕空间边缘光</a><br><a href="https://zhuanlan.zhihu.com/p/139290492">【JTRP】屏幕空间深度边缘光 Screen Space Depth Rimlight</a><br>有点像描边，但不用开新的pass，直接在片元做就完事了。我这里把之前用来做描边用的平滑法线复用了一下，虽然感觉没啥必要…代价就多了次矩阵运算，所以加不加就见仁见智吧<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得打开摄像机的深度纹理</span></span><br><span class="line">TEXTURE2D(_CameraDepthTexture); SAMPLER(sampler_CameraDepthTexture);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕空间深度等宽边缘光</span></span><br><span class="line"><span class="comment">// 屏幕空间UV</span></span><br><span class="line">float2 RimScreenUV = float2(i.pos.x / _ScreenParams.x, i.pos.y / _ScreenParams.y);</span><br><span class="line"><span class="comment">// 法线外扩偏移UV，把worldNormal转换到NDC空间</span></span><br><span class="line">float3 smoothNormal = <span class="built_in">normalize</span>(UnpackNormalmapRGorAG(i.color));</span><br><span class="line">float3x3 tangentTransform = float3x3(i.worldTangent, i.worldBiTangent, i.worldNormal);</span><br><span class="line">float3 worldRimNormal = <span class="built_in">normalize</span>(mul(smoothNormal, tangentTransform));</span><br><span class="line">float2 RimOffsetUV = float2(mul((float3x3) UNITY_MATRIX_V, worldRimNormal).xy * _RimOffset * <span class="number">0.01</span> / i.pos.w);</span><br><span class="line">RimOffsetUV += RimScreenUV;</span><br><span class="line">                </span><br><span class="line"><span class="type">float</span> ScreenDepth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, RimScreenUV);</span><br><span class="line"><span class="type">float</span> Linear01ScreenDepth = LinearEyeDepth(ScreenDepth, _ZBufferParams);</span><br><span class="line"><span class="type">float</span> OffsetDepth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, RimOffsetUV);</span><br><span class="line"><span class="type">float</span> Linear01OffsetDepth = LinearEyeDepth(OffsetDepth, _ZBufferParams);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> diff = Linear01OffsetDepth - Linear01ScreenDepth;</span><br><span class="line"><span class="type">float</span> rimMask = <span class="built_in">step</span>(_RimThreshold * <span class="number">0.1</span>, diff);</span><br><span class="line"><span class="comment">// 边缘光颜色的a通道用来控制边缘光强弱</span></span><br><span class="line">half4 RimColor = float4(rimMask * _RimColor.rgb * _RimColor.a, <span class="number">1</span>) * _EnableRim;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123;&quot;LightMode&quot; = &quot;DepthOnly&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>插句题外话，这里是将世界法线转到NDC，除以w没什么好说的，而《入门精要》p275 讲到有关深度和法线纹理的效果的时候，从NDC重建世界坐标也做了一次“透视除法”，虽然这个和这里边缘光没啥关系，但当时看这里对这个步骤困惑了很久，想了想还是放在这里一并记下吧<br><img src="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651674911792-958413b7-5374-45bf-8fe9-9f53cd81e8df.png#averageHue=%23f8f8f8&amp;clientId=ua34e33ef-0961-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=393&amp;id=u63fee7e8&amp;originHeight=491&amp;originWidth=573&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54649&amp;status=error&amp;style=none&amp;taskId=u64632915-1fbf-407f-8883-8e14df37fd1&amp;title=&amp;width=458.4" alt="FO~D]G9%]QA9T~46(KUODL5.png"><br>效果：<br>![0%CRZY3XALS6}57S)P@<a href="https://cdn.nlark.com/yuque/0/2022/png/23115229/1651945531979-45f52b43-4599-4e80-8cf0-3ad8351bfb4e.png#averageHue=%234c4c4b&amp;clientId=u32c63bef-2a11-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=379&amp;id=u270c7938&amp;originHeight=474&amp;originWidth=537&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=140985&amp;status=error&amp;style=none&amp;taskId=u9076feac-152d-4a0f-a3d2-70c62a77115&amp;title=&amp;width=429.6">OXE.png</a><br>prprpr<br>调整的过程中，需要注意边缘光是辅助元素，不能太过显眼，借用月神的话来说，就只要调到那种“不仔细看察觉不到”的程度即可（除非是风格需要）</p><h1 id="总结-amp-Future-Works"><a href="#总结-amp-Future-Works" class="headerlink" title="总结 &amp; Future Works"></a>总结 &amp; Future Works</h1><p>完整代码github链接：<br><a href="https://github.com/YuiLu/GenshinCharacterShading">GitHub - YuiLu/GenshinCharacterShading: 通过编写一个仿原神渲染的shader，来学习URP和卡通渲染相关知识</a><br>除了某些显而易见的bug，还有很多个性化调整的点，比如shadow和shadowAO色调分离，Rim边缘软硬控制，body上第二层halfLambert等等等等，不胜枚举，目前计划是等暑假多学点东西之后，先把高光的问题修了（还有皮肤也有问题），在看着实现下头发的各向异性和眼睛的PBR…未来的工作还有很多，希望有一天能成为喵刀colin那样的大佬吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blogs </tag>
            
            <tag> 卡通渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B样条曲线-个人笔记</title>
      <link href="/posts/16402.html"/>
      <url>/posts/16402.html</url>
      
        <content type="html"><![CDATA[<p>参考课程：</p><a href="https://www.bilibili.com/video/BV1R4411W7FL/?p=111&vd_source=e94af411b63e78479c47cf227d55bab8" target="_blank" title="8.5.1 B样条曲线产生背景及定义" referrerpolicy="no-referrer" class="link_card"><div class="link_icon"><svg t="1670307855063" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="19066" width="200" height="200"><path d="M504.064 516.608m-384.256 0a384.256 384.256 0 1 0 768.512 0 384.256 384.256 0 1 0-768.512 0Z" fill="#009CF5" p-id="19068"/><path d="M746.112 270.464L472.448 485.12l63.104 63.104L750.08 274.56c2.304-2.688-1.28-6.144-3.968-4.096z" fill="#FF4C3A" p-id="19069"/><path d="M262.016 762.752l273.664-214.528-63.104-63.104-214.656 273.536c-2.176 2.688 1.28 6.144 4.096 4.096z" fill="#FFFFFF" p-id="19070"/><path d="M505.216 155.136c-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.56 5.888 5.888 5.888s5.888-2.56 5.888-5.888v-53.504c-0.128-3.2-2.688-5.888-5.888-5.888zM442.368 160.512c-3.2 0.512-5.376 3.584-4.736 6.784l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736zM396.288 234.368c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552l-18.304-50.304c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552l18.304 50.304zM348.928 257.408c1.664 2.816 5.248 3.712 7.936 2.176s3.712-5.248 2.176-7.936l-26.752-46.336c-1.664-2.816-5.248-3.712-7.936-2.176-2.816 1.664-3.712 5.248-2.176 7.936l26.752 46.336zM306.304 288.256c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.432 2.048-2.816 5.76-0.768 8.192l34.432 40.96zM269.696 326.144c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-2.048 2.432-1.792 6.144 0.768 8.192l40.96 34.432zM193.792 342.912l46.336 26.752c2.816 1.664 6.4 0.64 7.936-2.176 1.664-2.816 0.64-6.4-2.176-8.064L199.552 332.8c-2.816-1.664-6.4-0.64-7.936 2.176-1.664 2.688-0.64 6.272 2.176 7.936zM168.32 399.488l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM207.872 457.344l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784zM201.984 509.568H148.48c-3.2 0-5.888 2.56-5.888 5.888 0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888zM205.44 562.176l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.376 6.784 4.736l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784s-3.584-5.248-6.784-4.736zM217.856 613.376l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 3.072 4.48 4.608 7.552 3.456l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456zM238.976 661.504l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.816 5.248 3.712 8.064 2.176l46.336-26.752c2.816-1.664 3.712-5.248 2.176-8.064-1.664-2.816-5.248-3.712-8.064-2.176zM268.16 705.408l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.432 5.76 2.816 8.192 0.768l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-1.92-2.56-5.632-2.816-8.192-0.768zM304.512 743.424l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.304-1.92-6.016-1.664-8.192 0.768zM347.008 774.656l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.664 6.4 0.64 8.064-2.176l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.536-6.4-0.64-8.064 2.176zM394.24 798.08l-18.304 50.304c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.152 6.4-0.512 7.552-3.456l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.528 0.384-7.552 3.456zM440.192 872.32c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.64 3.2 1.536 6.272 4.736 6.784zM502.912 878.08c3.2 0 5.888-2.56 5.888-5.888v-53.504c0-3.2-2.56-5.888-5.888-5.888-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.688 5.888 5.888 5.888zM549.632 815.232l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736-3.2 0.512-5.248 3.584-4.736 6.784zM600.832 802.816l18.304 50.304c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552L611.84 798.72c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552zM649.088 781.696l26.752 46.336c1.664 2.816 5.248 3.712 8.064 2.176 2.816-1.664 3.712-5.248 2.176-8.064l-26.88-46.336c-1.664-2.816-5.248-3.712-8.064-2.176-2.816 1.664-3.712 5.248-2.048 8.064zM692.864 752.384l34.432 40.96c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.56 2.048-2.816 5.76-0.768 8.192zM730.88 716.032l40.96 34.432c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-1.92 2.432-1.664 6.144 0.768 8.192zM762.112 673.664l46.336 26.752c2.816 1.664 6.4 0.64 8.064-2.176 1.664-2.816 0.64-6.4-2.176-7.936L768 663.552c-2.816-1.664-6.4-0.64-8.064 2.176-1.536 2.688-0.64 6.272 2.176 7.936zM785.536 626.432l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM800.256 575.872l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784zM800.256 517.76c0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888h-53.504c-3.328 0-5.888 2.56-5.888 5.888zM802.688 471.04l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784-0.512-3.2-3.584-5.376-6.784-4.736l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.248 6.784 4.736zM790.272 419.84l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 2.944 4.48 4.608 7.552 3.456zM769.152 371.584l46.336-26.752c2.816-1.664 3.712-5.248 2.176-7.936-1.664-2.816-5.248-3.712-8.064-2.176l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.688 5.248 3.712 8.064 2.048zM739.84 327.808l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-2.048-2.432-5.76-2.816-8.192-0.768l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.56 5.76 2.816 8.192 0.768zM703.488 289.664l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.432-2.048-6.144-1.792-8.192 0.768l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768zM661.12 258.56l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.664-6.4-0.64-8.064 2.176l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.536 6.4 0.64 8.064-2.176zM613.888 235.136l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.4 0.512-7.552 3.456L602.88 231.168c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.024 6.4-0.512 7.552-3.584zM556.544 225.152c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.512 3.2 1.536 6.144 4.736 6.784zM273.536 290.432c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96l21.12 21.12zM237.824 333.824c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536s-1.28 6.912 1.536 8.832l24.448 17.152zM183.04 370.176l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 7.04 3.072 8.448zM194.688 423.68l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.152 6.912 4.48 7.808l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808zM183.168 478.72l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.456 2.304 6.656 5.76 6.912l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.384-3.456-2.176-6.528-5.76-6.912zM181.504 535.04l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.456 6.144 6.912 5.76l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.328-6.016-6.912-5.76zM191.36 590.72l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.352 5.376 7.808 4.48l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.328-4.352-5.376-7.808-4.48zM207.232 644.224l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.2 5.248 4.608 8.448 3.072l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.408-3.2-5.248-4.48-8.448-3.072zM233.984 693.888l-24.448 17.152c-2.944 2.048-3.584 6.016-1.536 8.832 2.048 2.944 6.016 3.584 8.832 1.536l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536zM310.912 775.552L293.76 800c-2.048 2.944-1.28 6.912 1.536 8.832 2.944 2.048 6.912 1.28 8.832-1.536l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.816-2.048-6.912-1.408-8.832 1.536zM349.184 840.704c3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.536-3.2 0.128-7.04-3.072-8.448-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.408 3.2-0.128 6.912 3.072 8.448zM407.808 862.72c3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c0.896-3.456-1.152-6.912-4.48-7.808-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.328 1.152 6.912 4.48 7.808zM469.376 874.112c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.584 2.304 6.656 5.76 6.912zM522.496 839.168l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.456-6.144-6.912-5.76-3.456 0.256-6.016 3.328-5.76 6.912zM578.176 830.976l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928c-0.896-3.456-4.352-5.376-7.808-4.48-3.328 0.896-5.376 4.48-4.48 7.808zM631.68 813.312l12.672 27.136c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.248 3.072-8.448l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.48 5.248-3.072 8.448zM681.344 786.688l17.152 24.448c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 1.92-3.584 5.888-1.536 8.832zM725.504 751.744l21.12 21.12c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96zM763.008 709.76l24.448 17.152c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536-2.048 2.816-1.408 6.784 1.536 8.832zM792.576 661.888l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 6.912 3.072 8.448zM813.44 609.536l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.024 6.912 4.48 7.808zM824.832 554.368l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.256-3.456-2.304-6.656-5.76-6.912l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.584 2.304 6.656 5.76 6.912zM826.624 498.176l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.456-6.144-6.912-5.76l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.328 6.016 6.912 5.76zM818.432 442.368l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.456-4.352-5.376-7.808-4.48l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.48 5.376 7.808 4.48zM800.768 388.992l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.536-3.2-5.248-4.608-8.448-3.072l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.072 5.248 4.48 8.448 3.072zM774.144 339.328l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536L766.848 328.96c-2.944 2.048-3.584 6.016-1.536 8.832 1.92 2.816 5.888 3.584 8.832 1.536zM697.216 257.664l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.944-2.048-6.912-1.28-8.832 1.536l-17.152 24.448c-2.048 2.944-1.28 6.912 1.536 8.832 2.816 2.048 6.784 1.408 8.832-1.536zM658.944 192.512c-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.536 3.2-0.128 7.04 3.072 8.448 3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.408-3.2 0-7.04-3.072-8.448zM600.192 170.496c-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.456 1.152 6.912 4.48 7.808 3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c1.024-3.328-1.024-6.912-4.48-7.808zM534.912 201.6c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.456 2.304 6.528 5.76 6.912zM476.032 158.464c-3.456 0.256-6.144 3.456-5.76 6.912l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.328-6.016-6.912-5.76zM422.144 173.312c-0.896-3.456-4.352-5.376-7.808-4.48-3.456 0.896-5.376 4.352-4.48 7.808l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928zM376.448 219.776l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.608 5.248-3.072 8.448L364.8 225.28c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.376 3.2-8.576zM316.416 253.824c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 2.048-3.584 6.016-1.536 8.832l17.152 24.448z" fill="#FFFFFF" p-id="19071"/></svg></div><div class="link_content"><div class="link_title">8.5.1 B样条曲线产生背景及定义</div></div></a><p>辅助理解：</p><a href="https://zhuanlan.zhihu.com/p/50626506" target="_blank" title="我好饱啊：简单粗暴：B-样条曲线入门" referrerpolicy="no-referrer" class="link_card"><div class="link_icon"><svg t="1670307855063" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="19066" width="200" height="200"><path d="M504.064 516.608m-384.256 0a384.256 384.256 0 1 0 768.512 0 384.256 384.256 0 1 0-768.512 0Z" fill="#009CF5" p-id="19068"/><path d="M746.112 270.464L472.448 485.12l63.104 63.104L750.08 274.56c2.304-2.688-1.28-6.144-3.968-4.096z" fill="#FF4C3A" p-id="19069"/><path d="M262.016 762.752l273.664-214.528-63.104-63.104-214.656 273.536c-2.176 2.688 1.28 6.144 4.096 4.096z" fill="#FFFFFF" p-id="19070"/><path d="M505.216 155.136c-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.56 5.888 5.888 5.888s5.888-2.56 5.888-5.888v-53.504c-0.128-3.2-2.688-5.888-5.888-5.888zM442.368 160.512c-3.2 0.512-5.376 3.584-4.736 6.784l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736zM396.288 234.368c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552l-18.304-50.304c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552l18.304 50.304zM348.928 257.408c1.664 2.816 5.248 3.712 7.936 2.176s3.712-5.248 2.176-7.936l-26.752-46.336c-1.664-2.816-5.248-3.712-7.936-2.176-2.816 1.664-3.712 5.248-2.176 7.936l26.752 46.336zM306.304 288.256c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.432 2.048-2.816 5.76-0.768 8.192l34.432 40.96zM269.696 326.144c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-2.048 2.432-1.792 6.144 0.768 8.192l40.96 34.432zM193.792 342.912l46.336 26.752c2.816 1.664 6.4 0.64 7.936-2.176 1.664-2.816 0.64-6.4-2.176-8.064L199.552 332.8c-2.816-1.664-6.4-0.64-7.936 2.176-1.664 2.688-0.64 6.272 2.176 7.936zM168.32 399.488l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM207.872 457.344l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784zM201.984 509.568H148.48c-3.2 0-5.888 2.56-5.888 5.888 0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888zM205.44 562.176l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.376 6.784 4.736l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784s-3.584-5.248-6.784-4.736zM217.856 613.376l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 3.072 4.48 4.608 7.552 3.456l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456zM238.976 661.504l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.816 5.248 3.712 8.064 2.176l46.336-26.752c2.816-1.664 3.712-5.248 2.176-8.064-1.664-2.816-5.248-3.712-8.064-2.176zM268.16 705.408l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.432 5.76 2.816 8.192 0.768l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-1.92-2.56-5.632-2.816-8.192-0.768zM304.512 743.424l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.304-1.92-6.016-1.664-8.192 0.768zM347.008 774.656l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.664 6.4 0.64 8.064-2.176l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.536-6.4-0.64-8.064 2.176zM394.24 798.08l-18.304 50.304c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.152 6.4-0.512 7.552-3.456l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.528 0.384-7.552 3.456zM440.192 872.32c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.64 3.2 1.536 6.272 4.736 6.784zM502.912 878.08c3.2 0 5.888-2.56 5.888-5.888v-53.504c0-3.2-2.56-5.888-5.888-5.888-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.688 5.888 5.888 5.888zM549.632 815.232l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736-3.2 0.512-5.248 3.584-4.736 6.784zM600.832 802.816l18.304 50.304c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552L611.84 798.72c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552zM649.088 781.696l26.752 46.336c1.664 2.816 5.248 3.712 8.064 2.176 2.816-1.664 3.712-5.248 2.176-8.064l-26.88-46.336c-1.664-2.816-5.248-3.712-8.064-2.176-2.816 1.664-3.712 5.248-2.048 8.064zM692.864 752.384l34.432 40.96c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.56 2.048-2.816 5.76-0.768 8.192zM730.88 716.032l40.96 34.432c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-1.92 2.432-1.664 6.144 0.768 8.192zM762.112 673.664l46.336 26.752c2.816 1.664 6.4 0.64 8.064-2.176 1.664-2.816 0.64-6.4-2.176-7.936L768 663.552c-2.816-1.664-6.4-0.64-8.064 2.176-1.536 2.688-0.64 6.272 2.176 7.936zM785.536 626.432l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM800.256 575.872l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784zM800.256 517.76c0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888h-53.504c-3.328 0-5.888 2.56-5.888 5.888zM802.688 471.04l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784-0.512-3.2-3.584-5.376-6.784-4.736l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.248 6.784 4.736zM790.272 419.84l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 2.944 4.48 4.608 7.552 3.456zM769.152 371.584l46.336-26.752c2.816-1.664 3.712-5.248 2.176-7.936-1.664-2.816-5.248-3.712-8.064-2.176l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.688 5.248 3.712 8.064 2.048zM739.84 327.808l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-2.048-2.432-5.76-2.816-8.192-0.768l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.56 5.76 2.816 8.192 0.768zM703.488 289.664l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.432-2.048-6.144-1.792-8.192 0.768l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768zM661.12 258.56l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.664-6.4-0.64-8.064 2.176l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.536 6.4 0.64 8.064-2.176zM613.888 235.136l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.4 0.512-7.552 3.456L602.88 231.168c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.024 6.4-0.512 7.552-3.584zM556.544 225.152c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.512 3.2 1.536 6.144 4.736 6.784zM273.536 290.432c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96l21.12 21.12zM237.824 333.824c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536s-1.28 6.912 1.536 8.832l24.448 17.152zM183.04 370.176l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 7.04 3.072 8.448zM194.688 423.68l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.152 6.912 4.48 7.808l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808zM183.168 478.72l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.456 2.304 6.656 5.76 6.912l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.384-3.456-2.176-6.528-5.76-6.912zM181.504 535.04l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.456 6.144 6.912 5.76l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.328-6.016-6.912-5.76zM191.36 590.72l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.352 5.376 7.808 4.48l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.328-4.352-5.376-7.808-4.48zM207.232 644.224l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.2 5.248 4.608 8.448 3.072l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.408-3.2-5.248-4.48-8.448-3.072zM233.984 693.888l-24.448 17.152c-2.944 2.048-3.584 6.016-1.536 8.832 2.048 2.944 6.016 3.584 8.832 1.536l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536zM310.912 775.552L293.76 800c-2.048 2.944-1.28 6.912 1.536 8.832 2.944 2.048 6.912 1.28 8.832-1.536l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.816-2.048-6.912-1.408-8.832 1.536zM349.184 840.704c3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.536-3.2 0.128-7.04-3.072-8.448-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.408 3.2-0.128 6.912 3.072 8.448zM407.808 862.72c3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c0.896-3.456-1.152-6.912-4.48-7.808-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.328 1.152 6.912 4.48 7.808zM469.376 874.112c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.584 2.304 6.656 5.76 6.912zM522.496 839.168l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.456-6.144-6.912-5.76-3.456 0.256-6.016 3.328-5.76 6.912zM578.176 830.976l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928c-0.896-3.456-4.352-5.376-7.808-4.48-3.328 0.896-5.376 4.48-4.48 7.808zM631.68 813.312l12.672 27.136c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.248 3.072-8.448l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.48 5.248-3.072 8.448zM681.344 786.688l17.152 24.448c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 1.92-3.584 5.888-1.536 8.832zM725.504 751.744l21.12 21.12c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96zM763.008 709.76l24.448 17.152c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536-2.048 2.816-1.408 6.784 1.536 8.832zM792.576 661.888l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 6.912 3.072 8.448zM813.44 609.536l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.024 6.912 4.48 7.808zM824.832 554.368l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.256-3.456-2.304-6.656-5.76-6.912l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.584 2.304 6.656 5.76 6.912zM826.624 498.176l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.456-6.144-6.912-5.76l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.328 6.016 6.912 5.76zM818.432 442.368l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.456-4.352-5.376-7.808-4.48l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.48 5.376 7.808 4.48zM800.768 388.992l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.536-3.2-5.248-4.608-8.448-3.072l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.072 5.248 4.48 8.448 3.072zM774.144 339.328l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536L766.848 328.96c-2.944 2.048-3.584 6.016-1.536 8.832 1.92 2.816 5.888 3.584 8.832 1.536zM697.216 257.664l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.944-2.048-6.912-1.28-8.832 1.536l-17.152 24.448c-2.048 2.944-1.28 6.912 1.536 8.832 2.816 2.048 6.784 1.408 8.832-1.536zM658.944 192.512c-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.536 3.2-0.128 7.04 3.072 8.448 3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.408-3.2 0-7.04-3.072-8.448zM600.192 170.496c-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.456 1.152 6.912 4.48 7.808 3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c1.024-3.328-1.024-6.912-4.48-7.808zM534.912 201.6c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.456 2.304 6.528 5.76 6.912zM476.032 158.464c-3.456 0.256-6.144 3.456-5.76 6.912l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.328-6.016-6.912-5.76zM422.144 173.312c-0.896-3.456-4.352-5.376-7.808-4.48-3.456 0.896-5.376 4.352-4.48 7.808l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928zM376.448 219.776l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.608 5.248-3.072 8.448L364.8 225.28c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.376 3.2-8.576zM316.416 253.824c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 2.048-3.584 6.016-1.536 8.832l17.152 24.448z" fill="#FFFFFF" p-id="19071"/></svg></div><div class="link_content"><div class="link_title">我好饱啊：简单粗暴：B-样条曲线入门</div></div></a><a href="https://zhuanlan.zhihu.com/p/144042470" target="_blank" title="沈经纬：深入理解B样条曲线（上）" referrerpolicy="no-referrer" class="link_card"><div class="link_icon"><svg t="1670307855063" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="19066" width="200" height="200"><path d="M504.064 516.608m-384.256 0a384.256 384.256 0 1 0 768.512 0 384.256 384.256 0 1 0-768.512 0Z" fill="#009CF5" p-id="19068"/><path d="M746.112 270.464L472.448 485.12l63.104 63.104L750.08 274.56c2.304-2.688-1.28-6.144-3.968-4.096z" fill="#FF4C3A" p-id="19069"/><path d="M262.016 762.752l273.664-214.528-63.104-63.104-214.656 273.536c-2.176 2.688 1.28 6.144 4.096 4.096z" fill="#FFFFFF" p-id="19070"/><path d="M505.216 155.136c-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.56 5.888 5.888 5.888s5.888-2.56 5.888-5.888v-53.504c-0.128-3.2-2.688-5.888-5.888-5.888zM442.368 160.512c-3.2 0.512-5.376 3.584-4.736 6.784l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736zM396.288 234.368c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552l-18.304-50.304c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552l18.304 50.304zM348.928 257.408c1.664 2.816 5.248 3.712 7.936 2.176s3.712-5.248 2.176-7.936l-26.752-46.336c-1.664-2.816-5.248-3.712-7.936-2.176-2.816 1.664-3.712 5.248-2.176 7.936l26.752 46.336zM306.304 288.256c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.432 2.048-2.816 5.76-0.768 8.192l34.432 40.96zM269.696 326.144c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-2.048 2.432-1.792 6.144 0.768 8.192l40.96 34.432zM193.792 342.912l46.336 26.752c2.816 1.664 6.4 0.64 7.936-2.176 1.664-2.816 0.64-6.4-2.176-8.064L199.552 332.8c-2.816-1.664-6.4-0.64-7.936 2.176-1.664 2.688-0.64 6.272 2.176 7.936zM168.32 399.488l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM207.872 457.344l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784zM201.984 509.568H148.48c-3.2 0-5.888 2.56-5.888 5.888 0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888zM205.44 562.176l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.376 6.784 4.736l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784s-3.584-5.248-6.784-4.736zM217.856 613.376l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 3.072 4.48 4.608 7.552 3.456l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456zM238.976 661.504l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.816 5.248 3.712 8.064 2.176l46.336-26.752c2.816-1.664 3.712-5.248 2.176-8.064-1.664-2.816-5.248-3.712-8.064-2.176zM268.16 705.408l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.432 5.76 2.816 8.192 0.768l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-1.92-2.56-5.632-2.816-8.192-0.768zM304.512 743.424l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.304-1.92-6.016-1.664-8.192 0.768zM347.008 774.656l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.664 6.4 0.64 8.064-2.176l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.536-6.4-0.64-8.064 2.176zM394.24 798.08l-18.304 50.304c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.152 6.4-0.512 7.552-3.456l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.528 0.384-7.552 3.456zM440.192 872.32c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.64 3.2 1.536 6.272 4.736 6.784zM502.912 878.08c3.2 0 5.888-2.56 5.888-5.888v-53.504c0-3.2-2.56-5.888-5.888-5.888-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.688 5.888 5.888 5.888zM549.632 815.232l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736-3.2 0.512-5.248 3.584-4.736 6.784zM600.832 802.816l18.304 50.304c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552L611.84 798.72c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552zM649.088 781.696l26.752 46.336c1.664 2.816 5.248 3.712 8.064 2.176 2.816-1.664 3.712-5.248 2.176-8.064l-26.88-46.336c-1.664-2.816-5.248-3.712-8.064-2.176-2.816 1.664-3.712 5.248-2.048 8.064zM692.864 752.384l34.432 40.96c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.56 2.048-2.816 5.76-0.768 8.192zM730.88 716.032l40.96 34.432c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-1.92 2.432-1.664 6.144 0.768 8.192zM762.112 673.664l46.336 26.752c2.816 1.664 6.4 0.64 8.064-2.176 1.664-2.816 0.64-6.4-2.176-7.936L768 663.552c-2.816-1.664-6.4-0.64-8.064 2.176-1.536 2.688-0.64 6.272 2.176 7.936zM785.536 626.432l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM800.256 575.872l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784zM800.256 517.76c0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888h-53.504c-3.328 0-5.888 2.56-5.888 5.888zM802.688 471.04l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784-0.512-3.2-3.584-5.376-6.784-4.736l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.248 6.784 4.736zM790.272 419.84l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 2.944 4.48 4.608 7.552 3.456zM769.152 371.584l46.336-26.752c2.816-1.664 3.712-5.248 2.176-7.936-1.664-2.816-5.248-3.712-8.064-2.176l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.688 5.248 3.712 8.064 2.048zM739.84 327.808l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-2.048-2.432-5.76-2.816-8.192-0.768l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.56 5.76 2.816 8.192 0.768zM703.488 289.664l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.432-2.048-6.144-1.792-8.192 0.768l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768zM661.12 258.56l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.664-6.4-0.64-8.064 2.176l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.536 6.4 0.64 8.064-2.176zM613.888 235.136l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.4 0.512-7.552 3.456L602.88 231.168c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.024 6.4-0.512 7.552-3.584zM556.544 225.152c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.512 3.2 1.536 6.144 4.736 6.784zM273.536 290.432c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96l21.12 21.12zM237.824 333.824c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536s-1.28 6.912 1.536 8.832l24.448 17.152zM183.04 370.176l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 7.04 3.072 8.448zM194.688 423.68l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.152 6.912 4.48 7.808l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808zM183.168 478.72l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.456 2.304 6.656 5.76 6.912l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.384-3.456-2.176-6.528-5.76-6.912zM181.504 535.04l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.456 6.144 6.912 5.76l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.328-6.016-6.912-5.76zM191.36 590.72l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.352 5.376 7.808 4.48l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.328-4.352-5.376-7.808-4.48zM207.232 644.224l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.2 5.248 4.608 8.448 3.072l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.408-3.2-5.248-4.48-8.448-3.072zM233.984 693.888l-24.448 17.152c-2.944 2.048-3.584 6.016-1.536 8.832 2.048 2.944 6.016 3.584 8.832 1.536l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536zM310.912 775.552L293.76 800c-2.048 2.944-1.28 6.912 1.536 8.832 2.944 2.048 6.912 1.28 8.832-1.536l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.816-2.048-6.912-1.408-8.832 1.536zM349.184 840.704c3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.536-3.2 0.128-7.04-3.072-8.448-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.408 3.2-0.128 6.912 3.072 8.448zM407.808 862.72c3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c0.896-3.456-1.152-6.912-4.48-7.808-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.328 1.152 6.912 4.48 7.808zM469.376 874.112c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.584 2.304 6.656 5.76 6.912zM522.496 839.168l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.456-6.144-6.912-5.76-3.456 0.256-6.016 3.328-5.76 6.912zM578.176 830.976l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928c-0.896-3.456-4.352-5.376-7.808-4.48-3.328 0.896-5.376 4.48-4.48 7.808zM631.68 813.312l12.672 27.136c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.248 3.072-8.448l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.48 5.248-3.072 8.448zM681.344 786.688l17.152 24.448c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 1.92-3.584 5.888-1.536 8.832zM725.504 751.744l21.12 21.12c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96zM763.008 709.76l24.448 17.152c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536-2.048 2.816-1.408 6.784 1.536 8.832zM792.576 661.888l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 6.912 3.072 8.448zM813.44 609.536l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.024 6.912 4.48 7.808zM824.832 554.368l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.256-3.456-2.304-6.656-5.76-6.912l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.584 2.304 6.656 5.76 6.912zM826.624 498.176l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.456-6.144-6.912-5.76l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.328 6.016 6.912 5.76zM818.432 442.368l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.456-4.352-5.376-7.808-4.48l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.48 5.376 7.808 4.48zM800.768 388.992l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.536-3.2-5.248-4.608-8.448-3.072l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.072 5.248 4.48 8.448 3.072zM774.144 339.328l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536L766.848 328.96c-2.944 2.048-3.584 6.016-1.536 8.832 1.92 2.816 5.888 3.584 8.832 1.536zM697.216 257.664l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.944-2.048-6.912-1.28-8.832 1.536l-17.152 24.448c-2.048 2.944-1.28 6.912 1.536 8.832 2.816 2.048 6.784 1.408 8.832-1.536zM658.944 192.512c-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.536 3.2-0.128 7.04 3.072 8.448 3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.408-3.2 0-7.04-3.072-8.448zM600.192 170.496c-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.456 1.152 6.912 4.48 7.808 3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c1.024-3.328-1.024-6.912-4.48-7.808zM534.912 201.6c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.456 2.304 6.528 5.76 6.912zM476.032 158.464c-3.456 0.256-6.144 3.456-5.76 6.912l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.328-6.016-6.912-5.76zM422.144 173.312c-0.896-3.456-4.352-5.376-7.808-4.48-3.456 0.896-5.376 4.352-4.48 7.808l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928zM376.448 219.776l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.608 5.248-3.072 8.448L364.8 225.28c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.376 3.2-8.576zM316.416 253.824c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 2.048-3.584 6.016-1.536 8.832l17.152 24.448z" fill="#FFFFFF" p-id="19071"/></svg></div><div class="link_content"><div class="link_title">沈经纬：深入理解B样条曲线（上）</div></div></a><h1 id="Bezier曲线缺点"><a href="#Bezier曲线缺点" class="headerlink" title="Bezier曲线缺点"></a>Bezier曲线缺点</h1><ul><li>Bezier曲线一旦确定了特征多边形的顶点数 <script type="math/tex">n+1</script> ，也就决定了曲线的阶次（n次）。如果阶数过高，则曲线中会有大量极值点，造成曲线波动现象明显</li><li>Bezier曲线或曲面的拼接比较复杂</li><li>Bezier曲线或曲面不能作局部修改，牵一发而动全身。因为每个Bernstein多项式在整个区间 <script type="math/tex">[0,1]</script> 上都有支撑，所以每个控制点对整条曲线都有影响<br><img src="https://pic4.zhimg.com/v2-21e0940ffebcf993b349f89c023c4cdb_r.jpg" alt="伯恩斯坦多项式"></li></ul><h1 id="B样条曲线"><a href="#B样条曲线" class="headerlink" title="B样条曲线"></a>B样条曲线</h1><p>采用分段连续多项式，整条曲线用一个完整的表达式表达，但表达式内部分量分段。使用低次曲线克服波动，使用分段多项式克服无法局部修改的局限</p><p>要求： <script type="math/tex">n+1</script> 个型值点，共 <script type="math/tex">n</script> 个区间，每个区间构造一个三次多项式，这 <script type="math/tex">n</script> 个三次多项式拼在一起可以表达出特定的曲线，且段与段之间需要满足 <script type="math/tex">C^2</script> 连续</p><p>数学表达式： <script type="math/tex">P(u)=\sum_{i=0}^nP_iB_{i,k}(u),u\in[u_{k-1},u_{n+1}]</script></p><p>其中 <script type="math/tex">P_i(i=0,1,\ldots,n)</script> 是控制多边形的顶点</p><script type="math/tex; mode=display">B_{i,k}(u)$$ 称为 $$k$$ 阶 $$k-1$$ 次B样条基函数， $$k$$ 刻画阶数， $$k\in[2,n+1]</script><p>对于Bezier曲线，阶数 = 次数；对于B样条曲线，阶数=次数+1</p><p>B样条基函数是一个称为节点向量的非递减的参数 <script type="math/tex">u</script> 的序列所决定的 <script type="math/tex">k</script> 阶分段多项式，这个序列称为节点向量， <script type="math/tex">u\in [u_{k-1},u_{n+1}]</script></p><p>de Boor-Cox 递推<br>每个 <script type="math/tex">k</script> 阶 <script type="math/tex">k-1</script> 次B样条基函数，都可以用低一次的两个基函数的线性组合构造</p><script type="math/tex; mode=display">\begin{aligned}B_{i,k}(u)&= \frac{u-u_i}{u_{i+k-1}-u_i}B_{i,k-1}(u)+ \frac{u_{i+k}-u}{u_{i+k}-u_{i+1}}B_{i+1,k-1}(u)\end{aligned}</script><p>以一次到三次基函数为例，给出表达式和图像如下：</p><script type="math/tex; mode=display">\begin{aligned}B_{i,1}(u)&=\begin{cases} 1&u_i</script><script type="math/tex; mode=display">B_{i,2}(u)= \begin{cases} \dfrac{u-u_i}{u_{i+1}-u_i}&u_i\leq u\leq u_{i+1}\\\\ \dfrac{u_{i+2}-u}{u_{i+2}-u_{i+1}}&u_{i+1}\leq u\leq u_{i+2}\\\\ 0&\text{其它} \end{cases}</script><script type="math/tex; mode=display">B_{i,3}(u)=\begin{cases} \dfrac{u-u_{i}}{u_{i+2}-u_{i}}\cdot \dfrac{u-u_{i}}{u_{i+1}-u_{i}},&u_{i}\leq u</script><p><img src="https://pic2.zhimg.com/80/v2-b867b7b18f52d7c2a06e479a79f305ad_720w.webp" alt></p><p>对于 <script type="math/tex">B_{i,1}</script> （1阶0次基函数）来说，涉及到 <script type="math/tex">u_i</script> 到 <script type="math/tex">u_{i+1}</script> 一个区间，即一阶的多项式涉及1个区间2个节点； <script type="math/tex">B_{i,2}</script> 由 <script type="math/tex">B_{i,1}</script> 和 <script type="math/tex">B_{i+1,1}</script> 组成，因此 <script type="math/tex">B_{i,2}</script> 涉及2个区间3个节点；同理 <script type="math/tex">B_{i,3}</script> 涉及3个区间4个节点，…， <script type="math/tex">k</script> 阶 <script type="math/tex">k-1</script> 次B样条基函数 <script type="math/tex">B_{i,k}(u)</script> 涉及 <script type="math/tex">k</script> 个区间 <script type="math/tex">k+1</script> 个节点，所有基函数从 <script type="math/tex">B_{0,k}(u)</script> 到 <script type="math/tex">B_{n,k}(u)</script> 共涉及 <script type="math/tex">n+k+1</script> 个节点（型值点个数+阶数=节点数）</p><p><img src="https://pic2.zhimg.com/v2-079accdf8de2730d3e702e24c55614e9_r.jpg" alt></p><p>如图， <script type="math/tex">k=4</script> ， <script type="math/tex">n=4</script> ，每个基函数涉及 <script type="math/tex">k+1=5</script> 个节点，共 <script type="math/tex">n+1=5</script> 个型值点，5个基函数，5个节点向量，涉及 <script type="math/tex">n+k+1=9</script> 个节点</p><p>具体来说， <script type="math/tex">B_{0,4}(u)</script> 涉及 <script type="math/tex">\{ u_0,u_1,u_2,u_3,u_4 \}</script> ， <script type="math/tex">B_{0,4}(u)</script> 涉及 <script type="math/tex">\{ u_1,u_2,u_3,u_4,u_5 \}</script> ，…， <script type="math/tex">B_{4,4}(u)</script> 涉及 <script type="math/tex">\{ u_4,u_5,u_6,u_7,u_8 \}</script> ，但区间合法的条件需要一个区间包括足够多的基函数支撑，也即有效区间是仅包括 <script type="math/tex">\{ u_3,u_4,u_5 \}</script> 这三个节点的区间，即 <script type="math/tex">[u_3,u_4]</script> 和 <script type="math/tex">[u_4,u_5]</script> 两段区间，所以原曲线可由2段3次曲线构成，更一般的， <script type="math/tex">n+1</script> 个型值点， <script type="math/tex">k</script> 阶B样条，可由 <script type="math/tex">n-k+2</script> 段 <script type="math/tex">k-1</script> 次曲线段组成（控制点个数 - 阶数 + 1）</p><p>B样条基函数性质<br>局部支承性： <script type="math/tex">B_{i,k}(u) \begin{cases} \ge0&u\in[u_i,u_{i+k}]\\ =0&其他 \end{cases}</script> ，而Bezier在整个区间非0。对每个区间 <script type="math/tex">(u_i,u_{i+k})</script> , 至多只有 <script type="math/tex">k</script> 个基函数在其上非零<br><img src="https://pic3.zhimg.com/v2-a33c112bbad65cfa151dcc32dd30d92a_r.jpg" alt></p><p>B样条基函数<br>权性：基函数权值之和=1， <script type="math/tex">\sum_{i=0}^nB_{i,k}(u)=1,u\in[u_{k-1},u_{n+1}]</script></p><p>连续性： <script type="math/tex">B_{i,k}(u)</script> 在 <script type="math/tex">r</script> 重节点处的连续阶不低于 <script type="math/tex">k-1-r</script></p><p>B样条曲线性质<br>局部性：k阶B样条曲线上的一点至多与k个控制顶点有关，与其它控制顶点无关</p><p>变差缩减性：若曲线为平面图形，则直线和曲线的交点不多于直线和特征多边形的交点</p><p>几何不变性：曲线几何特性不随坐标变化而变化</p><p>凸包性：曲线被包含在特征多边形构成的凸包内</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES202个人笔记（1）-基础引入</title>
      <link href="/posts/12444.html"/>
      <url>/posts/12444.html</url>
      
        <content type="html"><![CDATA[<h3 id="What-is-GAMES202-About"><a href="#What-is-GAMES202-About" class="headerlink" title="What is GAMES202 About"></a>What is GAMES202 About</h3><p>一共两个关键词，一个<u>高质量</u>，一个<u>实时</u></p><p>首先是<strong>实时</strong>，一般来计算机图形学中所说的实时所要求的标准是30fps，VR/AR要求更高，需要达到90fps</p><p>与实时渲染相对的是离线渲染，更多的应用于影视行业，渲染一帧的时间非常之久，渲染结果也相应的更加真实</p><p>而介于离线渲染和实时渲染之间的渲染，则被称为交互式渲染（interactive rendering），低于30fps，但也不会太低（卡成ppt）</p><p>其次是<strong>高质量</strong>，渲染的究极目标是以假乱真，为了获得更高质量的结果，就要面临极其昂贵的计算，这种trade off在101中经常性的被提及。但是，人类的本质是贪婪的，怎么做到“我全都要”，即在保证在实时的情况下，让结果尽可能的物理（近似）正确，是非常大的一个挑战</p><p>至于<strong>渲染</strong>，则可以理解为在一个3d场景中，通过计算生成图片（来模拟光线等信息）的过程</p><p>总之，课程内容可归纳为以下四个部分：</p><div class="table-container"><table><thead><tr><th style="text-align:center">阴影</th><th style="text-align:center">全局光照</th><th style="text-align:center">PBS</th><th style="text-align:center">实时光追</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/12444/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p1/1.png" alt="1"></td><td style="text-align:center"><img src="/posts/12444/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p1/2.png" alt="2"></td><td style="text-align:center"><img src="/posts/12444/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p1/3.png" alt="3"></td><td style="text-align:center"><img src="/posts/12444/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p1/4.png" alt="4"></td></tr></tbody></table></div><p>内容较101更分散，包括但不限于环境映射（Environment Mapping），非真实感渲染（NPR），球面谐波函数（SH），抗锯齿与超采样等等等等，难度并不会比101的路径追踪大，但需要101的知识做铺垫</p><p>另外，202不会包含如下内容：</p><ul><li>建模，引擎（不教工具使用方法，只会教这些工具背后的工程或科学原理，太偏应用不会提及）</li><li>离线渲染（卫星？难度极大）</li><li>神经渲染（Neural Rendering，做不到“实时”和“高质量”，但会提一些成功的应用，如DLSS）</li><li>怎么用OpenGL之类的着色语言，以及有关着色器的优化，或高性能计算（CUDA）</li></ul><h3 id="How-to-study-GAMES202"><a href="#How-to-study-GAMES202" class="headerlink" title="How to study GAMES202"></a>How to study GAMES202</h3><p>首先要清楚一件事：科学$\neq$技术，<strong>科学=知识</strong>，<strong>技术=让科学理论落地</strong>，二者并不等价，但同等重要</p><p>简单来说就是  <strong>科技=科学+技术</strong>，比如虚幻这些商业引擎，它们背后的科学原理非常简单，但真正实现过程中所采用的技术，使得他不论在效率还是易用性上都更胜一筹。从另一点来说，工业界在实时渲染上的发展也远远领先于学术界，一方面是需求推动，另一方面也可以说业界已经逐渐形成了从提出问题到解决问题的闭环，加上知识产权之类的问题，最后导致了这一奇怪现象，这也某种程度上算是证明了科学与技术的不等价关系</p><p>其次，欢迎倍速（×1.25）（但我还是习惯原速）</p><p>一些要求：</p><ul><li>对渲染或图形学感兴趣（很重要）</li><li>图形学基础和一些高数知识储备</li><li>基本的GLSL基础，课程用WebGL，跨平台没有任何问题</li><li>不需要买显卡，不需要买书（rtr4可以作为参考），参考资料在BBS上都有</li><li>没必要用IDE，作业独立完成</li></ul><h3 id="发展里程碑"><a href="#发展里程碑" class="headerlink" title="发展里程碑"></a>发展里程碑</h3><p>实时渲染的历史可能比离线渲染还要悠久</p><div class="table-container"><table><thead><tr><th style="text-align:center">更早</th><th style="text-align:center">可交互级3D图形管线</th><th style="text-align:center">SGI machines（1982）</th></tr></thead><tbody><tr><td style="text-align:center"><strong>20年前</strong></td><td style="text-align:center"><strong>可交互级3D实时渲染进入游戏行业</strong></td><td style="text-align:center"><strong>最终幻想VII（1997），反恐精英（1999）</strong></td></tr><tr><td style="text-align:center"><strong>10年前</strong></td><td style="text-align:center"><strong>可编程渲染管线发布</strong></td><td style="text-align:center"><strong>刺客信条2（2009）（暗），生化危机5（2009）（油）</strong></td></tr><tr><td style="text-align:center"><strong>现状</strong></td><td style="text-align:center"><strong>更完美的画面，虚拟现实，实时渲染电影</strong></td><td style="text-align:center"><strong>战神（2018）</strong></td></tr></tbody></table></div><p>预计算（15年前）：以牺牲存储空间为代价，提前将复杂的效果算出来，从而减少实时渲染的消耗</p><p>可交互级光线追踪（8-10年前，CUDA+OptiX）：先在gpu上用较低的采样率算出一个噪声很多的结果，然后快速做一次降噪，在多gpu加持下可以做出不错的效果</p><h3 id="Recap-of-CG-Basics"><a href="#Recap-of-CG-Basics" class="headerlink" title="Recap of CG Basics"></a>Recap of CG Basics</h3><h4 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h4><p><img src="/posts/12444/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p8-shading/%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF.png" alt="图形管线"></p><p>光栅化，深度缓存，着色模型，插值……详细可参考101 p7，或《入门精要》p9</p><div class="table-container"><table><thead><tr><th><strong>Q：光栅化前的三角形设置是怎么知道连接哪些顶点的？</strong></th></tr></thead><tbody><tr><td><strong>A：这是在obj这类格式的文件中被定义的，由点到面，在每个面上都带有三个顶点的坐标信息</strong></td></tr><tr><td><strong>Q：有没有适合全局光照的渲染管线？</strong></td></tr><tr><td><strong>A：目前暂时还没有，但光线追踪的渲染管线是已经非常完善了的</strong></td></tr><tr><td><strong>Q：纹理坐标是怎么参数化的？</strong></td></tr><tr><td><strong>A：看102，可以理解为物体外面有个盒子，参数化的过程就是把盒子挤压到物体上（降维），而盒子上的uv信息是很方便获取的</strong></td></tr></tbody></table></div><h4 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h4><p>是一系列通过CPU调动GPU的API之一，是一种图像应用编程的接口，所以具体用什么语言并不重要，重要的是怎么去写（背后的逻辑）</p><p>OpenGL（GLSL）具有良好的跨平台性，但迭代过于碎片化，且是C风格的代码，不具备任何面向对象的概念</p><p>DirectX（HLSL/Cg）相较之下对硬件的兼容性就比较高，但作为完全由微软控制的着色器编译，在平台上的限制就比较大，基本仅限于微软自己的产品</p><p>Vulkan可以理解为OpenGL的后续版本，支持多线程，可以跨除苹果以外的所有平台，是目前最新的一套图形接口</p><p>具体可以参考《入门精要》2.4.1</p><p>我们可以用画油画的步骤来类比OpenGL的架构</p><p><strong>1、摆放绘制物体</strong></p><p>获取模型信息，确定模型渲染位置。这个过程是有顶点缓冲对象（VBO）来完成的，它与obj格式文件非常类似，只不过他是在gpu中开辟出来的一块空间，用来储存点的位置和连接方式等信息，通过OpenGL定义的一些函数，可以对其进行空间变换和一些其他的运动</p><p><strong>2、摆放画架</strong></p><p>确定相机位置，进行视口变换（透视or正交）</p><p><strong>3、摆放画布</strong></p><p>FrameBuffer帧缓冲，对场景渲染一次可以渲染出很多纹理（MRT），至于对应关系，则会在之后的片元着色器中指定</p><p>在MRT中有一个特殊的渲染目标是直接渲染到屏幕，因为这么做会造成帧与帧之间的渲染结果覆盖，导致画面撕裂，所以一般不推荐这么做。当然，可以通过设置“垂直同步”来解决这一问题，或者把渲染的结果储存在缓冲区里，确认无误再在屏幕上渲染（双重缓冲/多重缓冲）</p><p><strong>4、在画布上进行绘制</strong></p><p>即着色，202只会用到顶点着色器和片元着色器</p><p>先由顶点着色器做MVP映射，再在片元着色器上进行插值、深度测试等操作，而将顶点打散为三角形的光栅化过程，则是由OpenGL来完成的</p><p><strong>5、画完了可以换一张画布接着画</strong></p><p>1-4是一次渲染，一次渲染就是一个pass（一个pass可以输出多张图到一个frambuffer）</p><p>换个画布就是换个pass，而在每个pass里都包含如下过程</p><ul><li>指定渲染对象，指定相机</li><li>指定输出对象（渲染到哪个纹理）</li><li>定义顶点/片元着色器，进行绘制</li></ul><p><strong>6、画新的画可以参考之前画的画</strong></p><p>在之前的pass渲染好的纹理可以作为参考，为别的pass提供信息（多pass渲染，《入门精要》中第一次出现是在第八章的透明效果）</p><div class="table-container"><table><thead><tr><th><strong>Q：shadowmap？光源也需要深度测试吗？</strong></th></tr></thead><tbody><tr><td><strong>A：shadow map可以去101 p12最后部分复习一下，场景中有几个光源就要几张shadow map，光源也需要纳入深度测试</strong></td></tr><tr><td><strong>Q：opengl支持optix吗？</strong></td></tr><tr><td><strong>A：可以是可以，但别指望shader能调用一个光线和一个场景怎么运作</strong></td></tr><tr><td><strong>Q：纹理是不是个buffer？</strong></td></tr><tr><td><strong>A：opengl里两者定义不一样，但也可以这样理解，都是显存里的一块缓存区域</strong></td></tr><tr><td><strong>Q：一个pass就是一个frame buffer渲染一次？</strong></td></tr><tr><td><strong>A：可以理解为一个场景渲染一次</strong></td></tr></tbody></table></div><h4 id="GLSL基础"><a href="#GLSL基础" class="headerlink" title="GLSL基础"></a>GLSL基础</h4><p>之前说过，GLSL是OpenGL的着色语言，用来描述着色器的各种不同操作，整体是C风格的语言，没有类的概念，但可以用结构体写</p><p>在着色语言出现以前，人们是在GPU上用汇编语言编写这些操作的，因此着色语言大大降低的图形编程的门槛</p><p>最早的着色语言是斯坦福的SGI，随后有了C for Graphics，再到现在主流的HLSL</p><p><em>题外：Unity是可以用GLSL或其他的着色语言的，用相应的片段包裹就行了（只不过入门精要用的是CG罢了）</em></p><h5 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h5><p>其实和在cpu上编程差不多：</p><p>编写shader -&gt; GPU编译shader -&gt; 建立program，集合所有自定义的shader -&gt; 链接并检查有没有问题 -&gt; 渲染</p><p>初始化：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shader初始化代码（不做要求）</span></span><br><span class="line">GLuint initshaders (GLenum type, <span class="keyword">const</span> char *filename) &#123;</span><br><span class="line"><span class="comment">// Using GLSL shaders, OpenGL book, page 679 </span></span><br><span class="line">GLuint shader = glCreateShader(type);</span><br><span class="line">GLint compiled;</span><br><span class="line">string str = textFileRead (filename);</span><br><span class="line">GLchar *cstr = new GLchar[str.size()+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> GLchar *cstr2 = cstr; <span class="comment">// Weirdness to get a const char</span></span><br><span class="line">strcpy(cstr,str.c_str());</span><br><span class="line">glShaderSource (shader, <span class="number">1</span>, &amp;cstr2, NULL);</span><br><span class="line">glCompileShader (shader);</span><br><span class="line">glGetShaderiv (shader, GL_COMPILE_STATUS, &amp;compiled);</span><br><span class="line"><span class="keyword">if</span> (!compiled) &#123; </span><br><span class="line">shadererrors (shader);</span><br><span class="line">        throw <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLuint initprogram (GLuint vertexshader, GLuint fragmentshader)&#123;</span><br><span class="line">GLuint program = glCreateProgram();</span><br><span class="line">    GLint linked;</span><br><span class="line">glAttachShader(program, vertexshader);</span><br><span class="line">glAttachShader(program, fragmentshader);</span><br><span class="line">glLinkProgram(program);</span><br><span class="line">glGetProgramiv(program, GL_LINK_STATUS, &amp;linked) ; </span><br><span class="line"> <span class="keyword">if</span> (linked)</span><br><span class="line">        glUseProgram(program);</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"> programerrors(program);</span><br><span class="line"> throw <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//attribute定义只在顶点着色器中出现的关键字</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aVertexPosition;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aNormalPosition;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> aTextureCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">//uniform定义全局变量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> uModelViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> uProjectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">//varying定义需要被传递到片元着色器的关键字</span></span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec2</span> vTextureCoord;</span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec3</span> vFragPos;</span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec3</span> vNormal;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>)&#123;</span><br><span class="line">vFragPos = aVertexPosition;</span><br><span class="line">    vNormal = aNormalPosition;</span><br><span class="line"><span class="built_in">gl_Position</span> = uProjectionMatrix * uModelViewMatrix * <span class="type">vec4</span>(aVertexPosition，<span class="number">1.0</span>);</span><br><span class="line">    vTextureCoord = aTextureCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更多的全局变量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> uSampler;<span class="comment">//sampler2D是纹理的数据类型</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uKd;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uKs;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uLightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uCameraPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uLightIntensity;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> uTextureSample;</span><br><span class="line"></span><br><span class="line"><span class="comment">//highp定义计算精度</span></span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec2</span> vTextureCoord;</span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec3</span> vFragPos;</span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec3</span> vNormal;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="type">vec3</span> color;</span><br><span class="line"><span class="keyword">if</span> (uTextureSample == <span class="number">1</span>)&#123;</span><br><span class="line">color = <span class="built_in">pow</span>(<span class="built_in">texture2D</span>(uSampler, vTextureCoord).rgb, <span class="type">vec3</span>(<span class="number">2.2</span>));<span class="comment">//2.2是伽马校正</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">color = uKd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//环境光</span></span><br><span class="line">    <span class="type">vec3</span> ambient = <span class="number">0.05</span> *color;</span><br><span class="line">    <span class="comment">//漫反射</span></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(uLightPos - vFragPos);</span><br><span class="line">    <span class="type">vec3</span> normal = <span class="built_in">normalize</span>(vNormal);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>( lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">float</span> light_atten_coff = uLightIntensity / <span class="built_in">length</span>(uLightPos - vFragPos);</span><br><span class="line">    <span class="type">vec3</span> diffuse = diff * light_atten_coff * color;</span><br><span class="line">    <span class="comment">//镜面反射</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(uCameraPos - vFragPos);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal) ;</span><br><span class="line">    spec = <span class="built_in">pow</span> (<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir)， <span class="number">0.0</span>)，<span class="number">35.0</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = uKs* light_atten_coff * spec;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>( <span class="built_in">pow</span>((ambient + diffuse + specular)，<span class="type">vec3</span>(<span class="number">1.0</span>/<span class="number">2.2</span>))，<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h5><p>难以调试的原因：编译好的shader是在gpu上运作的，调试会涉及到cpu和gpu的通信，必须使用外部工具才能实现</p><p>多年以前的调试工具，只有NVIDA的Nsight with Visual Studio，并且只能调试GLSL，HLSL还得在软件上运行才能debug</p><p>而现在，调试工具就丰富了，有Nsight Graphics（跨平台，但不跨硬件，只支持NVIDA），还有RenderDoc（对显卡品牌没要求）</p><p>更粗暴的可以用RGB调试法，具体参考《入门精要》5.5</p><div class="table-container"><table><thead><tr><th>Q：不同shader里定义的变量互通吗？</th></tr></thead><tbody><tr><td><strong>A：不互通</strong></td></tr></tbody></table></div><h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><script type="math/tex; mode=display">L(p,\omega_{output})=L_{emission}+\int_{H^2}L(p,\omega_{input})·f_r(p,\omega_{input}\rightarrow\omega_{output})·cos\theta_i \ d\omega_{input}</script><p>渲染方程是一个用来描述光线传播的等式，在101中扮演着非常重要的角色，是路径追踪的基础</p><p>这个等式表述的是，任意一点p反射到摄像机的radiance都等于该点发出的radiance + 其他打到该点的radiance × brdf × cos</p><p>实时渲染的渲染方程有一些区别：</p><script type="math/tex; mode=display">L_o(p,\omega_o)=\int_{\Omega+}L_i(p,\omega_i)·f_r(p,\omega_i,\omega_o)·cos\theta_i·V(p,\omega_i)\ d\omega_i</script><p>其中，BRDF可能指$f_r(p,\omega_i,\omega_o)$，也有可能指$f_r(p,\omega_i,\omega_o)·cos\theta_i$</p><p>$V(p,\omega_i)$是visibility项，考虑物体会不会被光源照到，通常定义为一张Cube Map或一张Sphere Map</p><p>注意，渲染方程的计算是像素级别的，非常消耗资源，有关这一点后续还会进一步提到</p><p>另外还有关于光线追踪渲染方程的递归定义，还是一样，回101复习吧</p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="/posts/12444/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B2.png" alt="渲染方程2"></th><th style="text-align:center"><img src="/posts/12444/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E7%94%A8%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E7%90%86%E8%A7%A3%E5%85%89%E6%A0%85%E5%8C%96.png" alt="用渲染方程理解光栅化"></th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES202 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES202个人笔记（2）-实时阴影</title>
      <link href="/posts/5734.html"/>
      <url>/posts/5734.html</url>
      
        <content type="html"><![CDATA[<h3 id="Shadow-Mapping-阴影映射"><a href="#Shadow-Mapping-阴影映射" class="headerlink" title="Shadow Mapping 阴影映射"></a>Shadow Mapping 阴影映射</h3><p>提到阴影，就不得不从Shadow Mapping开始说起，它是最早被应用于离线渲染的硬阴影的手法，也是现在的一种家喻户晓的渲染技术</p><h4 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h4><p>首先上图，先复习一下</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/shadow%20map%20gif.gif" alt="shadow map gif"></p><p>简单来说，它是一个2-pass算法，要用到两个pass（可以理解为渲染两遍），第一个pass先从光源出发，将==光源空间的深度值==写入阴影映射纹理（也就是所谓的shadow map），这张纹理表示场景哪里会被光源照亮；第二个pass从摄像机出发，将==屏幕空间的深度信息==写入z-buffer，再将当前像素的屏幕空间深度转换到光源空间中，并与shadow map上查询到的深度值相比较，若shadow map上的深度值小于屏幕空间的深度，就说明当前渲染位置产生了阴影（《入门精要》p197）</p><p>关于比较shadow map深度与屏幕空间的深度，有两种方法，一种是用深度缓存比较z分量，另一种是直接比较线性距离（光源坐标、相机坐标和图元坐标代入距离公式…），绝大多数情况下是用的第一种，也就是z分量比较（因为缓存速度快？）</p><p>而至于shadow map产生的问题，主要分为两种，一种是==自遮挡==（shadow acne，阴影失真），另一种是==走样==</p><p>自遮挡现象产生的原因有二，其一是处理器的数值精度的限制，还有一个原因是因为shadow map本身保存的值是离散值，也就是说shadow map上每个采样点都代表着一块范围内图元的深度值，因此在第二个pass比较深度的时候，shadow map中的深度可能会略低于物体表面的深度，部分片元就会被误计算为阴影，导致自遮挡。该现象在光源与平面趋于平行时（掠射）尤为严重</p><div class="table-container"><table><thead><tr><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/%E9%98%B4%E5%BD%B1%E5%A4%B1%E7%9C%9F%20(1" alt="阴影失真 (1)">.png)</th><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/%E9%98%B4%E5%BD%B1%E5%A4%B1%E7%9C%9F%20(2" alt="阴影失真 (2)">.png)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>为了解决这个问题，我们可以在shadow map中引入一个偏移值（bias），使得每次在比较深度大小的时候，都将一定区间内的shadow map深度认作与屏幕空间深度相等，强行减弱阴影判定。但这样做又会引入一个新的问题——detached shadow，或者说，peter panning（阴影悬浮）——即丢失部分原本可能发生遮挡的阴影</p><div class="table-container"><table><thead><tr><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/%E9%98%B4%E5%BD%B1%E6%82%AC%E6%B5%AE%20(1" alt="阴影悬浮 (1)">.png)</th><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/%E9%98%B4%E5%BD%B1%E6%82%AC%E6%B5%AE%20(2" alt="阴影悬浮 (2)">.png)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>解决阴影悬浮有两种方法，一种是将偏移值与入射角相关联，可以在OpenGL中通过glPolygonOffset来设置，入射角越大，偏移量越大，还有一种是second-depth shadow mapping，即在生成shadow map时使用最小深度和次小深度（正面剔除）的中间值，但使用这种方法也就意味着计算阴影的时间会随之翻倍，并且它还存在着封闭物体的局限性（只适用于盒体，球体这类非面片物体），因此在工业界这种方法并没有得到大范围的使用</p><p>另外有一点值得强调的是，不要小看翻倍的代价，在实时渲染中，开发者通常只会关注算法的绝对速度（以ms计），而不会去关注算法的时间复杂度，正所谓RTR does not believe in COMPLEXITY，就是这个道理</p><p>除了自遮挡，剩下还有一个问题就是走样。产生走样的原因是由于shadow map纹理的分辨率不足导致的，在对shadow map采样时，多个不同的顶点都采样到同一个纹素，从而产生锯齿。这个问题的解决方法与101中的MipMap类似，采用级联阴影（CSM），通过牺牲一些显存来对阴影进行分级，从而提高阴影质量，具体就不再赘述了</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/shadow%20map%E8%B5%B0%E6%A0%B7.png" alt="shadow map走样"></p><h4 id="阴影映射背后的数学原理"><a href="#阴影映射背后的数学原理" class="headerlink" title="阴影映射背后的数学原理"></a>阴影映射背后的数学原理</h4><p>之前提到过，实时渲染是在保证实时的情况下让结果尽可能的<strong>近似</strong>正确，而不苛求结果的绝对正确，因此在这个领域通常会把一些不等式直接当做约等式来用，比如微积分中的施瓦茨不等式和闵可夫斯基不等式….</p><p>接下来介绍一个实时渲染中非常重要的约等式</p><script type="math/tex; mode=display">\int_\Omega f(x)g(x)dx\approx\frac{\int_\Omega f(x)dx}{\int_\Omega dx}·\int_\Omega g(x)dx</script><p>这个式子的分式部分是一个归一化操作，其实也就是求了一下积分域内$f(x)$的均值</p><p>它提供了一种很好的方法，使得能够将乘积的积分拆为两个积分的乘积，并且当$g(x)$的积分域很小时，或当$g(x)$在其积分域内足够光滑（低频）的时候，这个约等式的结果是（更加）准确的</p><p>将这个约等式应用于渲染方程</p><script type="math/tex; mode=display">L_o(p,\omega_o)=\int_{\Omega+}L_i(p,\omega_i)·f_r(p,\omega_i,\omega_o)·cos\theta_i·V(p,\omega_i)\ d\omega_i\\\approx\frac{\int_{\Omega+}V(p,\omega_i)d\omega_i}{\int_{\Omega+}d\omega_i}\int_{\Omega+}L_i(p,\omega_i)·f_r(p,\omega_i,\omega_o)·cos\theta_i\ d\omega_i</script><p>立刻就可以发现，它将原来的渲染方程变为了Visibility项和Shading项相乘的结果，也就是在说，一边判断可见与否一边算着色结果，和先算着色结果再乘以shadow map的结果是近似相等的，这也就是shadow mapping做硬阴影的背后的理论基础</p><p>再考虑这个式子的准确性，积分限足够小对应光源类型为点光源或方向光源，$g(x)$足够低频对应brdf趋近diffuse（光滑材质），当满足这两个条件，这个约等式的准确性是非常高的（注意这里只考虑直接光照，不考虑间接光，当然间接光也可以强行使用，就是没这么准确罢了…）</p><div class="table-container"><table><thead><tr><th>Q：离线渲染有这种近似吗？</th></tr></thead><tbody><tr><td><strong>A：没见过</strong></td></tr><tr><td><strong>Q：有误差公式吗？</strong></td></tr><tr><td><strong>A：很少，且没有必要从理论上分析这类近似的误差上下界</strong></td></tr></tbody></table></div><h3 id="渐进百分比滤波（PCF）"><a href="#渐进百分比滤波（PCF）" class="headerlink" title="渐进百分比滤波（PCF）"></a>渐进百分比滤波（PCF）</h3><p>一般的Shadow Map只能实现硬阴影，想要实现更加自然的软阴影，需要其他的方法</p><p>在介绍PCSS之前，需要先介绍一下PCF（Percentage Closer Filtering）</p><p>PCF原本是一种抗锯齿方法，是在Shadow Map采样过程中，一次性取多个光源空间深度（shadow map纹素）与shading point的屏幕空间深度值进行比较，得到二值化数据，再对二值化数据（加权）平均得到非二值数据，从而达到软化阴影锯齿的目的</p><p>请注意，这个过程发生在采样过程中，滤波对象既<strong>不是</strong>Shadow Map所使用的深度图（1. 对深度图滤波，没有任何实际意义；2. 对深度图滤完波再做深度上的比较，结果仍是二值化数据，相当于什么都没做），也<strong>不是</strong>光源空间最后得到的阴影结果（非但不会消除锯齿，还会让阴影变糊，在101中有提到过，如下图所示），<strong>而是</strong>比较的光源空间和屏幕空间的深度所得到的二值图，对二值图做 filter（平均or加权）得到visibility，充当阴影软硬的依据</p><div class="table-container"><table><thead><tr><th style="text-align:center">先（采样）渲染再滤波（×）</th><th style="text-align:center">先滤波再（采样）渲染（√）</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/%E6%BB%A4%E6%B3%A2%E6%AC%A1%E5%BA%8F%20(2" alt="滤波次序 (2)">.png)</td><td style="text-align:center"><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/%E6%BB%A4%E6%B3%A2%E6%AC%A1%E5%BA%8F%20(1" alt="滤波次序 (1)">.png)</td></tr></tbody></table></div><p>由下图可以看到，PCF的结果还算不错，很好的消除了锯齿，但首先开销的成倍增加是其中一个问题，其次，这种方法也不能很好的表现现实中投影前实后虚的效果（虽然下右图有景深的因素，但这不影响观察阴影）</p><div class="table-container"><table><thead><tr><th style="text-align:center">PCF结果</th><th style="text-align:center">真实情况</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/PCF%E7%BB%93%E6%9E%9C.png" alt="PCF结果"></td><td style="text-align:center"><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/%E5%89%8D%E5%AE%9E%E5%90%8E%E8%99%9A.png" alt="前实后虚"></td></tr></tbody></table></div><h3 id="渐进百分比软阴影（PCSS）"><a href="#渐进百分比软阴影（PCSS）" class="headerlink" title="渐进百分比软阴影（PCSS）"></a>渐进百分比软阴影（PCSS）</h3><p>为了达到前实后虚的软阴影效果，就可以采用PCSS（Percentage Closer Soft Shadow），通过计算投影平面与遮挡物之间的距离，来确定滤波范围的大小==（自适应的filter size）==</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/PCSS.png" alt="PCSS"></p><p>如上图所示，这个filter size由半影区大小决定，半影区的大小可以由下述公式得到（其实就是一个相似三角形的问题）：</p><script type="math/tex; mode=display">w_{Penumbra}=w_{Light}·\frac{d_{receiver}-d_{blocker}}{d_{blocker}}</script><p><em>（软阴影产生的前提是光源本身具有一定面积，对于这种光源，产生Shadow Map的过程是取光源中间某一点，直接当做点光源来处理）</em></p><p>PCSS的具体步骤如下：</p><ul><li>首先依据着色点选择一块范围，对Shadow Map做一次局部深度测试，找到范围内的blocker并计算其平均深度（计算平均深度的目的是减小遮挡物自身的几何影响，避免漏光）</li><li>得到$d<em>{blocker}$后代入公式计算滤波范围，$d</em>{blocker}$越小，$d<em>{receiver}-d</em>{blocker}$越大，卷积核越大，得到的阴影就越软</li><li>重新进行深度测试，继续完成PCF的过程</li></ul><p>这里有个问题，filter size可以按上述方法确定了，那么计算filter size时需要用到的$d_{blocker}$同样需要在一定范围内做平均，这个范围又怎么确定呢？我们可以人为规定一个固定的大小，如4*4，16*16等，但这么做绝对不是最优解，更好的方法是在光源处设置一个视锥，将shadow map置于近平面上，接着连接着色点和光源，以其在shadow map上所截得的范围作为样本，来计算平均深度</p><p>这么做有一个非常大的好处，就是计算$d_{blocker}$也采用了自适应的方法，离光源越远，遮挡物越多，计算blocker所用的样本范围就越小；而离光源越近，遮挡物越少，计算blocker所用的样本空间就越大，非常合理</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p3/blocker.png" alt="blocker"></p><div class="table-container"><table><thead><tr><th>Q：多光源怎么处理？</th></tr></thead><tbody><tr><td><strong>A：如果是Shadow Mapping的话，只能一个个算</strong></td></tr><tr><td><strong>Q：点光源和方向光源怎么做PCSS？</strong></td></tr><tr><td><strong>A：前提错了，点光源和方向光源只能产生硬阴影，用不着PCSS</strong></td></tr><tr><td><strong>Q：运动物体怎么办？</strong></td></tr><tr><td><strong>A：这和运动物体没关系，因为每一帧的Shadow Map都会重新算</strong></td></tr></tbody></table></div><p>从数学公式上再深入理解一下，如图，设p为当前像素对应在shadow map上的采样点，q为p邻域上另一纹素</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/Deeper.png" alt="Deeper"></p><p>那么PCF计算阴影图的过程就可以表示为下述公式：</p><script type="math/tex; mode=display">V(x)=\sum_{q\in N(p)}w(p,q)·\chi^+[D_{shadow\ map}(q)-D_{scene}(x)]</script><p>其中权重$w(p,q)$可以由p和q之间的距离来定义，而乘号后的符号函数 $\chi^+[D_{}(q)-D(x)]$ 就是深度测试的过程</p><script type="math/tex; mode=display">V(x)\neq \chi^+\{[w*D_{shadow\ map}](q)-D_{scene}(x)\}\\V(x)\neq \sum_{y\in N(x)}w(x,y)·V(y)</script><p>通过这个公式我们也能更清楚的理解，为什么PCF的滤波对象不是shadow map和阴影图，而是一定filter size内的0-1样本了</p><p>那么再看回PCSS的三个步骤，很容易发现在步骤一和步骤三中都存在着遍历采样shadow map进行深度比较的操作，这对实时渲染来说是非常慢的。当然了，我们可以选择不遍历，而是通过随机采样的方式得到一个近似的结果，但这样也就意味着会引入一些噪声</p><p>工业界通常的处理方式就是这样，先对shadow map稀疏采样，再在图像空间内对含噪声结果进行一步降噪，就可以获得比较好的结果。至于怎么降噪，到之后的实时光线追踪部分再说</p><p>除了这种稀疏采样的方法，VSSM提供了另外一套针对性的解决方案</p><div class="table-container"><table><thead><tr><th>Q：这样连续的稀疏采样会不会造成闪烁（flicker）？</th></tr></thead><tbody><tr><td><strong>A：确实会，帧与帧之间随机采样相互独立，引入的噪声就不一样，连在一起就会flicker</strong></td></tr></tbody></table></div><h3 id="方差阴影贴图（VSSM-VSM）"><a href="#方差阴影贴图（VSSM-VSM）" class="headerlink" title="方差阴影贴图（VSSM / VSM）"></a>方差阴影贴图（VSSM / VSM）</h3><p>类比一个场景，在某次考试后，你想知道自己在班中的排名百分比，如果说PCF的过程是在用你的分数与其余同学的分数一一比较，从而获取精确的排位，那么VSSM就更像是在基于历史经验，省去遍历比较的过程而直接估计出排位。为了实现这样的估计，VSSM提出了许多大胆的假设</p><p>首先是PCSS的第三步，也就是PCF操作，VSSM假设在这一步对shadow map采样时得到深度值样本大致服从正态分布（其实并不是这样，后面提到的切比雪夫近似根本不需要知道样本服不服从正态分布，这里的假设只是为了方便理解），想要定义出这样一个正态分布，就需要事先求得样本的均值和方差</p><h4 id="均值-amp-方差"><a href="#均值-amp-方差" class="headerlink" title="均值&amp;方差"></a>均值&amp;方差</h4><p>对于快速求样本的均值，MipMap或许是一个不错的方法，在101中提到过，它是一个==快速的、近似的、正方形查询==方法，只不过在101中，这个算法是为了解决纹理过大的问题，回顾一下，那时候说如果一个屏幕像素对应多个纹理像素，为了避免失真，我们会预先通过双线性插值生成多级纹理，让纹素与像素大致对应，</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/MipMap2.png" alt="MipMap2"></p><p>然后在查询时依据查询范围确定层级序号（$D=log_2L$），在层与层之间再做一次插值作为结果写入像素</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/MipMap1.png" alt="MipMap1"></p><p>这样一个标准的三线性插值，用在shadow map上也是一样的，先在gpu上双线性插值得到多级阴影贴图，依据filter size确定层级序号，随后三线性插值完成查询</p><p>这个方法虽然简单，但一方面它要做三次插值，准确度不太高，另一方面，它只能做正方形查询，局限性太大（各向异性过滤可以解决），所以有人就提出了另一种方法——采用前缀和数组表（SAT）这一数据结构进行加速</p><p>SAT其实相当于一种预处理操作，在一维的情况下，SAT数组中的每一项SAT[i]都保存input数组前 i 项之和，假如想要知道图中原数组第3项到第6项元素之和，就只需要拿SAT数组中的第6项减去第3项就行了</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/SAT1.png" alt="SAT1"></p><p>对于二维的情况，生成SAT可以先并行的建立每一行的SAT，再在此基础上对列并行累加，不难算出，建立这样一张表需要的时间复杂度为$O(m*n)$，虽然建立的过程是并行的，但现代gpu往往具有更高的并行度，这样一个算法仍会显得比较“慢”</p><p>至于二维的查询就很简单了，想要获得任一矩形内元素的总和，只需要查4次表，用图中两个绿色矩形对应的SAT元素之和减去两个橙色矩形之和就行，这是最简单的容斥原理，也是leetcode 1314 matrix block sum这道经典算法题的基本思路</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/SAT2.png" alt="SAT2"></p><p>得到矩形区域内的元素和，再求样本均值就不在话下了。现在我们有了这一快速求均值的方法，再来看怎么求样本的方差</p><p>在概率论中有这样一个公式，体现了方差和期望之间的关系</p><script type="math/tex; mode=display">Var(X)=E(X^2)-E^2(X)</script><p>既然现在我们可以快速求$E(X)$，那么求$E(X^2)$就只需要在生成shadow map的时候额外计算一次光源空间深度的平方值就行了，将原来的shadow map储存在纹理的R通道，将square-depth map储存在G通道，完美解决</p><p>到此为止，样本均值和方差都变为了已知，那么定义假设中的概率密度函数也就非常方便了</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/%E6%AD%A3%E6%80%81.png" alt="正态"></p><script type="math/tex; mode=display">CDF(x)=\int_{-\infin}^{x}PDF(t)\ dt</script><p>如图，左侧PDF中的阴影部分面积表示shadow map上比shading point深度小的纹素占比，也就是会产生遮挡的概率，那么问题就转化为如何求这个PDF的概率分布（CDF，定义为PDF的积分）</p><p>可惜的是，大部分正态分布并不具备解析解，只能通过查表得到其数值解，就算c++中有内置的误差函数ERF可以专门用来求CDF数值解，这么做也是非常麻烦的。VSSM对于这个问题的解决方式，正是其精髓所在</p><h4 id="切比雪夫近似"><a href="#切比雪夫近似" class="headerlink" title="切比雪夫近似"></a>切比雪夫近似</h4><p>我们知道，实时渲染中常常会把一些不等式当做约等式来使用，VSSM就利用了这一点，通过切比雪夫不等式，用求得的期望和方差近似的估计CDF的值。这同时也是VSSM的第二个大胆假设</p><script type="math/tex; mode=display">P(x>t)\leq \frac{\sigma^2}{\sigma^2+(t-\mu)^2}\\\Rightarrow P(x>t)\approx \frac{\sigma^2}{\sigma^2+(t-\mu)^2}</script><p>这个约等式可以快速的求出下图中红色部分的概率，也就是$1-CDF(t)$，并且不仅仅是正态分布，它还适用于其他任何的单峰函数，这也是为什么VSSM不需要假设样本服从正态分布的原因</p><p>不过，切比雪夫近似也有它自己的局限性，那就是t必须位于均值右侧，即$t&gt;E(x)$时约等关系才成立（对正态分布这个其实很好解决，把t转化为$2\mu -t$就行了）</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%BF%91%E4%BC%BC.png" alt></p><p>至此，VSSM对PCSS第三步的加速就已经全部完成了，然而它对PCSS的第一步的优化我们却还只字未提，那么在这个步骤中，VSSM又是怎么做的呢？</p><h4 id="Blocker-Search加速"><a href="#Blocker-Search加速" class="headerlink" title="Blocker Search加速"></a>Blocker Search加速</h4><p>如前文所述，我们在第一步的主要目标是计算遮挡物的平均深度，按PCSS的做法是要先对shadow map采样，判断哪些是遮挡物</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/5x5.png" alt="5x5"></p><p>VSSM却直接忽略了这一步，以上图5*5的范围为例，它将深度小于着色点的蓝色遮挡区域的平均深度记作$Z<em>{ooc}$，而深度大于着色点的红色非遮挡区域的平均深度记作$Z</em>{unooc}$，则易得</p><script type="math/tex; mode=display">\frac{N1}N ·Z_{ooc}+\frac{N2}N ·Z_{unooc}=Z_{Avg}</script><p>其中$\frac{N1}N$和$\frac{N2}N$分别表示遮挡物和非遮挡物的占比，刚好可以用第三步完全一样的方法快速求得</p><script type="math/tex; mode=display">\frac{N1}N=P(x>t)\\\frac{N2}N=1-P(x>t)</script><p>剩下还有$Z<em>{ooc}$和$Z</em>{unooc}$未知，在这里VSSM再一次做出大胆的假设，直接认为$Z<em>{unooc}=Z</em>{shading\ point}$，$Z_{ooc}$随之迎刃而解</p><script type="math/tex; mode=display">Z_{ooc}=\frac{Z_{Avg}-\frac{N2}N ·Z_{unooc}}{\frac{N1}N}</script><p>如此假设不无它的道理，因为大多数情况下阴影的接受物都接近一个平面，但这也就意味着只要接受平面是曲面，或者遇到光线掠射的情况，VSSM就会出现一些问题</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/VSSM%E7%BB%93%E6%9E%9C.png" alt="VSSM结果"></p><p>可以看到，VSSM计算的阴影结果非常不错</p><p>总结一下，VSSM的实现过程如下：</p><ul><li>生成shadow map，同时生成square-depth map</li><li>依据着色点选择一块范围，基于shadow map和square-depth map，使用SAT数据结构计算局部深度和以及局部深度平方和，代公式求得期望和方差</li><li>使用切比雪夫近似，得到遮挡物和非遮挡物的占比，代入关系式求得遮挡物平均深度$d_{blocker}$</li><li>得到$d_{blocker}$后代公式算出fiter size</li><li>基于shadow map和square-depth map，使用SAT数据结构计算当前fiter size范围内的局部深度和以及局部深度平方和，代公式求得期望和方差</li><li>使用切比雪夫近似，得到shading point的遮挡概率，写入Visibility</li></ul><p>虽然但是，现在工业界仍更倾向于选择PCSS，因为随着各种降噪方法的提出，人们对噪声的容忍度变得越来越高，此时稀疏采样的PCSS与VSSM之间的差距就显得微不足道了，这种情况下，使用VSSM可能会有得到错误结果的风险，开发者自然就更倾向于使用PCSS了</p><div class="table-container"><table><thead><tr><th>Q：如果场景中有物体移动，不就要实时更新mipmap么？</th></tr></thead><tbody><tr><td><strong>A：没错，不仅是物体移动，只要生成了新的shadow map，就需要更新mipmap，所以还是存在一定开销的，但也不必过于担心，因为gpu对mipmap支持非常到位，可以认为基本不消耗时间</strong></td></tr><tr><td><strong>Q：投射平面是曲面会发生什么？</strong></td></tr><tr><td><strong>A：不仅是曲面，只要光源和投影平面不平行就会出错</strong></td></tr><tr><td><strong>Q：VSSM是PCSS的快速版本么？</strong></td></tr><tr><td><strong>A：可以这么理解，但不能等价替换，可以将PCSS作为一个基准</strong></td></tr></tbody></table></div><h4 id="VSSM的缺陷"><a href="#VSSM的缺陷" class="headerlink" title="VSSM的缺陷"></a>VSSM的缺陷</h4><p>VSSM的缺陷主要表现在如下几点：</p><ul><li><p>漏光（Light Leakiing）：VSSM将遮挡物分布强行假设为单峰分布，但有时候会与实际情况相差很远，如下左图，如果实际的非遮挡区域占比比假设小，那么就会得到一个局部较亮的结果，导致漏光</p><p>| <img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/%E6%BC%8F%E5%85%89%20(1" alt="漏光 (1)">.png) | <img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/%E6%BC%8F%E5%85%89%20(2" alt="漏光 (2)">.png) |<br>| —————————————————————————————— | —————————————————————————————— |</p></li><li><p>不连续阴影：在算$d_{blocker}$的时候，VSSM假设非遮挡平面深度都等于shading point深度，这会导致在阴影接受面不平整的时候出现阴影中断现象</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/%E4%B8%8D%E8%BF%9E%E7%BB%AD%E9%98%B4%E5%BD%B1.png" alt="不连续阴影"></p></li><li><p>使用切比雪夫近似本身具有一定局限</p></li></ul><h4 id="MSM"><a href="#MSM" class="headerlink" title="MSM"></a>MSM</h4><p>就像VSSM的提出是为了改进PCSS，MSM（Moment Shadow Mapping）的存在是为了解决VSSM假设带来的一些缺陷</p><p>其核心思想是，使用更高阶的矩来描述遮挡概率的CDF，使其更接近真实分布，从而避免漏光</p><p>关于矩的概念，它是数学中对变量的一种特征度量值，最简单的就是一个数的几次方，统计学中的期望是一阶矩，方差是二阶矩，所以从这个角度理解，VSSM就相当于记录了前两阶的矩</p><div class="table-container"><table><thead><tr><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/MSM%20(1" alt="MSM (1)">.png)</th><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/MSM%20(2" alt="MSM (2)">.png)</th><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p4/MSM%20(3" alt="MSM (3)">.png)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>使用更高阶的矩就能得到更好的拟合，但是如何用更高阶的矩描述CDF是一件非常复杂的事情，同样需要相当的额外空间开销和性能开销</p><h3 id="距离场阴影（DFSS）"><a href="#距离场阴影（DFSS）" class="headerlink" title="距离场阴影（DFSS）"></a>距离场阴影（DFSS）</h3><h4 id="有向距离场（SDF）"><a href="#有向距离场（SDF）" class="headerlink" title="有向距离场（SDF）"></a>有向距离场（SDF）</h4><p>又称有符号距离场，是一种<strong>标量场</strong>，场中每一点都记录了<u>该点</u>到<u>定义该场的物体</u>之间的最小距离，并且用正负号表示该点在物体内还是在物体外，若距离为0，则认为该点在物体表面上</p><p>课程一共提到了三种SDF的应用：字体渲染，几何形变和光线步进（Ray Marching）</p><p>字体渲染方面，因为距离场记录的是标量信息，不会受到分辨率限制，并且在细微层面可以通过插值进行拟合，所以有时候能做出很好的抗锯齿效果，甚至能实现无限分辨率的字符（已在商用引擎中得到应用，但对中文支持欠佳）</p><div class="table-container"><table><thead><tr><th style="text-align:center">距离场可视化</th><th style="text-align:center">距离场等值线</th><th style="text-align:center">SDF字体渲染</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%AD%97%E4%BD%93%E6%B8%B2%E6%9F%93%20(3" alt="字体渲染 (3)">.png)</td><td style="text-align:center"><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%AD%97%E4%BD%93%E6%B8%B2%E6%9F%93%20(2" alt="字体渲染 (2)">.png)</td><td style="text-align:center"><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%AD%97%E4%BD%93%E6%B8%B2%E6%9F%93%20(1" alt="字体渲染 (1)">.png)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">三维距离场可视化</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E4%B8%89%E7%BB%B4%E8%B7%9D%E7%A6%BB%E5%9C%BA%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="三维距离场可视化"></td></tr></tbody></table></div><p>而在几何方面，我们在101中讲距离函数的时候就提到过了，不同的物体有不同的距离场，在距离场与距离场间做插值运算，就能很好的进行混合过渡</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%87%A0%E4%BD%95%E5%BD%A2%E5%8F%98%20(1" alt="几何形变 (1)">.png)</p><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%87%A0%E4%BD%95%E5%BD%A2%E5%8F%98%20(2" alt="几何形变 (2)">.png)</p><h4 id="Ray-Marching-amp-DFSS"><a href="#Ray-Marching-amp-DFSS" class="headerlink" title="Ray Marching &amp; DFSS"></a>Ray Marching &amp; DFSS</h4><p>我们的重心主要放在Ray Marching上。采用了SDF的光线步进算法提供了一种截然不同的与场景物体求交的方法，具体来说，当我们向场景中投射一根光线的时候，Ray Marching会依据场景中每个物体的SDF，在投射点位置选取一个最小距离作为安全距离当做步长，也就是说在以投射点为球心、安全距离为半径的球形范围内，不论光线方向为何，它都不会与场景内物体相交，而当光线按原来方向走过这一段步长后，它又可以在新的位置依据SDF计算出新的安全距离，以此类推，直到步进次数达到一定值或者步长小到一定范围，即可认为光线与物体相交，退出循环</p><div class="table-container"><table><thead><tr><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%85%89%E7%BA%BF%E6%AD%A5%E8%BF%9B%20(3" alt="光线步进 (3)">.png)</th><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%85%89%E7%BA%BF%E6%AD%A5%E8%BF%9B%20(2" alt="光线步进 (2)">.png)</th><th><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%85%89%E7%BA%BF%E6%AD%A5%E8%BF%9B%20(1" alt="光线步进 (1)">.png)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><img src="/posts/5734/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/Ray-Marching.gif" alt="Ray-Marching"></p><p>现在可以对这个方法稍微做一个延伸，既然我们可以通过距离场算出安全距离，那么算出一根光线在当前位置的“安全角度”应该也是非常简单的，只需要用安全距离与累加的步长和做一步反三角运算就可以得到了。此时，我们连接面光源的中心与着色点，在这个方向上做Ray Marching，得到一系列安全角度后取个最小值作为最终的安全角度，这个角度越小，就说明光线被遮挡的概率越高，阴影就可以设置的越黑，反过来，当这个角度大于一定值时，就可以认为光线不被遮挡，不产生阴影</p><p>不过，上面说的用反三角算安全角还是有点废性能，于是iq大佬就提出了一种实时渲染的近似方法：</p><script type="math/tex; mode=display">arcsin\frac{SDF(p)}{p-o}\Longrightarrow min\{\frac{k·SDF(p)}{p-o},1.0\}</script><p>直接用一个k与sin值相乘，再截断在1以内直接作为Visibility的值（绝了wc），虽然说这么做近似非常胆大，但通过这种方式我们获得了一个非常好的控制参数——k</p><p>同等安全角度下，k越小，visibility越小，半影区越大，阴影越软；k越大，visibility越容易被1截断，阴影越硬</p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>DFSS是一种非常聪明 效果也非常好的阴影算法，但如果说DFSS比Shadow Map系列算法快的话其实是非常不公平的，因为DFSS本质上是一种预计算，而我们一般说的DFSS速度快，是忽略了它本身计算储存SDF的时间的，要知道，三维下的SDF在空间上的消耗可不是一般的大，尤其是对于场景内有物体发生形变的情况，还得重新计算SDF，从这点上来看，算上预处理的性能消耗，DFSS和SDF目前差距并不大，我们学习他只是为了参考它巧妙的处理方法而已</p><p>至于如何生成SDF，如何储存，还有DFSS的一系列artifact，这里就不再展开了</p><div class="table-container"><table><thead><tr><th>Q：查询空间中某个点的距离场时需要遍历场景中所有物体吗</th></tr></thead><tbody><tr><td><strong>A：不需要，预处理的时候每个物体单独算距离场，查询的时候只要取所有距离场在该位置的最小值即可</strong></td></tr><tr><td><strong>Q：使用SDF会有什么问题吗？</strong></td></tr><tr><td><strong>A：SDF生成的物体表面不太好贴纹理，如何参数化（UV）现在正在研究中</strong></td></tr><tr><td><strong>Q：SDF得到的阴影是真的阴影吗？</strong></td></tr><tr><td><strong>A：不是，只会更假</strong></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES202 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES202个人笔记（3）-实时环境光照</title>
      <link href="/posts/24703.html"/>
      <url>/posts/24703.html</url>
      
        <content type="html"><![CDATA[<h3 id="环境贴图"><a href="#环境贴图" class="headerlink" title="环境贴图"></a>环境贴图</h3><p>环境贴图是一种记录了场景中任意一点在不同方向上接受到的光照强度的贴图（天空盒 / 天空球），它默认这些环境光来自无穷远，因此它所记录的强度与位置无关（这也是为什么用环境贴图渲染的时候，走到哪里都会有一种漂浮感）</p><p>目前主流的环境贴图包括Spherical Map和Cube Map。类似这种处理环境光照的方法被统称为IBL（image-based lighting）</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE.png" alt="环境贴图"></p><h3 id="Split-Sum近似"><a href="#Split-Sum近似" class="headerlink" title="Split-Sum近似"></a>Split-Sum近似</h3><p>首先来看渲染方程</p><script type="math/tex; mode=display">L_o(p,\omega_o)=\int_{\Omega+}L_i(p,\omega_i)·f_r(p,\omega_i,\omega_o)·cos\theta_i\ d\omega_i</script><p>这里我们假设不考虑遮挡，所以直接舍去Visibility。按照之前路径追踪的做法，我们要解这个渲染方程需要借助蒙特卡洛积分去进行一个（无偏的）估计，但做过101作业7的应该都知道，蒙特卡洛需要非常大的采样率才能让结果接近真实，这对于实时的环境光照来讲是一件极其恐怖的事情，相当于对场景中每个图元都要做这么多次采样，无疑是非常慢的</p><p>（p.s.由于近几年TAA等一系列temporal方法的发展，使得一些采样方法已经能在实时领域得到应用，所以sampling对实时来说非常慢这个观点正在逐渐成为历史，但在那之前我们还是优先考虑其他不采样的方法）</p><p>这时候我们就又要用到之前那个在实时渲染中非常重要的积分近似公式了</p><script type="math/tex; mode=display">\int_\Omega f(x)g(x)dx\approx\frac{\int_\Omega f(x)dx}{\int_\Omega dx}·\int_\Omega g(x)dx</script><p>之前提这个公式的时候说，当$g(x)$的积分域很小，或当$g(x)$在其积分域内足够光滑（低频）的时候，这个约等式的近似结果会更加准确，而渲染方程中的brdf项又无非分为glossy和diffuse两种，glossy对应积分域小，diffuse对应低频，那我们理所应当的就可以把light项给拆出来了</p><div class="table-container"><table><thead><tr><th style="text-align:center">glossy，积分域小</th><th style="text-align:center">diffuse，光滑低频</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/glossy.png" alt="glossy"></td><td style="text-align:center"><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/diffuse.png" alt="diffuse"></td></tr></tbody></table></div><script type="math/tex; mode=display">L_o(p,\omega_o)\approx\frac{\int_{\Omega_{f_r}}L_i(p,\omega_i)d\omega_i}{\int_{\Omega_{f_r}}d\omega_i}\int_{\Omega+}f_r(p,\omega_i,\omega_o)·cos\theta_i\ d\omega_i</script><p>不难发现，原本的渲染方程现在变为了对积分域上的Light项取平均，换个说法，就是对环境贴图做了个模糊处理，材质越glossy，积分域越大，图像就越模糊：</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E6%A8%A1%E7%B3%8A.png" alt="模糊"></p><p>因为模糊对象是环境贴图，所以这个模糊操作是可以在渲染之前就完成的，即所谓的pre-filtering。我们可以在渲染前对环境贴图进行多级模糊，和MipMap一样，到真正的渲染环节，依据场景物体的材质确定模糊等级（通过插值保证级与级之间的连续），做一次查询就可以得到我们想要的结果</p><p>更形象一点，就如下图所示</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E6%9B%B4%E5%BD%A2%E8%B1%A1%E4%B8%80%E7%82%B9.png" alt="更形象一点"></p><p>多次采样后用pdf求平均得到的值 $\approx$ 对采样对象滤完波查询一次得到的值，没毛病</p><p>（p.s. 老师上课讲的lobe是反射波瓣，就是图中pdf的采样区域，brdf的形状）</p><div class="table-container"><table><thead><tr><th>Q：spherical map每个像素表示的立体角不一样，那是不是不应该用统一的fiter size</th></tr></thead><tbody><tr><td><strong>A：没错，滤波的核的大小的单位是立体角，是在对一个球面做滤波</strong></td></tr><tr><td><strong>Q：漫反射是不是对整个环境贴图求平均</strong></td></tr><tr><td><strong>A：这么想也不是不行…实时渲染中的漫反射是一种很特殊的情况，它的的lobe是个半球面，所以直接沿着法线方向去查就可以了，至于diffuse的lobe慢慢变小会变为glossy的情况，真正在实现的时候会把diffuse单独处理，所以也不是什么问题</strong></td></tr></tbody></table></div><p>这样一来，我们就解决了环境光项的问题，此时的渲染方程还剩下一个brdf部分尚未解决，对于这个部分，我们仍可以用预计算替代实时采样，但考虑到微表面的BRDF可能会涉及菲涅尔项和法线分布等至少五维（粗糙度, r, g, b, 角度，总共五维）的数据处理，直接暴力预计算肯定是不可取的，只好通过一些近似来降低维度，以此来简化预计算</p><p>让我们先来复习一下101中微表面理论提到的几个近似：</p><div class="table-container"><table><thead><tr><th><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E7%90%86%E8%AE%BA.png" alt="微表面理论"></th><th><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/fresnel&amp;NDF.png" alt="fresnel&amp;NDF"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>菲涅尔用的Schlick近似，认为菲涅尔项与基础反射率$R_0$和入射角有关；法线分布的Beckmann近似，认为该项与表面粗糙度与$\theta_h$（半角与法线的夹角）有关；而在实时渲染中，因为<u>入射角</u>、<u>反射角</u>以及<u>入射角和反射角的半角</u> 度数差别不大，可以近似的看成一个角，$\theta_h$又能通过这三个角转化得到，所以角度部分可以认为是一个维度，现在，BRDF项的储存就由五维变成了三维</p><p>三维还是不太好存，能不能再压呢？来看下面这个化简：</p><script type="math/tex; mode=display">F=R_0+(1-R_0)(1-cos\theta)^5=R_0(1-(1-cos\theta)^5)+(1-cos\theta)^5\\\int_{\Omega+}f_r(p,\omega_i,\omega_o)·cos\theta_i\ d\omega_i=\int_{\Omega+}\frac{f_r(p,\omega_i,\omega_o)}{F}·F·cos\theta_i\ d\omega_i\\\Downarrow\\\int_{\Omega+}f_r(p,\omega_i,\omega_o)·cos\theta_i\ d\omega_i\approx R_0\int_{\Omega+}\frac{f_r}{F}(1-(1-cos\theta)^5)·cos\theta_i\ d\omega_i+\int_{\Omega+}\frac{f_r}{F}(1-cos\theta)^5·cos\theta_i\ d\omega_i</script><p>看起来很复杂，其实还是比较简单的。通过这个操作我们把基础反射$R_0$从积分里拆了出来，消除了原方程对它的依赖，那么现在剩下需要预计算的就只剩下roughness和角度两个变量了，直接将预计算结果储存为一张二维的纹理，之后要用的时候直接查表就完事了</p><p>（p.s.实时领域一般会把积分号写成求和号，但里面的内容是一样的）</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p5/split%20sum%E7%BB%93%E6%9E%9C.png" alt="split sum结果"></p><p>可以看到，即使做了这么多近似，结果还是非常令人满意。这也是Unreal引擎做PBR的基础</p><div class="table-container"><table><thead><tr><th>Q：Fresnel项需要预计算么？</th></tr></thead><tbody><tr><td><strong>A：Fresnel项被拆开了，可以说只有一部分需要预计算</strong></td></tr><tr><td><strong>Q：这个预计算结果是固定的吗？</strong></td></tr><tr><td><strong>A：是固定的，只要是同种类brdf都可以用</strong></td></tr><tr><td><strong>Q：用Microfacet GGX，参数会多么？</strong></td></tr><tr><td><strong>A：不会</strong></td></tr><tr><td><strong>Q：深度学习在实时渲染领域有没有什么其他的应用？除了DLSS</strong></td></tr><tr><td><strong>A：现在甚至连降噪都不会用深度学习，它在实时渲染中并不怎么成功，实在太慢了</strong></td></tr><tr><td><strong>Q：IBL适用于什么场景？</strong></td></tr><tr><td><strong>A：适用于任何你想用它的场景，但当光源和你的物体有确定的距离的时候，就不能再这么使用了（因为IBL假设光源无限远）</strong></td></tr><tr><td><strong>Q：积分里的F怎么计算？</strong></td></tr><tr><td><strong>A：不用算，BRDF的式子里包含F，分子分母消掉了</strong></td></tr></tbody></table></div><h3 id="环境光阴影的实现难点"><a href="#环境光阴影的实现难点" class="headerlink" title="环境光阴影的实现难点"></a>环境光阴影的实现难点</h3><p>前面我们介绍了如何在忽略阴影的情况下计算环境关照，那么如果现在不忽略阴影，我们又该如何计算呢</p><p>很可惜，以目前的技术来说，实现环境光下的阴影是基本不可能的一件事，尤其是对于实时来讲，它会变得更为困难。这主要体现在两个问题上，其一是<strong>多光源问题（many-light problem）</strong>，如果将环境光理解为四面八方无数的小光源，那么生成阴影也就意味着需要在每个小光源的位置处生成一张对应的shadow map，这么做的代价是不可估量的；另一个问题是<strong>如何采样</strong>，就算通过某种手段我们得到了多光源的shadow map，我们也很难获取着色点周围所有方向上的遮挡情况，那么为了计算Visibility项我们只好盲目的进行采样，在生成一大堆样本后慢慢处理。同时，我们也无法从渲染方程中将Visibility提取出来，因为对于环境光， <u>①足够小的积分域 ②高频的BRDF</u> 这两个提取条件它一个都无法满足，所以，常规的做法到这里都会变得寸步难行</p><p>在这方面，工业界也没有什么好的解决方法，一般做法都是选取一个主要光源（如太阳）生成阴影（摆就完了）</p><p>相关研究指路：</p><ul><li>Imperfect Shadow Maps，做的是全局光照阴影</li><li>Light Cut，离线渲染中里程碑式的工作，将场景中反射物当做小光源，试图通过归类得到近似结果</li><li>Real Time Ray Tracing（RTRT），或许是未来的终极解决方案</li><li>Precomputed Radiance Transfer（PRT），可以得到非常准确的得到环境光阴影，但需要付出一定代价（后面会讲）</li></ul><div class="table-container"><table><thead><tr><th>Q：UE5的全局光照是不是用的上面说的这些算法？</th></tr></thead><tbody><tr><td><strong>A：不知道，但游戏引擎对全局光照这块一般都不会只用一种算法，通常是几种方案的混合体</strong></td></tr></tbody></table></div><h3 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h3><p>1、傅里叶级数展开：任何一个周期函数，都可以表示为一系列sin和cos函数的线性组合加一个常数项的形式，对应到信号处理就是不同频率的波的叠加，或者是对数据的一种有损压缩，通过这么处理可以将图像从时域（空间域）变换到频域</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p6/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80.png" alt="傅里叶级数展开"></p><p>2、基函数（Basis Functions）：一个函数可以表示为一系列其他函数的组合，这些“其他函数”，就是所谓基函数</p><script type="math/tex; mode=display">f(x)=\sum_i c_i·B_i(x)</script><p>​      傅里叶级数展开就是将原函数表示为一系列基函数的过程</p><p>3、滤波（Filtering），这个应该不陌生了，前面都已经用过好几次了（指路：101 p6）</p><p>​      图像的高频信息越多，其内容变化越丰富，细节展示就越多</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p6/%E6%BB%A4%E6%B3%A2.png" alt="滤波"></p><p>4、卷积：对图像每个像素都在一定范围（卷积核）内做加权平均的操作，算是一种滤波的操作</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p6/%E5%8D%B7%E7%A7%AF.png" alt="卷积"></p><p>在时域内的卷积操作就相当于在频域内的相乘（原图频谱×卷积核频谱），而相乘结果经过逆傅里叶变换就能得到基于原图的模糊效果</p><p>用数学来表示，就是对两个函数的乘积求积分（product integral）：</p><script type="math/tex; mode=display">\int_{\Omega}f(x)g(y)dx</script><p>相当于在频域上让两个信号相乘，==最后输出的频率取决于积分前的两个函数的最低频率==</p><h3 id="球谐函数SH"><a href="#球谐函数SH" class="headerlink" title="球谐函数SH"></a>球谐函数SH</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>比较易懂的科普可以看这篇 <a href="https://zhuanlan.zhihu.com/p/351289217，以下内容在顺序上存在部分调整">https://zhuanlan.zhihu.com/p/351289217，以下内容在顺序上存在部分调整</a></p><p>球谐函数（Spherical Harmonics）其实就是定义在球面坐标系中的一系列<strong>二维基函数</strong>，每个基函数都可以用 <em>勒让德多项式</em> 写出来，我们不需要了解勒让德多项式是什么（那毫无意义），只要能看明白下面这张可视化就行：</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p6/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="球谐函数可视化"></p><p>图中蓝色表示的是正值，黄色表示的是负值，颜色深浅表示的是<strong>函数值的大小</strong>，越深越小，而形状则表示<strong>频率的大小</strong></p><p>图的最左边标明了球谐函数的<strong>阶数</strong>，第 $l$ 阶球谐对应有 $2l+1$ 个基函数，前 $n$ 阶一共有 $n^2$ 个基函数，而图的最下边 $m$ 则对应了球谐函数的<strong>序号</strong>，第 $l$ 阶对应的序号范围为 $[-l,l]$</p><p>有了这一系列概念，再来看球谐函数的展开公式，$f(x)=\sum_i c_i·B_i(x)$，其中$B_i(x)$是球谐函数，可以认为已知，$f(x)$是原函数，$c_i$是球谐系数，那么原函数就可以储存为一个 $i$ 维向量$(c_1,c_2,···,c_i)$</p><p>计算球谐系数的过程称为<strong>投影</strong>，其计算方法如下（product integral）：</p><script type="math/tex; mode=display">c_i=\int_\Omega f(w)B_i(w)\ dw</script><p>已知球谐系数，还原原函数的过程称为<strong>重建</strong>（实际上可以理解为做了一系列的点乘），使用的基函数越多，展开的阶数越高，重建的细节的越多，还原的效果就越好，如图</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p6/%E9%87%8D%E5%BB%BA.png" alt="重建"></p><p>当我们使用Spherical Map作为环境贴图时，环境光信息被定义在一个球面坐标系内，这时候我们就可以用球面谐波函数对其展开近似，而当brdf为diffuse时，渲染方程的$f_r$项只有低频信息，相当于一个低通滤波器，那么无论环境光多么高频，最后乘积的结果仍是低频，所以此时只需用三阶的球谐函数就能做到很好的近似，这样一来通过预计算虽然牺牲一定储存空间（存16维向量），但它既免去了采样的过程，又为后面的PRT奠定了理论基础，显然还是很划算的</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>在正式介绍PRT之前，还需要补充球谐函数的一些优良性质</p><h5 id="正交完备性"><a href="#正交完备性" class="headerlink" title="正交完备性"></a>正交完备性</h5><p>球谐函数中任意两个基函数之间都满足相互正交，即其中任意一个球谐函数向另一个球谐函数的投影结果都是0，而如果向自己投影，则结果是1：</p><script type="math/tex; mode=display">\int_{\Omega}B_i(i)·B_j(i)\ di=1,\ (i=j)\\\int_{\Omega}B_i(i)·B_j(i)\ di=0,\ (i\neq j)</script><h5 id="旋转不变性"><a href="#旋转不变性" class="headerlink" title="旋转不变性"></a>旋转不变性</h5><p>对任意函数进行旋转，就相当对球谐展开的基函数进行旋转，旋转后的基函数虽然不能再被称为基函数，但它仍旧可以由同阶的基函数的线性组合表示出来，这就意味着不论怎么旋转原函数，我们都可以立刻得到其新的球谐系数</p><h3 id="PRT"><a href="#PRT" class="headerlink" title="PRT"></a>PRT</h3><p>现在有了SH，就可以将Visbility项考虑进来了</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p6/PRT1.png" alt="PRT1"></p><p>（brdf可以由入射角、出射角、入射方位角和出射方位角定义，所以可以写成图中的四维的形式，详情参考101 p17）</p><p>一般思路是将环境光项、Visibility项和brdf项全都描述为球面函数（这里为了方便理解使用cube map展示），然后逐像素相乘，最后相加。这种思路可谓一点都没体现球谐函数的优势，且不论三张贴图的存储，对每个shading point，光光逐像素计算就要花费很多计算，远远满足不了实时的要求</p><p>因此我们引入了PRT（Precompute Radiance Transfer，基于预计算的辐射传输），其核心思想是将渲染方程分为lighting（环境光项）和lighting transport（Visibility&amp;brdf）两部分，假设场景中只有lighting部分会发生变化（旋转or更换光源），而lighting tansport部分固定不变。因为lighting部分可以被球谐展开，所以旋转操作并不会造成多大影响（旋转不变性），即使更换光源，也只要在预计算中多计算几个光源就行，那么这两部分就都可以被球谐展开，从而在预处理中完成部分计算</p><p>下面来详细分析PRT的计算过程</p><h4 id="Diffuse-case"><a href="#Diffuse-case" class="headerlink" title="Diffuse case"></a>Diffuse case</h4><h5 id="计算方法Ⅰ"><a href="#计算方法Ⅰ" class="headerlink" title="计算方法Ⅰ"></a>计算方法Ⅰ</h5><p>第一种计算diffuse的方法，因为对于diffuse的情况，brdf几乎可以被认为是一个常数，所以直接将其提到积分号外面</p><script type="math/tex; mode=display">L(o)=\rho \int_{\Omega} L(i)V(i)max(0,n·i)\ di</script><p>再将$L(i)$写成球谐函数的形式，因为实时渲染中求和和积分次序可以任意交换，所以原式化简如下：</p><script type="math/tex; mode=display">L(o)\approx \rho \sum l_i \int_{\Omega} B_i(i)V(i)max(0,n·i)\ di</script><p>对于这个约等式的积分部分，一共有两种理解方式，一种是将其理解为一个投影操作，将light transport投影到某个基函数上，得到的是它在环境光照球面坐标系内的球谐系数，那么最后的渲染方程就变为了两个向量的点乘（$\sum l_iT_i$其实就是点乘）</p><script type="math/tex; mode=display">L(o)\approx \rho \sum l_iT_i\\T_i=\int_{\Omega} B_i(i)V(i)max(0,n·i)\ di</script><p>另一种理解方式是将$B_i(i)$理解为一盏光，那么这里的积分就相当于重算了一个渲染方程，算的是这些<u>球谐函数所描述的环境光</u>作用于物体的结果，最后以$l_i$为权重叠加求和，得到最终的重建结果（下图中红色代表正值，蓝色代表负值）</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p6/PRT2.png" alt="PRT2"></p><h5 id="计算方法Ⅱ"><a href="#计算方法Ⅱ" class="headerlink" title="计算方法Ⅱ"></a>计算方法Ⅱ</h5><p>与计算方法Ⅰ不同，计算方法Ⅱ彻底将lighting和light transport部分分开考虑，分别对他们球谐展开，设$c_p$为lighting的球谐系数，$c_q$为light transport的球谐系数：</p><script type="math/tex; mode=display">L_o(p,w_o) = \int_{\Omega+} L_i(p,w_i) f_r(p,w_i,w_o) cos\theta_i V(p,w_i) \ dw_i\\=\int_{\Omega+}L(i) · \rho V(i) max(0,n·i) dw_i\\</script><script type="math/tex; mode=display">\begin{cases}L_i=L(i)\approx \sum_p c_pB_p(i)\\T_i=\rho V(i)max(0,n·i)\approx\sum_q c_qB_q(i)\end{cases}</script><p>代入渲染方程，同计算方法Ⅰ，交换求和与积分次序，将两个球谐系数提出来</p><script type="math/tex; mode=display">L_o(p,w_o)=\int_{\Omega+} \sum_p c_pB_p(i)\sum_q c_qB_q(i)\ dw_i\\=\sum_p\sum_q c_p c_q \int_{\Omega+}B_p(i)B_q(i)\ dw_i</script><p>可以发现结果变为了一个双重求和的形式，并且乍一眼看上去时间复杂度还似乎从计算方法Ⅰ的$O(n)$变为了$O(n^2)$</p><p>实际上，因为球谐函数的正交性，只有当p=q的时候，也就是lighting和light transport用了同阶基函数时，$\int_{\Omega+}B_p(i)B_q(i)\ dw_i$才会等于1，其他时候都等于0，根本不用纳入计算范围，就好比一个二维矩阵只计算它对角线上的元素，其算法复杂度仍然是$O(n)$</p><h5 id="Diffuse总结"><a href="#Diffuse总结" class="headerlink" title="Diffuse总结"></a>Diffuse总结</h5><p>纵观PRT的整个计算过程，不管是哪种计算方法，它都只需要经过部分的预计算，就能把原先的逐顶点 / 逐像素操作转化为向量的点乘，这对于性能来说绝对是成百倍的提升，并且我们还可以从下图看到，它不仅适用于计算带阴影的环境光，还适合做多次bounce的间接光照预计算，结果同样非常不错（关于间接光预计算后面会有详细说明）</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p6/PRT3.png" alt="PRT3"></p><div class="table-container"><table><thead><tr><th>Q：预计算能不能做天气系统或者日出日落？</th></tr></thead><tbody><tr><td><strong>A：会预计算一部分</strong></td></tr><tr><td><strong>Q：实时光追普及后，PRT会不会淘汰？</strong></td></tr><tr><td><strong>A：个人认为不会，实时光追的普及反而会让PRT有更多的表现空间</strong></td></tr><tr><td><strong>Q：每个点的Visibility的球谐函数是怎么得到的？</strong></td></tr><tr><td><strong>A：最暴力的方法就是从shading point出发往四周trace光线，因为是预计算，所以时间可以认为是无限的</strong></td></tr></tbody></table></div><h4 id="Glossy-Case"><a href="#Glossy-Case" class="headerlink" title="Glossy Case"></a>Glossy Case</h4><p>对于glossy的材质，brdf项就不能简简单单的当做一个常数去处理了，因为当观察glossy材质的时候，每个不同的视角得到的shading结果都不一样，所以计算其光路还需要将视角关联进来（四维brdf：入射角、出射角、入射方位角、出射方位角）</p><p>那么如果这时候再像之前计算方法Ⅰ那样，将light transport投影到lighting的基函数上，投影的结果就不再会是一个球谐系数了，而是一个关于出射方向o的函数$T_i(o)$，换句话说，是一组球谐系数</p><script type="math/tex; mode=display">L(o)\approx \rho \sum l_iT_i\ \Longrightarrow\ L(o)\approx \sum l_iT_i(o)</script><p>对$T<em>i(o)$球谐展开，$T_i(o)\approx \sum t</em>{ij}B_j(o)$，代入原式</p><script type="math/tex; mode=display">L(o)\approx \sum l_i\sum t_{ij}B_j(o)\\=\sum(\sum l_it_{ij})B_j(o)</script><p>于是结果就从原来的向量点乘变为了一个向量和一个矩阵的乘法</p><p><u>矩阵理解方式1</u>：$T_i$的每个基函数都对应一组球谐系数，矩阵大小为基函数阶数n*视角采样次数m</p><p><u>矩阵理解方式2</u>：对任一出射方向 / 视角上的$T_i(o)$球谐展开，会得到一组基函数的球谐系数，最后把所有方向上对应的基函数vector组合在一起，就形成了一个矩阵。矩阵大小为视角采样次数m*基函数阶数n</p><p><u>矩阵理解方式3</u>：我们最后得到的结果是不同方向上的radiance，是一个向量，而lighting部分球谐展开得到的也是一个向量，只有向量乘以一个矩阵才能最后得到一个向量，所以light transport部分球谐展开得到的是一个矩阵（倒推法）</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/PRT1.png" alt="PRT1"></p><p>所以对于glossy材质，使用PRT的效率会比diffuse差很多，四阶的情况下，diffuse的每个shading point只要乘一个16维向量就够了，而glossy必须乘以一个16*16的矩阵，五阶就是25*25，这在储存上带来的压力增长可想而知</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/PRT2.png" alt="PRT2"></p><h4 id="Inter-Case"><a href="#Inter-Case" class="headerlink" title="Inter Case"></a>Inter Case</h4><p>之前提到，PRT还适合做一些多次bounce的间接光照预计算，那么它这么做的理论依据是什么呢？</p><p>其实非常简单，我们把light transport部分理解为光的传播路径，再用正则表达式把它描述出来</p><div class="table-container"><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">LE</td><td style="text-align:center">light→eye</td></tr><tr><td style="text-align:center">LGE</td><td style="text-align:center">light→glossy→eye</td></tr><tr><td style="text-align:center">LGGE</td><td style="text-align:center">light→glossy→glossy→eye</td></tr><tr><td style="text-align:center">L(D\</td><td style="text-align:center">G)* E</td><td>light→(diffuse or glossy)*n→eye</td></tr><tr><td style="text-align:center">LS* (D\</td><td style="text-align:center">G)* E</td><td>light→specular*n→(diffuse or glossy)*n→eye</td></tr></tbody></table></div><p>可以看到，所有光线的传播路径的起点和终点都是光源light和摄像机，不论中间有多少次bounce，最终的表达式都可以被描述为light和light transport两部分，所以我们只需要预计算出light transport，就可以得到最后的shading result（计算方法参考Diffuse计算方法Ⅰ的第二种理解方式，结合Ray Tracing之类的算法就可以完成）。而这样一来，因为所有复杂的计算都被集中在预计算中处理掉了，实际渲染所消耗的时间自然就与light tranport的复杂度无关了</p><p>下图为各种不同的BRDF的渲染结果，spatial varying BRDF指的是各点具有不同brdf的材质，如生锈的铁器等</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/PRT4.png" alt="PRT4"></p><h4 id="PRT的局限"><a href="#PRT的局限" class="headerlink" title="PRT的局限"></a>PRT的局限</h4><p>PRT虽然可以很好的实现带有阴影的实时环境光渲染，但它也有它自己的局限性，主要体现在两方面</p><p>首先是对场景的要求。之前我们假设light transport不变，相当于默认了这一部分对于场景是一种自带的属性，也就是说如果要使用PRT，渲染对象就必须具备==静态场景、动态光源==这一条件，如果场景中的物体发生移动，物体原先的阴影就会因为Visibility项固定不变而留在原地，而如果物体的材质发生变化，或者物体发生了形变，则会得到错误的结果</p><p>其次是对材质的要求。因为球谐函数在描述高频信息时需要非常高阶的基函数才能完成重建，所以一般PRT只适合做一些较为低频的情况（试想用26阶球谐重建glossy材质，最后得乘一个$26^2$阶的矩阵，676*676，这是何等恐怖的储存压力）</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/PRT3.png" alt="PRT3"></p><div class="table-container"><table><thead><tr><th>Q：怎么做spatial varying的brdf预计算</th></tr></thead><tbody><tr><td><strong>A：PRT关注的更多的是已知brdf的预计算，一般人们会用一些诸如柏林噪声之类的可控制噪声来得到spatial varing brdf</strong></td></tr><tr><td><strong>Q：glossy材质中的视角方向怎么决定？</strong></td></tr><tr><td><strong>A：不是视角方向怎么决定，而是要在预计算中把所有视角方向的球谐都算出来，至于矩阵不能无限大</strong></td></tr><tr><td><strong>Q：预计算是写在光栅化里面么？</strong></td></tr><tr><td><strong>A：预计算是一个独立的程序，会有存储和读取的过程</strong></td></tr><tr><td><strong>Q：预计算可以理解成伪材质吗？</strong></td></tr><tr><td><strong>A：可以，可以理解为伪材质的一部分</strong></td></tr></tbody></table></div><h4 id="小波函数（Wavelet）"><a href="#小波函数（Wavelet）" class="headerlink" title="小波函数（Wavelet）"></a>小波函数（Wavelet）</h4><p>为了解决SH在频率上的局限，科学家研究出了一些其他不同的基函数，如Zonal Harmonics，Spherical Gaussian（SG），Piecewise Constant等等等等，而小波函数也是其中之一</p><p>不同于球谐函数，小波函数是定义在图像块上的一系列基函数，不同的小波函数具有不同的定义域，如图</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/%E5%B0%8F%E6%B3%A2%E5%87%BD%E6%95%B0.png" alt="小波函数"></p><p>当用小波函数对原函数进行压缩的时候，我们也不再会采用SH那样的截断方法，而是选择将原函数投影到全部基函数上，通过舍去大量接近0的小波系数，保留部分基函数从而来完成近似</p><p>因为小波函数是定义在图像块上的基函数，所以为了防止重建后的图像出现接缝，我们一般会使用cube map记录环境光照。以二维Haar Wavelet为例，从下面的gif可以看出，小波函数对图像的压缩过程是先把压缩区域分为四个部分，将低频信息放在左上角，高频信息分波段填充剩余部分，随后对左上角的低频信息继续递归执行之前的步骤（四叉树）</p><p><img src="/posts/24703/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/%E5%B0%8F%E6%B3%A2%E5%87%BD%E6%95%B0gif.gif" alt="小波函数gif"></p><p>从图中我们很容易观察到，随着压缩程度的越来越大，cube map会变得越来越灰，这恰恰说明了经过小波变换后原图像会舍去大量次要信息（只保留0.1% - 1%的有效信息），从而高效地得到一个==全频段==的压缩结果</p><p>值得一提的是，虽然小波函数解决了球谐函数的频率限制，但它同时也放弃了球谐的一些好的性质，比如SH的旋转不变性，使用小波函数就无法做到像之前那样随意转动灯光，每次旋转都必须重新进行计算（这就涉及到dynamic scene的PRT研究了，单论基函数的话小波函数还是非常不错的）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES202 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES202个人笔记（4）-实时全局光照</title>
      <link href="/posts/25879.html"/>
      <url>/posts/25879.html</url>
      
        <content type="html"><![CDATA[<h3 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h3><p>1、全局光照=直接光照+间接光照，是指通过模拟光线的传播路径，将物体反射的间接光纳入计算，从而提高结果真实感的一种渲染技术（如图中金属球的焦散，蜡烛的次表面）</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7.png" alt="全局光照"></p><p>实时渲染中的全局光照，一般就是指如何<strong>简单而快速</strong>地计算比直接光照<strong>多一次bounce</strong>的光照结果</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/%E5%A4%9A%E4%B8%80%E6%AC%A1bounce.png" alt="多一次bounce"></p><p>2、辐射度量学相关概念：</p><div class="table-container"><table><thead><tr><th style="text-align:center">物理量</th><th style="text-align:center">符号</th><th style="text-align:center">中文翻译</th><th style="text-align:center">简单定义</th><th style="text-align:center">单位</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">Radiant Energy</td><td style="text-align:center">Q</td><td style="text-align:center">辐射能量</td><td style="text-align:center">电磁波形式的能量</td><td style="text-align:center">焦耳（J）</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">Radiant Flux</td><td style="text-align:center">P</td><td style="text-align:center">辐射功率/辐射通量</td><td style="text-align:center">单位时间内的辐射能量</td><td style="text-align:center">瓦特（w）</td><td style="text-align:center">$P=\frac{dQ}{dt}$</td></tr><tr><td style="text-align:center">Radiant Intensity</td><td style="text-align:center">I</td><td style="text-align:center">辐射强度</td><td style="text-align:center">点源向某单位立体角发射的辐射功率</td><td style="text-align:center">w/sr</td><td style="text-align:center">$I=\frac{dP}{d\omega}$</td></tr><tr><td style="text-align:center">Irradiance</td><td style="text-align:center">E</td><td style="text-align:center">辐（射）照度</td><td style="text-align:center">受照面单位面积上的辐射功率</td><td style="text-align:center">w$/m^2$</td><td style="text-align:center">$E=\frac{dP}{dA}$</td></tr><tr><td style="text-align:center">Radiance</td><td style="text-align:center">L</td><td style="text-align:center">辐（射）亮度</td><td style="text-align:center">单位投影面积、单位立体角上的辐射功率</td><td style="text-align:center">w$/m^2$sr</td><td style="text-align:center">$L=\frac{d^2P}{dAd\omega cos(\theta)}$</td></tr></tbody></table></div><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.png" alt="辐射度量学相关概念"></p><p><a href="https://ciechanow.ski/lights-and-shadows/">Lights and Shadows – Bartosz Ciechanowski</a> 安利一个网站，可以很好的帮助理解这块概念</p><p>3、BRDF的定义：</p><script type="math/tex; mode=display">f_r(\omega_i\rightarrow\omega_o)=\frac{dL(\omega_o)}{dE(\omega_i)}=\frac{吸收后向某立体角方向辐射出去的 Radiance}{辐射前某单位面积dA接收到的Irradiance}</script><p>4、对光源采样的渲染方程：</p><script type="math/tex; mode=display">L(p,\omega_o)=\int_{\Omega+} L(p,\omega_i)·f_r(p,\omega_i \rightarrow \omega_o)·cos\theta \ d\omega_i\\=\int_{\Omega+}L(p,\omega_i)·f_r(p,\omega_i\rightarrow\omega_o)·\frac{cos\theta ·cos\theta'}{\abs{x'-x}^2} \ dA</script><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B.png" alt="光源采样渲染方程"></p><p>（建议重新过一遍101 p16）</p><h3 id="图像空间方法"><a href="#图像空间方法" class="headerlink" title="图像空间方法"></a>图像空间方法</h3><h4 id="反射阴影贴图（RSM）"><a href="#反射阴影贴图（RSM）" class="headerlink" title="反射阴影贴图（RSM）"></a>反射阴影贴图（RSM）</h4><p>参考：<a href="https://zhuanlan.zhihu.com/p/357259069">【论文复现】Reflective Shadow Maps</a></p><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>既然实时全局光照只计算比直接光照多一次bounce的间接光照，那么问题就自然分为了两个部分：</p><p>1° 场景中哪些表面会被直接光照影响，反射出间接光</p><p>2° 如何计算这些表面对着色点p的贡献</p><p>对于这两个问题，RSM的思路是通过shadow map获取直接光照的影响区域，再根据shadow map的分辨率将这些区域微元化，把其中每一个像素（或者说surface patch）都当做一个次级光源进行计算，如图</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/VPL.png" alt="VPL"></p><p>这个概念其实和离线渲染中的虚拟点光源（Virtual Point Light，VPL）有些类似，唯一的区别在于，这里RSM会将所有次级光源的表面设为diffuse，以摆脱这些surface patch对视角方向的依赖（如果不这么设置，次级光源是glossy的话，计算量会变得非常恐怖），又因为我们无法对每个次级光源都生成一张阴影贴图，所以在实时渲染中间接光通常不会考虑Visibility的大小，那么现在连接pq，我们所要计算的虚拟光源贡献就是在q点处出射的radiance大小</p><script type="math/tex; mode=display">L_o(p,w_o)=\int_{\Omega_{patch}}L(p,w_i) V(p,w_i)·f_r(p,\omega_i,\omega_o)·cos\theta_i\ dw_i\\=\int_{A_{patch}} L(q \rightarrow p)f_r(p,q \rightarrow p,\omega_o)·\frac{cos\theta_p · cos\theta_q}{\abs{q-p}^2}\, \mathrm{d}A</script><p>上式中，因为光源面积是阴影贴图上的一系列像素，所以可以直接当做$dA$处理</p><p>由brdf定义$f_r(\omega_i\rightarrow\omega_o)=\frac{dL(\omega_o)}{dE(\omega_i)}$，得$L(q \rightarrow p)=f_r·\frac{\phi}{dA}$，代入渲染方程，原式化简如下</p><script type="math/tex; mode=display">L_o(p,w_o)=\phi ·f_r^2(p,q \rightarrow p,\omega_o)·\frac{cos\theta_p · cos\theta_q}{\abs{q-p}^2}</script><p>又由假设中的diffuse次级光源，可知$f_r$是一常数，合并参数，最后就可以得到下面这个式子（老师的写法）：</p><script type="math/tex; mode=display">L_o(p,w_o)=\phi_p·\frac{cos\theta_p · cos\theta_q}{\abs{q-p}^2}\\</script><p>至于老师说的paper里的那个分母中的4次方，则是因为分子未做归一化导致的，后来在p9开头有做澄清（硬盘装不下.jpg）</p><p>两个式子都没有错，这里把字母全都做了一个统一，方便比较：</p><script type="math/tex; mode=display">L_o(p,w_o)=\phi_p·\frac{max\{ 0, n_p·\frac{q-p}{\abs{q-p}} \} · max\{ 0, n_q·\frac{p-q}{\abs{p-q}}\} }{\abs{q-p}^2}\\=\phi_p·\frac{max\{ 0, n_p·(q-p) \} · max\{ 0, n_q·(p-q) \} }{\abs{q-p}^4}</script><p>到这里为止，算法的核心思想就已经介绍完毕了，但如果说要去真正实现它，那还是存在着一些问题的</p><h5 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h5><p>试想按照前面的思路去计算场景中一个点的间接光，如果每个着色点所使用的shadow map分辨率都是512*512，那就意味着要设置20多万个虚拟光源，这显然非常不合理；并且我们从下图也很容易看到 ，场景有一些点是不可能对目标着色点产生影响的（如$q’$点和$p$），计算它们纯粹是在浪费性能</p><div class="table-container"><table><thead><tr><th><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/RSM3.png" alt="RSM3"></th><th><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/RSM2.png" alt="RSM2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>于是为了解决这个问题，作者不再采用逐一计算虚拟光源的方法，而选择以着色点为中心，做一个有侧重的选取</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/RSM%E6%94%B9%E8%BF%9B.png" alt="RSM改进"></p><p>他认为在shadow map中 距离着色点越近（或深度越接近）的虚拟光源带来的贡献越大，那么就只要多选取一些离着色点相近的次级光源，再引入一个与SM距离相关的权重来弥补稀疏采样带来的误差（越远越稀疏，权重越大），就能对最终的结果做出一个很好的近似（一般一个shading point只要400次采样就足够了，直接在原先基础上降了3个数量级，优化幅度还是非常大的）</p><h5 id="RSM总结"><a href="#RSM总结" class="headerlink" title="RSM总结"></a>RSM总结</h5><p>综上所述，实现RSM一共需要储存四种信息：</p><p>① 光源空间的深度值（shadow map）；② 世界坐标，用来比较距离；③  法线；④ 光源光强flux</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/RSM%E5%82%A8%E5%AD%98.png" alt="RSM储存"></p><p>在实际应用中，RSM通常被用来做一些小型的单光源全局光照（如下面这张gif里的手电筒），一方面是因为它思路比较直接，实现起来比较方便，另一方面也是因为小型光源的shadow map的储存压力小，使用RSM可以以非常低的性能代价给画面带来质的提升</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p7/%E5%AF%B9%E6%AF%94gif.gif" alt="对比gif"></p><p>但是同样也是因为这个原因，使得RSM在光源数增加的时候更容易遇到性能瓶颈（因为需要储存更多的shadow map）</p><p>另外在其他方面，RSM也还存在着一些问题，比如次级光源的diffuse，忽略Visibility项，低采样率和质量的取舍等等，这些都会或多或少对结果造成一定影响，导致RSM在实际开发中的应用频率并不高</p><p>即使如此，作为一个经典的算法，RSM仍对后人带来了相当深远的启发，包括后面要讲的LPV，也是建立在其基础上才被提出的，因此其中的思想仍然值得我们去学习和借鉴</p><h3 id="三维空间方法"><a href="#三维空间方法" class="headerlink" title="三维空间方法"></a>三维空间方法</h3><h4 id="LPV"><a href="#LPV" class="headerlink" title="LPV"></a>LPV</h4><p>参考：<a href="https://zhuanlan.zhihu.com/p/412287249">Light Propagation Volumes</a>（其中包括Visibility的解决方法）</p><p>Light Propagation Volumes（光照传播体积），最早是由 CryEngine3 提出的一种基于RSM和球谐函数的实时全局光照技术，其核心思想是通过将场景划分为一系列三维网格（体素化）来模拟光线的传播，随后利用其Irradiance在传播过程中保持恒定这一特征，计算出每个shading point上的间接光照。这一创造性的方法不仅在速度和质量上有着非常好的表现，还同时解决了一部分RSM带来的问题，下面就来介绍它的具体做法</p><ul><li><p><strong>生成（Generation）</strong></p><p>第一步很简单，利用光源的shadow map完成次级光源的定义即可。在这一步可以通过采样对次级光源的数量做出一些简化，从而给算法带来一定优化</p></li><li><p><strong>注入（Injection）</strong></p><p>对整个场景进行体素化，并将虚拟光源转化为对应体素的属性。一块体素可能对应多个虚拟光源，叠加其内部所有虚拟光源即可得到当前体素的Radiance信息</p><p>在存储过程中，由于Cube Map的开销过于庞大，我们可以使用球谐函数对其进行压缩，工业界一般认为两阶SH就能做到很好的拟合</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/LPV%E7%90%83%E8%B0%90.png" alt="LPV球谐"></p></li><li><p><strong>传播（Propagation）</strong></p><p>对于每一个体素，依据其储存的Radiance分布，计算它周围六个体素的radiance，然后分别对它们使用SH进行简化。对角的体素可以被多步传播覆盖到，因此不做考虑</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/LPV%E4%BC%A0%E6%92%AD.png" alt="LPV传播"></p><p>计算完成后，再算这六块体素各自 除了原体素相邻面以外的 另外五个格子，如此迭代，直至传播的radiance趋于稳定</p></li><li><p><strong>渲染（Rendering）</strong></p><p>对场景中任意着色点，找到其所在的体素并叠加所在体素中所有方向的radiance后正常渲染即可</p></li></ul><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/LPV%E6%95%88%E6%9E%9C.gif" alt="LPV效果"></p><p>LPV提供的这种实现全局光照的方法<u>不需要任何的预计算</u>，因此可以支持各种变化的场景，做到真正的”实时“。不过，它有时候也会存在一些问题，如图，当渲染的几何对象小于体素大小，即体素划分精度不足时，会出现漏光的现象</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/%E6%BC%8F%E5%85%89%20(1" alt="漏光 (1)">.png)</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/%E6%BC%8F%E5%85%89%20(2" alt="漏光 (2)">.png)</p><p>这是因为在LPV注入的时候，我们假设所有的Radiance都是由体素中心发出的，因此对于下左图中原本位于薄墙左侧的点p，就会被强行移动到右侧，产生漏光。为了解决这个问题，我们可以选择提高体素精度，但这还是会面临一个性能与质量之间的取舍</p><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/LPV%E6%BC%8F%E5%85%89%E5%8E%9F%E5%9B%A0.png" alt="LPV漏光原因"></th><th style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/LPV%E7%BA%A7%E8%81%94.png" alt="LPV级联"></th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><p>另外，在场景较大、光源较多的情况下，LPV的计算压力也会随之上升，关于这一点，可以使用类似LOD的级联方法进行加速（上右图）</p><div class="table-container"><table><thead><tr><th>Q：体素划分一般多大比较合适？</th></tr></thead><tbody><tr><td><strong>A：至少比场景分辨率少一个数量级</strong></td></tr><tr><td><strong>Q：一块体素会记录其他多个体素的传播贡献吧？</strong></td></tr><tr><td><strong>A：当然，每个格子都会对它周围 6个/5个 格子产生贡献，最后累加</strong></td></tr><tr><td><strong>Q：传播过程中会不会一直不稳定传播，达不到稳态而无法停止？</strong></td></tr><tr><td><strong>A：肯定是会达到稳态的，就像向水面投一块石头产生的波纹，没有外界影响的话最后肯定是会收敛的</strong></td></tr><tr><td><strong>Q：LPV会假设次级光源是diffuse的吗？</strong></td></tr><tr><td><strong>A：会，只要是用SH压缩，渲染glossy表面都会造成强烈模糊，所以一般只要用了SH都会假设diffuse</strong></td></tr></tbody></table></div><h4 id="VXGI"><a href="#VXGI" class="headerlink" title="VXGI"></a>VXGI</h4><p>与RSM和LPV类似，Voxel Global Illumination（体素全局光照）也是一个基于体积渲染的2-pass实时全局光照算法，但它与二者的区别在于：① VXGI 会在对场景离散体素化之后，再对数据做一次==稀疏八叉树划分==，所以从一开始，它的“次级光源”就是一系列体素；② 在渲染过程中，VXGI 会采用==Cone-Tracing==的方式计算间接光的贡献，在速度方面会比LPV慢很多</p><div class="table-container"><table><thead><tr><th style="text-align:center">体素离散化</th><th style="text-align:center">八叉树划分</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/%E4%BD%93%E7%B4%A0%E7%A6%BB%E6%95%A3%E5%8C%96.png" alt="体素离散化"></td><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/%E5%85%AB%E5%8F%89%E6%A0%91%E5%88%92%E5%88%86.png" alt="八叉树划分"></td></tr></tbody></table></div><p>下面来具体介绍这个算法的执行步骤：</p><ul><li><p><strong>Light-Pass</strong></p><p>VXGI 的第一个pass主要关注场景中哪些表面会被直接光照照亮，以及间接光照的反射方向。和LPV的注入过程不同的是，虽然它们都是以体素为储存单位，但 VXGI 记录的是直接光源的==入射方向区间==和体素对应的受光表面的==法线方向区间==，结合材质，VXGI 能够轻松的算出间接光照的分布（即直接光出射方向，反射波瓣），而在算完最低层级的体素之后，将当前层级的八个叶子结点相加，就可以计算更高一级体素的间接光照分布了（diffuse的情况比较特殊，下面会提）</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/VXGI%20Light-Pass.png" alt="VXGI Light-Pass"></p><p>比起LPV用SH压缩记录虚拟光源信息，这种计算方法可以支持glossy，并且结果会更加准确</p><p>相关拓展：<a href="https://zhuanlan.zhihu.com/p/414691569">Voxel Global Illumination 体素全局光照</a></p></li><li><p><strong>Camera-Pass </strong></p><p>在第二个Pass，VXGI 就要开始考虑真正的渲染问题了。通过第一个Pass我们可以知道Cone-Tracing的间接光照投射方向与锥角大小，那么对于glossy的表面就可以像Ray-Marching那样，只要基于一定Ray-Cone Footprint（理解为锥截面大小），到八叉树中相应层级进行查询，就可以得到范围内所有shading point的==irradiance==大小了（其实和mipmap一模一样，只不过将纹理查询转化为了子树遍历问题）</p><p>| <img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/VXGI%20Camera-Pass%20(1" alt="VXGI Camera-Pass (1)">.png) | <img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/VXGI%20Camera-Pass%20(2" alt="VXGI Camera-Pass (2)">.png) |<br>| :—————————————————————————————: | :—————————————————————————————: |</p><p>而对于diffuse表面就比较特殊了，VXGI 通常会将出射方向看做若干圆锥，而忽略锥与锥之间的间隙（影响并不会很大），暴力求解，但这样一来diffuse就会比glossy多一层循环，效率比起其他方法自然也会更差</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/VXGI%20Diffuse.png" alt="VXGI Diffuse"></p></li></ul><p>总的来说，同样作为一种体积渲染方法，VXGI 的渲染结果质量非常好，有时候甚至可以做到与光线追踪相近的效果，但缺点是开销太大，且Light-Pass前的体素化会有一定预处理需求，所以它的实际应用也受到了很大的限制</p><p>下面是VXGI 的效果gif</p><div class="table-container"><table><thead><tr><th style="text-align:center">直接光照</th><th style="text-align:center">体素化</th><th style="text-align:center">最终结果</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/VXGI%20gif1.gif" alt="VXGI gif1"></td><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/VXGI%20gif2.gif" alt="VXGI gif2"></td><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/VXGI%20gif3.gif" alt="VXGI gif3"></td></tr></tbody></table></div><h3 id="屏幕空间方法"><a href="#屏幕空间方法" class="headerlink" title="屏幕空间方法"></a>屏幕空间方法</h3><p>屏幕空间实时渲染，是指利用在所有pass渲染完成之前各个帧缓冲中的信息，对已渲染结果加以修改的渲染方法。伴随着延迟渲染的兴起，更多的信息得以在屏幕空间取得，因此也延伸出许多不同的算法，这些算法一般都具有如下特点：</p><ul><li>能够很方便的支持各种滤波算法</li><li>解除了场景复杂度对算法的限制</li><li>会有不同程度的信息丢失（因为只能获得一些相机观察得到的信息，所以遮挡越多，越有可能发生信息丢失）</li></ul><p>本节将针对屏幕空间的全局光照，介绍SSAO，HBAO，SSDO、SSR共四种GI近似方法</p><h4 id="AO（环境光遮蔽）"><a href="#AO（环境光遮蔽）" class="headerlink" title="AO（环境光遮蔽）"></a>AO（环境光遮蔽）</h4><p>在开始这个话题之前，首先要明白AO是什么，它和法线、RGB这类信息一样，也是场景的一种属性，描述的是物体与物体之间环境光互相遮挡的程度。在场景中加入AO信息，可以让物体相交处的阴影更加脚踏实地，从而让整个画面更具立体感</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/AO1.gif" alt="AO1"></p><p>在计算全局光照过程中，由于我们无法在屏幕空间中直接获得间接光照，所以一般会假设间接光照强度为一个定值，随后通过AO来决定GI的亮度。比如在下图中，左边的shading point的AO比右图小，那么显然左边的间接光就会比右边亮</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/AO2.png" alt="AO2"></p><h5 id="AO背后的数学原理"><a href="#AO背后的数学原理" class="headerlink" title="AO背后的数学原理"></a>AO背后的数学原理</h5><p>有了形象解释，再来看渲染方程</p><script type="math/tex; mode=display">L_o(p,\omega_o)=\int_{\Omega+} L_i(p,\omega_i) f_r(p,\omega_i,\omega_o)V(p,\omega_i) cos\theta_i \, \mathrm{d}\omega_i\\\int_\Omega f(x)g(x)dx\approx\frac{\int_\Omega f(x)dx}{\int_\Omega dx}·\int_\Omega g(x) \, \mathrm{d}x\\L_o(p,\omega_o) \approx \frac{\int_{\Omega+}V(p,\omega_i)\cos\theta_i \, \mathrm{d}\omega_i}{\int_{\Omega+}\cos\theta_i \, \mathrm{d}\omega_i}·\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_i \, \mathrm{d}\omega_i</script><p>为了方便理解，我们需要再次用之前那个积分近似公式 把Visibility项拆出来，只不过这次我们并不是简简单单的对拆出去的Visibility取平均，而是引入了一个新的概念——投影立体角</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/%E6%8A%95%E5%BD%B1%E7%AB%8B%E4%BD%93%E8%A7%921.png" alt="投影立体角1"></p><p>从图中可以看到，我们原先定义的立体角是在单位球上的一个面积微元，$\mathrm{d}\omega<em>i=\sin{\theta} \mathrm{d}\theta\mathrm{d}\phi$，如果我们在此基础上，将这个面积微元向x-y平面投影，就会得到一个单位圆上的面积微元，而这块面积我们就称其为投影立体角，$\mathrm{d}x</em>{\perp}=\cos{\theta<em>i}\,\mathrm{d}\omega_i$，不难看出，对单位半球面上的投影立体角求积分的结果，就相当于在求一个单位圆的面积，那么约等式的前半部分就可以理解为是在对 <strong>单位半球面  沿法线垂直向下投影  所得的单位圆内</strong>对可见性按照cos值进行加权平均；而对于式子的后半部分，由于我们假设了间接光照强度是一个定值，且材质BRDF全都统一为diffuse，所以整个后半段积分积出来就是个常数，$L</em>{indir}·\frac{\rho}{\pi}·\pi=L_{indir}·\rho$，这对于积分近似公式也是100%准确的</p><p>由上，原式最后可以化简如下</p><script type="math/tex; mode=display">L_o(p,\omega_o)=\int_{\Omega+} L_i(p,\omega_i) f_r(p,\omega_i,\omega_o)V(p,\omega_i) cos\theta_i \, \mathrm{d}\omega_i\\=\frac{\rho}{\pi}·L_i(p)· \int_{\Omega+}V(p,\omega_i)\cos\theta_i \, \mathrm{d}\omega_i\\</script><p>通过这个式子我们就可以很直观的了解到AO背后的实现原理，即==环境的间接光照 = 来自远处的未被遮挡的光线==</p><p>值得注意的是，此处的“来自远处”并不代表着可见判断范围可以无限大，因为在某些特定的封闭场景下（如室内），如果可见性判定范围无穷大，将会得到一个AO处处为1的结果（即没有间接光照），而若判定范围不足，则会造成可见信息的丢失，因此我们为了得到准确的AO，一般都会选取一个合适的判定半径，在一个半球范围内完成操作，这是一个不可避免的trade off</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/AO3.png" alt="AO3"></p><h4 id="SSAO"><a href="#SSAO" class="headerlink" title="SSAO"></a>SSAO</h4><p>经过上述分析，我们已经得到了场景AO的计算方法，那么现在的问题就只剩下如何（在屏幕空间中）求Visibility的积分了</p><p>对此，SSAO（Screen-Space Ambient Occulusion）的解决方案如下：</p><ul><li>首先从相机出发，得到屏幕空间的深度信息，写入z-buffer</li><li>对屏幕空间的任意一个像素（着色点），在以它为中心、R为半径的球体范围内随机寻找数个采样点，判断其可见性</li><li>若该采样点的深度大于它在屏幕空间对应的深度，则认为该点不可见，记可见性为0（下图绿点）</li><li>计算可见性为1的采样点的占比，作为当前像素的visibility值</li></ul><p>在早些时候，屏幕空间渲染还无法获得法线信息，因此那时候SSAO只能通过考虑visibility小于50%的情况来近似AO，并且同时无法使用上面推导的cos对可见性进行加权</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/%E6%97%A9%E6%9C%9FSSAO.png" alt="早期SSAO"></p><p>而在延迟渲染普及之后，我们就可以更加准确的在法向半球内采样，进而也能够使用法线与采样点之间的夹角余弦对结果做加权平均</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/SSAO.png" alt="SSAO"></p><p>但是即使这样，在特定的采样点我们仍会得到错误的结果，如上图中红色虚线右侧的红点，理论上它应该需要为其对应着色点计算贡献，但却由于深度测试 该点被错误判定为不可见，而导致结果产生多余的阴影</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/SSAO%E9%94%99%E8%AF%AF.png" alt="SSAO错误"></p><p>对于这样的错误，首先它并不会对最终结果造成太大的影响，其次SSAO也没有什么可靠的解决方案，所以在实际计算过程中我们一般选择忽略不计……</p><p>纵观SSAO的整个实现过程，我们可以发现它的思路非常像PCF做软阴影，采样的过程也极其相似，样本数量越大，结果越好，效率越慢，只不过由于在屏幕空间做后处理非常方便，通常情况我们不会直接使用非常高的采样率，而是会先采用一个较低的采样(64次以内)，再对它做一次降噪，降噪残留的模糊与噪声在与其他光照叠加计算后会得到一定掩盖，所以我们并不需要过多的担心质量的问题</p><div class="table-container"><table><thead><tr><th>Q：减少采样半径可以缓解false occlusion么？</th></tr></thead><tbody><tr><td><strong>A：可以，但减少采样半径会伴随着AO自身效果的变淡</strong></td></tr></tbody></table></div><h4 id="HBAO"><a href="#HBAO" class="headerlink" title="HBAO"></a>HBAO</h4><p>这里老师讲的并不是非常明白，如果有需要可以参考：<a href="https://zhuanlan.zhihu.com/p/367793439">【论文复现】Image-Space Horizon-Based Ambient Occlusion</a></p><p>HBAO（Horizon-Based Ambient Occlusion）相比SSAO，不仅改善了冗余阴影的问题，还大大减少了采样率的需求，使得它成为了目前手机端最主流的环境光遮蔽算法</p><p>其主要思想是，使用==多次光线步进== 找到<u>着色点切平面</u>与<u>遮挡物采样点</u>形成的最大角度，再通过这个角度来计算物体与物体间的遮挡程度，从而完成对环境光遮蔽的近似</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/HBAO.png" alt="HBAO"></p><p>公式如下：</p><script type="math/tex; mode=display">AO_p=1- \frac{1}{2\pi} \int_{\Omega} \cos(\alpha)W(\omega_i) \, \mathrm{d}\omega_i\\=1- \frac{1}{2\pi} \int_{\theta=-\pi}^{\pi}(\sin(H(\theta))-\sin(t(\theta)))W(\omega_i) \, \mathrm{d}\omega_i</script><p>公式中的sin可以由万能公式换成tan进行计算，其余推导见链接</p><p>下图展示了SSAO与HBAO各自的效果，可以看到，二者还是存在一定质量上的差距的</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p8/SSAO%E3%80%81HBAO%E6%95%88%E6%9E%9C.gif" alt="SSAO、HBAO效果"></p><h4 id="SSDO"><a href="#SSDO" class="headerlink" title="SSDO"></a>SSDO</h4><p>和HBAO一样，SSDO （Screen Space Directional Occlusion）也是一种对于SSAO的改进算法，它几乎照搬了RSM的实现思路，通过在屏幕空间计算一系列虚拟光源的贡献，以较小的代价取得了相比SSAO更为准确的结果</p><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>其计算过程大致可以分为两部分——直接光照与间接光照：</p><ul><li><p><strong>直接光照</strong></p><p>在着色点的法向半球内随机寻找若干采样点，判断其可见性，以此确定是否要为该采样点计算直接光照</p><p>下左图中，$\textcolor{red}{A、B、D}$均为遮挡，因此仅需要计算$\textcolor{red}{C}$点的直接光照：</p><script type="math/tex; mode=display">L_o^{dir}(p,\omega_o)=\int_{\Omega+,\textcolor{blue}{V=1}} L_i^\textcolor{blue}{dir}(p,\omega_i)f_r(p,\omega_i,\omega_o) \cos\theta_i \, \mathrm{d}\omega_i</script></li><li><p><strong>间接光照</strong></p><p>在完成直接光照计算后，找到所有采样点在着色点法向半球内对应的表面微元，将它们设置为diffuse的次级光源，再依据次级光源的法线信息判断其有效性，对所有满足条件的次级光源计算间接光贡献</p><p>下右图中，$\textcolor{grey}{C}$点在法向半球以外，$\textcolor{grey}{A}$点因法线朝向问题被判定为无效，所以最后只需计算$\textcolor{grey}{B}$点和$\textcolor{grey}{D}$点的间接光照即可</p><script type="math/tex; mode=display">L_o^{indir}(p,\omega_o)=\int_{\Omega+,\textcolor{blue}{V=0}} L_i^\textcolor{blue}{indir}(p,\omega_i)f_r(p,\omega_i,\omega_o) cos\theta_i \, \mathrm{d}\omega_i\\=\sum_{i=1}^N L_{pixel}(1-V(\omega_i)) · \frac{\rho}{\pi} · \frac{A_s \cos{\theta_{s_i}}\cos{\theta_{r_i}}}{d_i^2}</script></li></ul><p><em>（公式解释：$d<em>i$为着色点$P$到次级光源$P_i$的距离，$\cos{\theta</em>{s<em>i}}$为次级光源$P_i$的法线与$\overrightarrow{P_iP}$的夹角余弦，$\cos{\theta</em>{r<em>i}}$为$P$点法线与$\overrightarrow{PP_i}$的夹角余弦，$A_s$为为调节渗光程度的因子，表示虚拟点光源的面积，此处为$\frac{\pi r^2</em>{max}}{N}$）</em></p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSDO.png" alt="SSDO"></p><p>可以看到，SSDO与SSAO的最大区别在于它们==计算间接光照的来源不同==，SSAO认为间接光来源于远处的未被遮挡的光线，而SSDO则认为它们来自于周围较近的遮挡物体的反射，正因为这一点，SSDO可以直接通过屏幕空间的像素颜色对间接光照进行估计，而不再需要将间接光照设为一个定值代入计算，也正因如此，SSDO的结果会得到更多的细节表现（color bleeding）</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSAO%E3%80%81SSDO%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94gif.gif" alt="SSAO、SSDO效果对比gif"></p><h5 id="SSDO存在的问题"><a href="#SSDO存在的问题" class="headerlink" title="SSDO存在的问题"></a>SSDO存在的问题</h5><p>由于SSDO和SSAO一样是屏幕空间的计算方法，所以它具有一切使用屏幕空间算法的弊端，如flase occlusion，信息丢失等</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSDO%E7%9A%84%E9%97%AE%E9%A2%98%20(1" alt="SSDO的问题 (1)">.png)</p><p>就以图中的A点和B点为例，对于A点，理论上应该分别对直接光照和间接光照进行计算，但是SSDO将其判定为不可见，并错误的设置了虚拟光源，导致在A点处产生了flase occlusion；而对于B点，在计算其直接光照时，SSDO直接计算了PB连线上的光照信息而忽略了遮挡，导致B点发生漏光</p><p>更重要的是，SSDO对间接光的近似方法是通过计算附近遮挡物的反射，所以它无法做到像SSAO那样考虑来自远处的间接光（其实按道理讲SSAO与SSDO应该互相配合着一起使用，但现实如何我们无从得知）另外，屏幕空间的信息丢失对SSDO的影响也会更加明显，因为几何特征的丢失会伴随着颜色信息的丢失，如下图中的两个长方体，随着它们摆放角度的逐渐垂直，地面上的颜色信息也会逐渐消失</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSDO%E7%9A%84%E9%97%AE%E9%A2%98%20(2" alt="SSDO的问题 (2)">.png)</p><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p>我们前面介绍的这三种方法，SSAO、HBAO与SSDO，都是基于屏幕空间的环境光遮蔽提出的GI近似算法，但它们对于间接光照的理解都没有触及到问题的本质。回顾一下我们一开始对于全局光照的定义，它的核心是如何通过模拟光线的==传播路径==来计算比直接光照==多一次bounce==的光照结果，也就是说，如果想要在屏幕空间得到一个更加真实的结果，还是得靠光线追踪才能实现。托 延迟渲染 的福，现在的屏幕空间已经基本具备了所有模拟光线弹射的条件（法线，深度，balabala），那么剩下的问题就是如何与物体求交做shading，也就是我们接下来要介绍的最后一种方法——SSR（屏幕空间反射，screen-space relfections）</p><h5 id="再提Ray-Marching"><a href="#再提Ray-Marching" class="headerlink" title="再提Ray-Marching"></a>再提Ray-Marching</h5><p>因为在屏幕空间中只能获得场景几何最浅深度上的一些信息，所以我们无法再继续像3d空间那样用Möller-Trumbore等算法做Ray-casting了，那么为了计算光线与物体求交就必须转变一下思路，使用Ray-Marching来做判断</p><p>有关光线步进这个概念，我们已经在HBAO和之前的DFSS算法中多次提及，它无非就是让光线按一定步长向前迈进，同时判断是否与物体产生相交。由于这种计算方式适用于无法通过套公式进行求交的情况，所以在体渲染中得到了大量的应用，而对于SSR屏幕空间，只要再在此基础上多加一步空间转换，配合DDA画线算法，就可以完成这步操作了</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/Ray-Marching.png" alt="Ray-Marching"></p><p>具体参考 <a href="https://zhuanlan.zhihu.com/p/386510829">【论文复现】Efficient GPU Screen-Space Ray Tracing</a>，以及<a href="https://www.zhihu.com/question/29863225">Ray-tracing和Ray-marching的区别</a></p><h5 id="Hierarchical-tracing加速结构"><a href="#Hierarchical-tracing加速结构" class="headerlink" title="Hierarchical tracing加速结构"></a>Hierarchical tracing加速结构</h5><p>现在我们解决了屏幕空间的求交问题，但显然这种方法对实时渲染来说太慢了，虽然这种逐像素逐步长Ray-Marching非常稳妥，但中间的过程存在大量的性能浪费，这并不是我们所想看到的。那么有没有一种方法，既可以替代这种遍历式步进，又可以做到像三维的BVH / KD-Tree那样的加速效果呢？</p><p>于是有人就参照SDF，提出了一种基于动态步长的层级加速结构，这个结构有点类似Mipmap，会首先对深度缓存中的屏幕深度生成一个层级纹理，这个过程并不是像Mipmap那种做双线性插值，而是取四个像素的最小深度直接写入缓冲，如图</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/%E5%B1%82%E7%BA%A7%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2.png" alt="层级深度缓冲"></p><p>这时候我们再看下图的二维几何近似，可以发现这种层级结构刚好相当于对原场景生成了多个层级的包围盒，并且在级与级之间很自然的形成了一棵树形结构</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%841.png" alt="加速结构1"></p><p>直接上伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">intersect</span><span class="params">(<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(level&gt;<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span>( hit level-&gt;node[i++] )</span><br><span class="line">level--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(level&gt;<span class="number">-1</span> &amp;&amp; in screen)<span class="comment">//求交成功/失败-&gt;退出循环</span></span><br><span class="line">&#123;</span><br><span class="line">    step through current cell;<span class="comment">//按当前level步长向前迈进</span></span><br><span class="line">    <span class="keyword">if</span>(above Z plane)</span><br><span class="line">        level++;<span class="comment">//若没有交点，则加大步长</span></span><br><span class="line">    <span class="keyword">if</span>(below Z plane) </span><br><span class="line">    &#123;</span><br><span class="line">        level--;<span class="comment">//若有交点则遍历当前层级</span></span><br><span class="line">intersect(level);<span class="comment">//定位到相交的子节点，随后缩短步长，在子节点层级继续求交</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84.gif" alt="加速结构"></p><p>按paper的写法确实应该多一步增大步长，但这样会破坏树形结构，不太方便理解</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%842.png" alt="加速结构2"></p><h5 id="着色-amp-采样方法"><a href="#着色-amp-采样方法" class="headerlink" title="着色&amp;采样方法"></a>着色&amp;采样方法</h5><p>求到光线与物体的交点，剩下的工作就简单了。SSR计算着色的方法几乎与路径追踪一模一样，如果是specular材质则cast一次，是glossy材质就用蒙特卡洛重要性采样多次计算（这里需要假设次级反射物为diffuse），正因为这一点，SSR才具备了实现许多路径追踪自带高质量效果的能力，如下图中的接触锐化和各向同性拉伸：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Glossy &amp; Blurry</th><th style="text-align:center">Contact hardening（接触锐化）</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSR%E6%95%88%E6%9E%9C1.png" alt="SSR效果1"></td><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSR%E6%95%88%E6%9E%9C2.png" alt="SSR效果2"></td></tr><tr><td style="text-align:center"><strong>Specular elongation（各向同性拉伸）</strong></td><td style="text-align:center"><strong>Spacial Varying</strong></td></tr><tr><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSR%E6%95%88%E6%9E%9C3.png" alt="SSR效果3"></td><td style="text-align:center"><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSR%E6%95%88%E6%9E%9C4.png" alt="SSR效果4"></td></tr></tbody></table></div><p>唯一的不同在于，SSR不用考虑光线的平方衰减，并且可以保证交点的可见性，这是因为SSR的采样对象是brdf本身，而只有在对光源采样的时候才要考虑衰减和遮挡…</p><p>至于对采样算法的优化，一方面我们可以采用之前的pre-filtering，通过提前对glossy反射波瓣的覆盖区域做滤波处理，来加快实际渲染速度。但这里有一点需要注意，屏幕空间的滤波操作还需要考虑深度值大小（原因如下图所示），在此我们不做深入讨论</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/%E7%A9%BA%E9%97%B4%E5%A4%8D%E7%94%A81.png" alt="空间复用1"></p><p>另外，因为反射平面上邻近的两个着色点很有可能会采样到同一个交点，所以我们还可以对交点进行复用，如图：</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/%E7%A9%BA%E9%97%B4%E5%A4%8D%E7%94%A82.png" alt="空间复用2"></p><p>（p.s. 还有一些时间上的加速算法，留到后续的实时光线追踪中详细介绍）</p><h5 id="SSR总结"><a href="#SSR总结" class="headerlink" title="SSR总结"></a>SSR总结</h5><p>综合来看，SSR是一个极其优秀的屏幕空间算法，既能在实时的条件下根据不同材质得到不同的高质量结果，又能忽略前面AO算法中的各种遮挡问题，集各种优良性质于一身，属实nb</p><p>不过金无足赤，SSR也有自己不完美的地方，首先还是信息丢失的问题，这是屏幕空间算法的通病，无需多言</p><p><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSR%E7%BC%BA%E7%82%B9%20(1" alt="SSR缺点 (1)">.png)</p><p>另外还有就是它的硬边问题了，如果不做软化处理，结果会显得非常不自然，如图：</p><div class="table-container"><table><thead><tr><th><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSR%E7%BC%BA%E7%82%B9%20(2" alt="SSR缺点 (2)">.png)</th><th><img src="/posts/25879/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/202/%E5%9B%BE%E7%89%87/p9/SSR%E7%BC%BA%E7%82%B9%20(3" alt="SSR缺点 (3)">.png)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES202 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（1）-基础引入</title>
      <link href="/posts/40876.html"/>
      <url>/posts/40876.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h1><p><img src="/posts/40876/%E5%85%89%E6%A0%85%E5%8C%96.png" alt="Alt text"></p><p>计算机图形学下关于“实时”的定义：&gt;30fps，&lt;30fps称为离线</p><p><strong>计算机视觉与计算机图形学的区别：</strong><br><img src="/posts/40876/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="Alt text"></p><h1 id="二、线代基础"><a href="#二、线代基础" class="headerlink" title="二、线代基础"></a>二、线代基础</h1><h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><p><strong>叉乘基本运算</strong></p><script type="math/tex; mode=display">\displaylines{\vec{a}\times\vec{b}=-\vec{b}\times\vec{a}\\\\\vec{a}\times\vec{a}=\vec{0} \\\\\vec{a}\times(\vec{b}+\vec{c})=\vec{a}\times\vec{b}+\vec{a}\times\vec{c} \\\\\vec{a}\times(k\vec{b})=k(\vec{a}\times\vec{b})}</script><p>图形学叉乘应用：判断左/右&amp;内/外</p><p><strong>正交坐标系定义</strong></p><script type="math/tex; mode=display">\displaylines{||\vec{u}||=||\vec{v}||=||\vec{w}||\\\\\vec{u}\cdot\vec{v}=\vec{v}\cdot\vec{w}=\vec{w}\cdot\vec{u}\\\\\vec{w}=\vec{u}\times\vec{v}（右手）\\\\\vec{p}=(\vec{p}\cdot\vec{u})\vec{u}+(\vec{p}\cdot\vec{v})\vec{v}+(\vec{p}\cdot\vec{w})\vec{w}}</script><p><strong>矩阵乘法</strong><br>要第几行第几列，就去找第几行和第几列，左管行，右管列</p><p>设矩阵A和矩阵B，则：</p><p>1、AB和BA大多数情况下不等</p><p>2、只要不涉及前后交换，以下等式均成立</p><script type="math/tex; mode=display">\displaylines{(AB)C=A(BC)\\\\A(B+C) = AB +AC\\\\(A+B)C =AC ＋BC\\\\}</script><p><strong>矩阵和向量的乘法</strong></p><p>总是把向量视作列向量并置于乘号右边</p><p><strong>矩阵转置（ij -&gt; ji）</strong></p><script type="math/tex; mode=display">(AB)^T=B^TA^T</script><p><strong>单位矩阵</strong></p><script type="math/tex; mode=display">\displaylines{AA^{-1}=A^{-1}A=I\\\\AB^{-1}=B^{-1}A^{-1}}</script><p><strong>向量乘法的矩阵形式</strong></p><script type="math/tex; mode=display">\displaylines{\vec{a}\cdot\vec{b}=\vec{a}^T\vec{b}\\\\\vec{a}\times\vec{b}=A^*b}</script><h2 id="向量变换"><a href="#向量变换" class="headerlink" title="向量变换"></a>向量变换</h2><h3 id="2d"><a href="#2d" class="headerlink" title="2d"></a>2d</h3><h4 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h4><div class="table-container"><table><thead><tr><th style="text-align:center">缩放</th><th style="text-align:center">切变</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/40876/%E7%BA%BF%E6%80%A7%E5%8F%98%E5%8C%96-%E7%BC%A9%E6%94%BE.png" alt="Alt text"></td><td style="text-align:center"><img src="/posts/40876/%E7%BA%BF%E6%80%A7%E5%8F%98%E5%8C%96-%E5%88%87%E5%8F%98.png" alt="Alt text"></td></tr><tr><td style="text-align:center"><strong>对称</strong></td><td style="text-align:center"><strong>旋转</strong></td></tr><tr><td style="text-align:center"><img src="/posts/40876/%E7%BA%BF%E6%80%A7%E5%8F%98%E5%8C%96-%E5%AF%B9%E7%A7%B0.png" alt="Alt text"></td><td style="text-align:center"><img src="/posts/40876/%E7%BA%BF%E6%80%A7%E5%8F%98%E5%8C%96-%E6%97%8B%E8%BD%AC.png" alt="Alt text"></td></tr></tbody></table></div><p>相同维度线性变化：</p><script type="math/tex; mode=display">\displaylines{x'=ax+by\\\\y'=cx+dy\\\\\left[ \begin{matrix}x'\\\\y'\\\\\end{matrix}\right]=\left[ \begin{matrix}a&b\\\\c&d\\\\\end{matrix}\right]\left[\begin{matrix}x\\\\y\\\\\end{matrix}\right]\\\\x'=Mx}</script><h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><p>点(x,y,1)    向量(x,y,0)    则有：</p><p>点-点=向量，向量$\pm$向量=向量，点+向量=点，点+点=两点的中点</p><p>在齐次坐标中，$\left(\begin{matrix}x\\ y\\ w \end{matrix} \right)$都视作$\left(\begin{matrix}x/w\\ y/w\\ 1 \end{matrix}\right)$，其中$w≠0$</p><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p>仿射变化=线性变换+平移</p><div class="table-container"><table><thead><tr><th><img src="/posts/40876/%E4%BB%BF%E5%B0%84%E5%8F%98%E5%8C%96.png" alt="Alt text"></th><th><img src="/posts/40876/仿射变化-2d transformation.png" alt="Alt text"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>矩阵相乘不满足结合律</p><p>例如，先旋转再平移和先平移再旋转所得结果不一样</p><h4 id="变换合成（结合律的体现）"><a href="#变换合成（结合律的体现）" class="headerlink" title="变换合成（结合律的体现）"></a>变换合成（结合律的体现）</h4><p><img src="/posts/40876/%E5%90%88%E6%88%90%E5%8F%98%E6%8D%A2.png" alt="Alt text"></p><h3 id="3d"><a href="#3d" class="headerlink" title="3d"></a>3d</h3><div class="table-container"><table><thead><tr><th style="text-align:center">平移</th><th style="text-align:center">缩放</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/40876/%E5%B9%B3%E7%A7%BB.png" alt="Alt text"></td><td style="text-align:center"><img src="/posts/40876/%E7%BC%A9%E6%94%BE.png" alt="Alt text"></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>旋转</th><th></th></tr></thead><tbody><tr><td><img src="/posts/40876/%E6%97%8B%E8%BD%AC1.png" alt="Alt text"></td><td><img src="/posts/40876/%E6%97%8B%E8%BD%AC2.png" alt="Alt text"></td></tr></tbody></table></div><p>3d旋转变换矩阵遵循循环对称：$X\times Y=Z,\ \ Y\times Z=X,\ \ Z\times X=Y$</p><p>合成的旋转变换：$R_{xyz}(\alpha,\beta,\gamma)=R_x(\alpha)R_y(\beta)R_z(\gamma)$</p><h4 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h4><p>绕旋转轴n旋转α角度</p><script type="math/tex; mode=display">R(n,\alpha)=cos(\alpha)E+(1-cos(\alpha))nn^T+sin(\alpha)\left(\begin{matrix}0     & -n_z    & n_y    \\\\n_z     & 0    & -n_x    \\\\-n_y & n_x    & 0\end{matrix}\right)</script><p>推导过程：<br><a href="https://zhuanlan.zhihu.com/p/113299607?utm_source=qq&utm_medium=social&utm_oi=605668290971045888" target="_blank" title="罗德里格斯公式Rodrigues'Rotation Formula推导" referrerpolicy="no-referrer" class="link_card"><div class="link_icon"><svg t="1670307855063" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="19066" width="200" height="200"><path d="M504.064 516.608m-384.256 0a384.256 384.256 0 1 0 768.512 0 384.256 384.256 0 1 0-768.512 0Z" fill="#009CF5" p-id="19068"/><path d="M746.112 270.464L472.448 485.12l63.104 63.104L750.08 274.56c2.304-2.688-1.28-6.144-3.968-4.096z" fill="#FF4C3A" p-id="19069"/><path d="M262.016 762.752l273.664-214.528-63.104-63.104-214.656 273.536c-2.176 2.688 1.28 6.144 4.096 4.096z" fill="#FFFFFF" p-id="19070"/><path d="M505.216 155.136c-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.56 5.888 5.888 5.888s5.888-2.56 5.888-5.888v-53.504c-0.128-3.2-2.688-5.888-5.888-5.888zM442.368 160.512c-3.2 0.512-5.376 3.584-4.736 6.784l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736zM396.288 234.368c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552l-18.304-50.304c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552l18.304 50.304zM348.928 257.408c1.664 2.816 5.248 3.712 7.936 2.176s3.712-5.248 2.176-7.936l-26.752-46.336c-1.664-2.816-5.248-3.712-7.936-2.176-2.816 1.664-3.712 5.248-2.176 7.936l26.752 46.336zM306.304 288.256c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.432 2.048-2.816 5.76-0.768 8.192l34.432 40.96zM269.696 326.144c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-2.048 2.432-1.792 6.144 0.768 8.192l40.96 34.432zM193.792 342.912l46.336 26.752c2.816 1.664 6.4 0.64 7.936-2.176 1.664-2.816 0.64-6.4-2.176-8.064L199.552 332.8c-2.816-1.664-6.4-0.64-7.936 2.176-1.664 2.688-0.64 6.272 2.176 7.936zM168.32 399.488l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM207.872 457.344l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784zM201.984 509.568H148.48c-3.2 0-5.888 2.56-5.888 5.888 0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888zM205.44 562.176l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.376 6.784 4.736l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784s-3.584-5.248-6.784-4.736zM217.856 613.376l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 3.072 4.48 4.608 7.552 3.456l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456zM238.976 661.504l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.816 5.248 3.712 8.064 2.176l46.336-26.752c2.816-1.664 3.712-5.248 2.176-8.064-1.664-2.816-5.248-3.712-8.064-2.176zM268.16 705.408l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.432 5.76 2.816 8.192 0.768l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-1.92-2.56-5.632-2.816-8.192-0.768zM304.512 743.424l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.304-1.92-6.016-1.664-8.192 0.768zM347.008 774.656l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.664 6.4 0.64 8.064-2.176l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.536-6.4-0.64-8.064 2.176zM394.24 798.08l-18.304 50.304c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.152 6.4-0.512 7.552-3.456l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.528 0.384-7.552 3.456zM440.192 872.32c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.64 3.2 1.536 6.272 4.736 6.784zM502.912 878.08c3.2 0 5.888-2.56 5.888-5.888v-53.504c0-3.2-2.56-5.888-5.888-5.888-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.688 5.888 5.888 5.888zM549.632 815.232l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736-3.2 0.512-5.248 3.584-4.736 6.784zM600.832 802.816l18.304 50.304c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552L611.84 798.72c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552zM649.088 781.696l26.752 46.336c1.664 2.816 5.248 3.712 8.064 2.176 2.816-1.664 3.712-5.248 2.176-8.064l-26.88-46.336c-1.664-2.816-5.248-3.712-8.064-2.176-2.816 1.664-3.712 5.248-2.048 8.064zM692.864 752.384l34.432 40.96c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.56 2.048-2.816 5.76-0.768 8.192zM730.88 716.032l40.96 34.432c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-1.92 2.432-1.664 6.144 0.768 8.192zM762.112 673.664l46.336 26.752c2.816 1.664 6.4 0.64 8.064-2.176 1.664-2.816 0.64-6.4-2.176-7.936L768 663.552c-2.816-1.664-6.4-0.64-8.064 2.176-1.536 2.688-0.64 6.272 2.176 7.936zM785.536 626.432l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM800.256 575.872l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784zM800.256 517.76c0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888h-53.504c-3.328 0-5.888 2.56-5.888 5.888zM802.688 471.04l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784-0.512-3.2-3.584-5.376-6.784-4.736l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.248 6.784 4.736zM790.272 419.84l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 2.944 4.48 4.608 7.552 3.456zM769.152 371.584l46.336-26.752c2.816-1.664 3.712-5.248 2.176-7.936-1.664-2.816-5.248-3.712-8.064-2.176l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.688 5.248 3.712 8.064 2.048zM739.84 327.808l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-2.048-2.432-5.76-2.816-8.192-0.768l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.56 5.76 2.816 8.192 0.768zM703.488 289.664l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.432-2.048-6.144-1.792-8.192 0.768l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768zM661.12 258.56l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.664-6.4-0.64-8.064 2.176l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.536 6.4 0.64 8.064-2.176zM613.888 235.136l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.4 0.512-7.552 3.456L602.88 231.168c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.024 6.4-0.512 7.552-3.584zM556.544 225.152c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.512 3.2 1.536 6.144 4.736 6.784zM273.536 290.432c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96l21.12 21.12zM237.824 333.824c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536s-1.28 6.912 1.536 8.832l24.448 17.152zM183.04 370.176l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 7.04 3.072 8.448zM194.688 423.68l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.152 6.912 4.48 7.808l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808zM183.168 478.72l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.456 2.304 6.656 5.76 6.912l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.384-3.456-2.176-6.528-5.76-6.912zM181.504 535.04l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.456 6.144 6.912 5.76l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.328-6.016-6.912-5.76zM191.36 590.72l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.352 5.376 7.808 4.48l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.328-4.352-5.376-7.808-4.48zM207.232 644.224l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.2 5.248 4.608 8.448 3.072l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.408-3.2-5.248-4.48-8.448-3.072zM233.984 693.888l-24.448 17.152c-2.944 2.048-3.584 6.016-1.536 8.832 2.048 2.944 6.016 3.584 8.832 1.536l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536zM310.912 775.552L293.76 800c-2.048 2.944-1.28 6.912 1.536 8.832 2.944 2.048 6.912 1.28 8.832-1.536l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.816-2.048-6.912-1.408-8.832 1.536zM349.184 840.704c3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.536-3.2 0.128-7.04-3.072-8.448-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.408 3.2-0.128 6.912 3.072 8.448zM407.808 862.72c3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c0.896-3.456-1.152-6.912-4.48-7.808-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.328 1.152 6.912 4.48 7.808zM469.376 874.112c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.584 2.304 6.656 5.76 6.912zM522.496 839.168l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.456-6.144-6.912-5.76-3.456 0.256-6.016 3.328-5.76 6.912zM578.176 830.976l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928c-0.896-3.456-4.352-5.376-7.808-4.48-3.328 0.896-5.376 4.48-4.48 7.808zM631.68 813.312l12.672 27.136c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.248 3.072-8.448l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.48 5.248-3.072 8.448zM681.344 786.688l17.152 24.448c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 1.92-3.584 5.888-1.536 8.832zM725.504 751.744l21.12 21.12c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96zM763.008 709.76l24.448 17.152c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536-2.048 2.816-1.408 6.784 1.536 8.832zM792.576 661.888l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 6.912 3.072 8.448zM813.44 609.536l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.024 6.912 4.48 7.808zM824.832 554.368l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.256-3.456-2.304-6.656-5.76-6.912l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.584 2.304 6.656 5.76 6.912zM826.624 498.176l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.456-6.144-6.912-5.76l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.328 6.016 6.912 5.76zM818.432 442.368l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.456-4.352-5.376-7.808-4.48l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.48 5.376 7.808 4.48zM800.768 388.992l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.536-3.2-5.248-4.608-8.448-3.072l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.072 5.248 4.48 8.448 3.072zM774.144 339.328l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536L766.848 328.96c-2.944 2.048-3.584 6.016-1.536 8.832 1.92 2.816 5.888 3.584 8.832 1.536zM697.216 257.664l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.944-2.048-6.912-1.28-8.832 1.536l-17.152 24.448c-2.048 2.944-1.28 6.912 1.536 8.832 2.816 2.048 6.784 1.408 8.832-1.536zM658.944 192.512c-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.536 3.2-0.128 7.04 3.072 8.448 3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.408-3.2 0-7.04-3.072-8.448zM600.192 170.496c-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.456 1.152 6.912 4.48 7.808 3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c1.024-3.328-1.024-6.912-4.48-7.808zM534.912 201.6c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.456 2.304 6.528 5.76 6.912zM476.032 158.464c-3.456 0.256-6.144 3.456-5.76 6.912l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.328-6.016-6.912-5.76zM422.144 173.312c-0.896-3.456-4.352-5.376-7.808-4.48-3.456 0.896-5.376 4.352-4.48 7.808l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928zM376.448 219.776l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.608 5.248-3.072 8.448L364.8 225.28c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.376 3.2-8.576zM316.416 253.824c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 2.048-3.584 6.016-1.536 8.832l17.152 24.448z" fill="#FFFFFF" p-id="19071"/></svg></div><div class="link_content"><div class="link_title">罗德里格斯公式Rodrigues'Rotation Formula推导</div></div></a></p><p><strong>四元数：旋转与旋转之间的差值，具体内容略去</strong></p><h2 id="视图-相机变换"><a href="#视图-相机变换" class="headerlink" title="视图 / 相机变换"></a>视图 / 相机变换</h2><h3 id="如何将三维变成二维并在屏幕上显示出来"><a href="#如何将三维变成二维并在屏幕上显示出来" class="headerlink" title="如何将三维变成二维并在屏幕上显示出来"></a>如何将三维变成二维并在屏幕上显示出来</h3><p>1、模型变换 (M)        2、相机变换 (V)        3、投影变换 (P)</p><h3 id="定义相机属性"><a href="#定义相机属性" class="headerlink" title="定义相机属性"></a>定义相机属性</h3><p>1、位置 $\vec{e}$</p><p>2、视线方向 $\widehat{g}$</p><p>3、垂直方向 $\widehat{t}$</p><p>初始：up at Y, look at -Z</p><p>如果把摄像机和世界一起变换，那么照片是一样的，所以把摄像机变换到新坐标系的原点，其他所有物体也做同样的变换</p><h3 id="teg坐标系怎么转变为xyz坐标系"><a href="#teg坐标系怎么转变为xyz坐标系" class="headerlink" title="teg坐标系怎么转变为xyz坐标系"></a>teg坐标系怎么转变为xyz坐标系</h3><p>$M_{view}$ in Math?</p><p>$M<em>{view}$=$R</em>{view}$$T_{view}$</p><p>1、先做平移，$T_{view}=\left[\begin{matrix}1&amp;0&amp;0&amp;-x_e\\ 0&amp;1&amp;0&amp;-y_e\\ 0&amp;0&amp;1&amp;-z_e\\ 0&amp;0&amp;0&amp;1\end{matrix}\right]$</p><p>2、再做旋转，顺着思路要把 $\widehat{g}$ 旋转到$-Z$坐标轴，把 $\widehat{t}$ 旋转到$Y$坐标轴，把$（g\times t）$旋转到 $x$ 坐标轴，但这样的旋转矩阵非常难写</p><p>​      所以采用逆向思路，把坐标轴移到相机坐标轴，通过逆操作写（该旋转矩阵为正交矩阵，其逆矩阵就是它的转置矩阵）（基变换）</p><script type="math/tex; mode=display">    R^{-1}\_{view}=    \left[\begin{matrix}    x_{\widehat g\times \widehat t} & x_t & x_{-g} & 0 \\\\    y_{\widehat g\times \widehat t} & y_t & y_{-g} & 0 \\\\    z_{\widehat g\times \widehat t} & z_t & z_{-g} & 0 \\\\    0 & 0 & 0 & 1    \end{matrix}\right]</script><script type="math/tex; mode=display">    R_{view}=    \left[\begin{matrix}    x_{\widehat g\times \widehat t} & y_{\widehat g\times \widehat t} & z_{\widehat g\times \widehat t} & 0\\\\    x_t & y_t & z_t & 0\\\\    x_{-g} & y_{-g} & z_{-g} & 0\\\\    0 & 0 & 0 & 1    \end{matrix}\right]</script><h3 id="投影变换（难点）"><a href="#投影变换（难点）" class="headerlink" title="投影变换（难点）"></a>投影变换（难点）</h3><p><img src="/posts/40876/%E6%AD%A3%E4%BA%A4or%E9%80%8F%E8%A7%86.png" alt="Alt text"></p><h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>相机位置无限远，没有远近概念（忽略深度信息）</p><p>步骤：先做平移，再做缩放，目标是吧投影全塞在 $[-1,1]^2$ 的长方体内</p><p><img src="/posts/40876/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1%E6%AD%A5%E9%AA%A4.png" alt="Alt text"></p><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>用的最广泛的投影，近大远小，</p><p>根据已知的$Near、Far、Fov、Aspect$确定透视投影的投影矩阵，如下</p><script type="math/tex; mode=display">M_{frustum}=\left[\begin{matrix}\frac{cot\frac{FOV}{2}}{Aspect}    &    0    &    0    &    0 \\\\0    &    cot{\frac{FOV}{2}}    &    0    &    0 \\\\0    &    0    &    \frac{Near+Far}{Near-Far}    &    -\frac{2Near·Far}{Near-Far} \\\\0    &    0    &    1    &    0\end{matrix}\right]</script><p>具体推导如下：<br><img src="/posts/40876/%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81P79.png" alt="Alt text"></p><p>关于课上的思考问题，视锥体压缩成长方体以后，内部的点的z值是更偏向于近平面还是更偏向于远平面？</p><!-- <a href="链接"  title="标题" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src="图标" class="no-lightbox"></div><div class="link_content"><div class="link_title">标题</div><div class="link_desc">介绍</div></div></a> --><a href="https://zhuanlan.zhihu.com/p/122411512?utm_source=qq&utm_medium=social&utm_oi=605668290971045888" target="_blank" title="[图形学笔记]推导投影矩阵" referrerpolicy="no-referrer" class="link_card"><div class="link_icon"><svg t="1670307855063" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="19066" width="200" height="200"><path d="M504.064 516.608m-384.256 0a384.256 384.256 0 1 0 768.512 0 384.256 384.256 0 1 0-768.512 0Z" fill="#009CF5" p-id="19068"/><path d="M746.112 270.464L472.448 485.12l63.104 63.104L750.08 274.56c2.304-2.688-1.28-6.144-3.968-4.096z" fill="#FF4C3A" p-id="19069"/><path d="M262.016 762.752l273.664-214.528-63.104-63.104-214.656 273.536c-2.176 2.688 1.28 6.144 4.096 4.096z" fill="#FFFFFF" p-id="19070"/><path d="M505.216 155.136c-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.56 5.888 5.888 5.888s5.888-2.56 5.888-5.888v-53.504c-0.128-3.2-2.688-5.888-5.888-5.888zM442.368 160.512c-3.2 0.512-5.376 3.584-4.736 6.784l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736zM396.288 234.368c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552l-18.304-50.304c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552l18.304 50.304zM348.928 257.408c1.664 2.816 5.248 3.712 7.936 2.176s3.712-5.248 2.176-7.936l-26.752-46.336c-1.664-2.816-5.248-3.712-7.936-2.176-2.816 1.664-3.712 5.248-2.176 7.936l26.752 46.336zM306.304 288.256c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.432 2.048-2.816 5.76-0.768 8.192l34.432 40.96zM269.696 326.144c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-2.048 2.432-1.792 6.144 0.768 8.192l40.96 34.432zM193.792 342.912l46.336 26.752c2.816 1.664 6.4 0.64 7.936-2.176 1.664-2.816 0.64-6.4-2.176-8.064L199.552 332.8c-2.816-1.664-6.4-0.64-7.936 2.176-1.664 2.688-0.64 6.272 2.176 7.936zM168.32 399.488l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM207.872 457.344l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784zM201.984 509.568H148.48c-3.2 0-5.888 2.56-5.888 5.888 0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888zM205.44 562.176l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.376 6.784 4.736l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784s-3.584-5.248-6.784-4.736zM217.856 613.376l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 3.072 4.48 4.608 7.552 3.456l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456zM238.976 661.504l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.816 5.248 3.712 8.064 2.176l46.336-26.752c2.816-1.664 3.712-5.248 2.176-8.064-1.664-2.816-5.248-3.712-8.064-2.176zM268.16 705.408l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.432 5.76 2.816 8.192 0.768l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-1.92-2.56-5.632-2.816-8.192-0.768zM304.512 743.424l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.304-1.92-6.016-1.664-8.192 0.768zM347.008 774.656l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.664 6.4 0.64 8.064-2.176l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.536-6.4-0.64-8.064 2.176zM394.24 798.08l-18.304 50.304c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.152 6.4-0.512 7.552-3.456l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.528 0.384-7.552 3.456zM440.192 872.32c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.64 3.2 1.536 6.272 4.736 6.784zM502.912 878.08c3.2 0 5.888-2.56 5.888-5.888v-53.504c0-3.2-2.56-5.888-5.888-5.888-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.688 5.888 5.888 5.888zM549.632 815.232l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736-3.2 0.512-5.248 3.584-4.736 6.784zM600.832 802.816l18.304 50.304c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552L611.84 798.72c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552zM649.088 781.696l26.752 46.336c1.664 2.816 5.248 3.712 8.064 2.176 2.816-1.664 3.712-5.248 2.176-8.064l-26.88-46.336c-1.664-2.816-5.248-3.712-8.064-2.176-2.816 1.664-3.712 5.248-2.048 8.064zM692.864 752.384l34.432 40.96c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.56 2.048-2.816 5.76-0.768 8.192zM730.88 716.032l40.96 34.432c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-1.92 2.432-1.664 6.144 0.768 8.192zM762.112 673.664l46.336 26.752c2.816 1.664 6.4 0.64 8.064-2.176 1.664-2.816 0.64-6.4-2.176-7.936L768 663.552c-2.816-1.664-6.4-0.64-8.064 2.176-1.536 2.688-0.64 6.272 2.176 7.936zM785.536 626.432l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM800.256 575.872l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784zM800.256 517.76c0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888h-53.504c-3.328 0-5.888 2.56-5.888 5.888zM802.688 471.04l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784-0.512-3.2-3.584-5.376-6.784-4.736l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.248 6.784 4.736zM790.272 419.84l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 2.944 4.48 4.608 7.552 3.456zM769.152 371.584l46.336-26.752c2.816-1.664 3.712-5.248 2.176-7.936-1.664-2.816-5.248-3.712-8.064-2.176l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.688 5.248 3.712 8.064 2.048zM739.84 327.808l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-2.048-2.432-5.76-2.816-8.192-0.768l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.56 5.76 2.816 8.192 0.768zM703.488 289.664l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.432-2.048-6.144-1.792-8.192 0.768l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768zM661.12 258.56l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.664-6.4-0.64-8.064 2.176l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.536 6.4 0.64 8.064-2.176zM613.888 235.136l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.4 0.512-7.552 3.456L602.88 231.168c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.024 6.4-0.512 7.552-3.584zM556.544 225.152c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.512 3.2 1.536 6.144 4.736 6.784zM273.536 290.432c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96l21.12 21.12zM237.824 333.824c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536s-1.28 6.912 1.536 8.832l24.448 17.152zM183.04 370.176l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 7.04 3.072 8.448zM194.688 423.68l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.152 6.912 4.48 7.808l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808zM183.168 478.72l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.456 2.304 6.656 5.76 6.912l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.384-3.456-2.176-6.528-5.76-6.912zM181.504 535.04l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.456 6.144 6.912 5.76l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.328-6.016-6.912-5.76zM191.36 590.72l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.352 5.376 7.808 4.48l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.328-4.352-5.376-7.808-4.48zM207.232 644.224l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.2 5.248 4.608 8.448 3.072l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.408-3.2-5.248-4.48-8.448-3.072zM233.984 693.888l-24.448 17.152c-2.944 2.048-3.584 6.016-1.536 8.832 2.048 2.944 6.016 3.584 8.832 1.536l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536zM310.912 775.552L293.76 800c-2.048 2.944-1.28 6.912 1.536 8.832 2.944 2.048 6.912 1.28 8.832-1.536l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.816-2.048-6.912-1.408-8.832 1.536zM349.184 840.704c3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.536-3.2 0.128-7.04-3.072-8.448-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.408 3.2-0.128 6.912 3.072 8.448zM407.808 862.72c3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c0.896-3.456-1.152-6.912-4.48-7.808-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.328 1.152 6.912 4.48 7.808zM469.376 874.112c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.584 2.304 6.656 5.76 6.912zM522.496 839.168l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.456-6.144-6.912-5.76-3.456 0.256-6.016 3.328-5.76 6.912zM578.176 830.976l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928c-0.896-3.456-4.352-5.376-7.808-4.48-3.328 0.896-5.376 4.48-4.48 7.808zM631.68 813.312l12.672 27.136c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.248 3.072-8.448l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.48 5.248-3.072 8.448zM681.344 786.688l17.152 24.448c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 1.92-3.584 5.888-1.536 8.832zM725.504 751.744l21.12 21.12c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96zM763.008 709.76l24.448 17.152c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536-2.048 2.816-1.408 6.784 1.536 8.832zM792.576 661.888l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 6.912 3.072 8.448zM813.44 609.536l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.024 6.912 4.48 7.808zM824.832 554.368l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.256-3.456-2.304-6.656-5.76-6.912l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.584 2.304 6.656 5.76 6.912zM826.624 498.176l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.456-6.144-6.912-5.76l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.328 6.016 6.912 5.76zM818.432 442.368l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.456-4.352-5.376-7.808-4.48l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.48 5.376 7.808 4.48zM800.768 388.992l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.536-3.2-5.248-4.608-8.448-3.072l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.072 5.248 4.48 8.448 3.072zM774.144 339.328l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536L766.848 328.96c-2.944 2.048-3.584 6.016-1.536 8.832 1.92 2.816 5.888 3.584 8.832 1.536zM697.216 257.664l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.944-2.048-6.912-1.28-8.832 1.536l-17.152 24.448c-2.048 2.944-1.28 6.912 1.536 8.832 2.816 2.048 6.784 1.408 8.832-1.536zM658.944 192.512c-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.536 3.2-0.128 7.04 3.072 8.448 3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.408-3.2 0-7.04-3.072-8.448zM600.192 170.496c-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.456 1.152 6.912 4.48 7.808 3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c1.024-3.328-1.024-6.912-4.48-7.808zM534.912 201.6c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.456 2.304 6.528 5.76 6.912zM476.032 158.464c-3.456 0.256-6.144 3.456-5.76 6.912l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.328-6.016-6.912-5.76zM422.144 173.312c-0.896-3.456-4.352-5.376-7.808-4.48-3.456 0.896-5.376 4.352-4.48 7.808l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928zM376.448 219.776l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.608 5.248-3.072 8.448L364.8 225.28c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.376 3.2-8.576zM316.416 253.824c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 2.048-3.584 6.016-1.536 8.832l17.152 24.448z" fill="#FFFFFF" p-id="19071"/></svg></div><div class="link_content"><div class="link_title">[图形学笔记]推导投影矩阵</div></div></a>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（2）-光栅化</title>
      <link href="/posts/31310.html"/>
      <url>/posts/31310.html</url>
      
        <content type="html"><![CDATA[<p>屏幕是一个二维数组的标准数据集，是离散的，是一个典型的光栅成像设备</p><h1 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h1><p>光栅化即把图像呈现在屏幕上的过程</p><p><strong>像素</strong>是“最小的”图像单元，一个像素内的颜色，由r，g，b三个参数控制</p><p>由裁剪空间映射到屏幕空间（视口变换）公式如下：</p><script type="math/tex; mode=display">M_{viewport}=\left[\begin{matrix}\frac{width}{2}    &    0    &    0    &    \frac{width}{2}\\0    &    \frac{height}{2}    &    0    &    \frac{height}{2}\\0    &    0    &    1    &    0\\0    &    0    &    0    &    1\\\end{matrix}\right]\\</script><p>经过矩阵变换后，再把屏幕空间中的多边形打散成三角形，成像到屏幕上，这就是光栅化的大致流程</p><p>计算机生成图像中，最基本的二维元素是三角形</p><p>三角形的特质：① 保证是平面；内外定义清晰；    ② 具有成熟的顶点插值方法</p><h1 id="不同的光栅化设备"><a href="#不同的光栅化设备" class="headerlink" title="不同的光栅化设备"></a>不同的光栅化设备</h1><p><strong>示波器oscilloscope</strong></p><p><strong>CRT屏幕：</strong></p><p>早期成像原理：阴极射线管</p><p>早期电视：光栅化的CRT屏幕，隔行扫描技术</p><p><strong>当今成像设备：平板显示设备</strong></p><p><strong>LCD液晶显示器：</strong>液晶会通过自己的不同排布，影响光的极化</p><p><strong>LED显示器：</strong>发光二极管点阵列</p><p><strong>电子水墨屏：</strong>电泳成像，刷新频率低</p><p><strong>OLED显示器：</strong>有机发光半导体</p><h1 id="最简单的光栅化方法：采样"><a href="#最简单的光栅化方法：采样" class="headerlink" title="最简单的光栅化方法：采样"></a>最简单的光栅化方法：采样</h1><p>采样，就是把函数离散化的一个过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; imax; i++)</span><br><span class="line">output[i] = f(i);</span><br></pre></td></tr></table></figure><p>为判断该为哪块像素着色，我们定义一个二进制函数：inside(tri,x,y)</p><script type="math/tex; mode=display">inside(tri,x,y)=\left\{\begin {array}{rcl}1&point(x,y)\ in\ △t\\2&otherwise\end {array}\right.</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; imax; i++)&#123;</span><br><span class="line">for(int j = 0; j &lt; jmax; j++)&#123;</span><br><span class="line">image[i][j] = inside(tri, i+0.5, j+0.5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="采样优化"><a href="#采样优化" class="headerlink" title="采样优化"></a>采样优化</h1><p>Axis-Aligned Bounding Box：包围盒</p><p>在光栅化前先行判断像素点是否在三角形所在包围盒内，若不在，则直接忽略，不进光栅化的循环判断</p><p>Incremental Triangle Traversal：增量三角形遍历</p><p>看似更快，实则实现起来有一定难度，适用于细长的三角形</p><p>采样率不够高 -&gt; 锯齿，走样</p><h1 id="抗锯齿与深度缓冲"><a href="#抗锯齿与深度缓冲" class="headerlink" title="抗锯齿与深度缓冲"></a>抗锯齿与深度缓冲</h1><h2 id="采样伪影"><a href="#采样伪影" class="headerlink" title="采样伪影"></a>采样伪影</h2><p>锯齿（空间采样上的错误）</p><p>摩尔纹（如，采样时跳过奇数行奇数列）</p><p>马车轮效应：人眼在时间上的采样跟不上运动速度</p><p>采样伪影的原因：信号频率太快，采样速度跟不上</p><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p>傅里叶级数展开：任何一个周期函数，都可以表示为一系列sin和cos函数的线性组合加一个常数项的形式</p><p><img src="/posts/31310/-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\傅里叶级数变换.png" alt="傅里叶级数变换"></p><p>傅里叶变换，与傅里叶级数展开关系并不大，可以把图像从时域（空间域）变换到频域</p><p><em>用信号处理解释走样：同样一种采样方法，采样两种不同频率的函数，得出的结果无法被区分</em></p><h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><p>在频域内去除某一特定频率的函数</p><p>高通滤波器，低通滤波器，具体处理过程：</p><p><a href="https://zhuanlan.zhihu.com/p/365546998?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888">https://zhuanlan.zhihu.com/p/365546998?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888</a></p><p>滤波=平均=卷积</p><p>卷积核越大，保留的高频信息越少，低频信息越多，对应到频域图上，高频区域的亮度就降低</p><h2 id="走样的本质"><a href="#走样的本质" class="headerlink" title="走样的本质"></a>走样的本质</h2><div class="table-container"><table><thead><tr><th>采样的本质</th><th>走样的本质</th></tr></thead><tbody><tr><td><img src="/posts/31310/-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\采样的本质.png" alt="采样的本质"></td><td><img src="/posts/31310/-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\走样的本质.png" alt="走样的本质"></td></tr></tbody></table></div><p>采样率变低，采样间隔变大，波长变大，频率变小</p><p>Dense sampling==稠密采样==，图中信号已经首尾相接，意味着当前的采样频率Fs是不发生走样的最低限值</p><p>Sparse sampling==稀疏采样==，意味着频率Fs变大，间隔变小，就会产生混叠（近视也是因为这种混叠，可以类比一下）</p><p>所以，像素越低，采样率越低，采样频率越小，采样越稀疏，更容易走样</p><h2 id="反走样技术思路"><a href="#反走样技术思路" class="headerlink" title="反走样技术思路"></a>反走样技术思路</h2><p>1、增加屏幕分辨率，增加采样频率（成本高）</p><p>2、在采样之前，进行模糊（/滤波）处理，<u>（注意，先模糊处理在采样，反过来是不可行的）</u>，模糊以后，将图像的边界弱化了，采样的时候，该区域对应的像素值可以起到过度缓冲的效果（低通滤波降低信号最高频率，使得可以用更低的采样频率完成采样）</p><p><img src="/posts/31310/-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\低通滤波反走样.png" alt="低通滤波反走样"></p><p>先采样后模糊之所以不可行，就是因为波形重叠的情况下截断依然会有重叠</p><p>通过像素做平均（卷积）来达到反走样：</p><p><img src="/posts/31310/-STUDY-\college\闫令琪_图形学入门\101\图片\p6-抗锯齿\像素低通滤波.png" alt="像素低通滤波"></p><p>如何计算图形在某一像素内覆盖的比例？</p><p>一种近似方法：==MSAA==（muti-sample anti-aliasing）</p><p>每个像素多次采样，求平均，像素的颜色值为负责的区域内取样多次颜色值的平均</p><p>MSAA并没有通过物理上增加分辨率达到抗锯齿效果，这些网格只是为了检测覆盖率而已，并且现实应用并非用网格，而是用一些其他图形来达到效果，涉及一些随机数分布（怎样分布样本达到最好的覆盖效果）</p><p>那么，代价是什么？太浪费性能！        优化：采样复用</p><p>3、其他抗锯齿方案</p><ul><li>==FXAA== (Fast Approximate AA)：先获得有锯齿的图，再后处理去除锯齿（很快）<ul><li>找到边界，换成没有锯齿的边界，（图像匹配）非常快</li><li>方法和采样无关，采样虽然有误，但是这种方法可以弥补</li></ul></li><li>==TAA== (Tem‘poral AA) ：时序信息，借助前面帧的信息<ul><li>最近刚刚兴起</li><li>静态场景，相邻两帧同一像素用不同的位置来sample</li><li>把MSAA的Sampling分布在时间上</li><li>运动情况下怎么办？</li></ul></li></ul><p>Super resolution / super sampling 超分辨率</p><p>低分辨率显示器还原高分辨率图片，归根结底依旧是”样本不足“，解决方案举例：DLSS (Deep Learning Super Sampling) </p><h2 id="深度缓存-Zbuffering"><a href="#深度缓存-Zbuffering" class="headerlink" title="深度缓存 -Zbuffering"></a>深度缓存 -Zbuffering</h2><p>Painter’s Algorithm：画家算法，由远及近画画，近处画面覆盖远处画面</p><p>无法处理复杂的深度判断，例如三个三角形互相重叠</p><p>深度计算排序 算法复杂度：$O(log\ n)$</p><p>==Z-buffer：对每个像素多存一个深度==</p><p>实际编程中，z值越小表示越远，但为方便理解，下述伪代码中z越远越大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(each Triangle T)</span><br><span class="line">for(each sample(x,y,z) in T)</span><br><span class="line">if(z&lt;zbuffer[x,y])</span><br><span class="line">framebuffer[x,y]=rgb;</span><br><span class="line">zbuffer[x,y]=z;</span><br><span class="line">else</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>复杂度：O(n) for n triangles 并不是排序，而是求最值，需要保证三角形进入顺序和结果无关</p><p>tips：无法处理透明物体，详情参考《入门精要》第八章</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（3）-光照、着色、图形管线</title>
      <link href="/posts/11171.html"/>
      <url>/posts/11171.html</url>
      
        <content type="html"><![CDATA[<h3 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h3><h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>要知道物体表面多亮，就要知道从光源到物体表面发射的能量光是多少，单位的能量光在单位球上的能量表示为 I，同一个点上的能量随着光不断向外传播而逐渐减少， 根据能量守恒定律，每一个球面上的总能量都是相同的（这在之后辐射度量学会有补充）</p><p><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\漫反射phone模型推导.png" alt="漫反射phone模型推导"></p><p>由此可以得到关系式：</p><script type="math/tex; mode=display">1^24πI=r^24πI'</script><p>再计算物体表面着色点反射多少能量光给摄像机接收</p><p>用一个系数$K_d$表示该着色点的光吸收率，范围是$[0,1]$，如果该系数是 0，证明该着色点完全吸收能量，反之，如果是 1，代表该点完全不吸收能量</p><p><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\漫反射phone模型.png" alt="漫反射phone模型"></p><p>把这个系数看作是==RGB颜色值==，当$K_d=0$时，此时对应着RGB值是：[0, 0, 0]，在计算机里表示为黑色，黑色正是完全吸收光的颜色，反之，当$K_d=1$时，对应着 [255, 255, 255]，在计算机里表示为白色，白色正是完全反射光的颜色</p><p>最终公式为公式：</p><script type="math/tex; mode=display">L_d=k_d(\frac{I}{r^2})max(0,n·l)</script><h4 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h4><p><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\镜面反射phone模型.png" alt="镜面反射phone模型"></p><p> $h$ 为 $l$ 和 $v$ 的半程向量， $n$ 为法线向量， $v$ 为观测角度，</p><p>假设前提：观测向量 $v$ 与镜面反射向量 $R$ 的夹角 与  $n$ 和 $h$ 的夹角相等( $R$ 在图中未标明）</p><p>why：计算机计算 $v$ 与 $R$ 的角度非常麻烦，考虑到大量像素的性能开销，因此使用较简单的半程向量进行计算</p><div class="table-container"><table><thead><tr><th><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\指数p的作用.png" alt="指数p的作用"></th><th><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\对比图.png" alt="对比图"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>左图：指数p是为了进一步缩小高光范围所提供的的参数，通常取值大于100</p><p>右图：不同光照强度和p的取值对高光效果的影响</p><h4 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h4><p>Blinn-Phone光照模型中，假设从四面八方反射而来的光的光强都是相等的，也就是说可以认为环境光强为一个常数（实际上全局光照的计算要复杂的多），公式为$L_a=K_aI_a$</p><h4 id="叠加效果"><a href="#叠加效果" class="headerlink" title="叠加效果"></a>叠加效果</h4><p><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\三种光照的叠加效果.png" alt="三种光照的叠加效果"></p><h3 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h3><h4 id="Flat-Shading（平面着色）"><a href="#Flat-Shading（平面着色）" class="headerlink" title="Flat Shading（平面着色）"></a>Flat Shading（平面着色）</h4><p>以三角面为单位进行着色，对于光滑的几何体效果很差</p><h4 id="Gouraud-Shading（高洛德着色）"><a href="#Gouraud-Shading（高洛德着色）" class="headerlink" title="Gouraud Shading（高洛德着色）"></a>Gouraud Shading（高洛德着色）</h4><p>以顶点为单位进行着色，通过插值计算，实现点与点之间颜色的平滑过渡</p><h4 id="Phone-Shading（冯氏着色）"><a href="#Phone-Shading（冯氏着色）" class="headerlink" title="Phone Shading（冯氏着色）"></a>Phone Shading（冯氏着色）</h4><p>以片元为单位进行着色，对每个点计算一次光照，点的法向量是通过顶点法向量插值得到的，冯氏着色最接近现实，可以在减少三角面数的情况下达到相同的效果（插值后法向量会光滑变化），当然，性能开销也非常大</p><h3 id="图形管线（实时渲染管线）"><a href="#图形管线（实时渲染管线）" class="headerlink" title="图形管线（实时渲染管线）"></a>图形管线（实时渲染管线）</h3><p><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p8-shading\图形管线.png" alt="图形管线"></p><p>顶点处理 -&gt; 三角形处理 -&gt; 光栅化 -&gt; 片元处理 -&gt; 逐片元操作</p><p>其中，Vertex和Fragment阶段是可编程的</p><p>由于翻译问题，具体可以参考《unity shader入门精要》p9 内容</p><p><strong>GPUs：</strong>可并行的图形管线处理器</p><p>当下的图形实时处理技术可以实时的处理200-400万面的复杂场景数据，并以30-60的帧率动态处理（VR的帧率会更加夸张）</p><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><h4 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h4><p>想要在三维物体的不同表面生成不同的纹理，就需要将三维图形的表面映射至二维表面（展UV）</p><p>三维图形的每个三角面顶点都可以对应一个uv坐标系下的坐标，uv坐标范围约定在$[0,1]$之间</p><p>可复用纹理：纹理本身可以被设计为无缝衔接（tilable）,Wang-Tiling是其中一种方法</p><h4 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h4><p>注意和重心概念的区别！对于三角形所在平面上的任意一点的坐标，都可以用三角形的三个顶点坐标的线性表达式表示</p><script type="math/tex; mode=display">(x,y)=\alpha A+\beta B+\gamma C</script><p>则$(\alpha,\beta,\gamma)$被称为该点的重心坐标，定理：$\alpha+\beta+\gamma=1$</p><p>对于三角形内的点，$\alpha,\beta,\gamma&gt;0$，更特殊的情况，三角形==重心的重心坐标==为$(\frac{1}{3},\frac{1}{3},\frac{1}{3})$</p><p>求$\alpha,\beta,\gamma$公式：</p><script type="math/tex; mode=display">\alpha = \frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}              {-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)}\\\beta = \frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}              {-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)}\\\gamma = 1-\alpha -\beta</script><p>推导：<a href="https://blog.csdn.net/wangjiangrong/article/details/115326930">https://blog.csdn.net/wangjiangrong/article/details/115326930</a></p><p>几何意义：$(x,y)$与三角形的三个顶点构成三个三角形，顶点==所对==的三角形的面积与三角形总面积的比值，即为对应的重心坐标值</p><p>利用重心坐标实现线性插值：</p><p><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p9-shading\重心坐标插值.png" alt="重心坐标插值"></p><p>注意，==重心坐标在映射过程中并非保持不变==，所以需要在对应时间计算对应的重心坐标来做插值，不能随意复用！</p><p>映射过程伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach rasterized screen sample(x,y) //通常来说是一个像素的中心</span><br><span class="line">(u,v) = evaluate texture coordinate at (x,y) //用重心坐标插值</span><br><span class="line">texcolor = texture,sample(u,v);</span><br><span class="line">set sample&#x27;s color to texture; //作为漫反射系数</span><br></pre></td></tr></table></figure><h4 id="纹理过小-or-纹理过大？"><a href="#纹理过小-or-纹理过大？" class="headerlink" title="纹理过小 or. 纹理过大？"></a>纹理过小 or. 纹理过大？</h4><h5 id="纹理太小"><a href="#纹理太小" class="headerlink" title="纹理太小"></a>纹理太小</h5><p>可以理解为多个pixel映射到了同一个texel</p><p>解决方案：</p><p>1、水平+竖直做两次插值，即==双线性插值== Lerp</p><p>2、对周围16个点做三次插值，==双三次插值== Bicubic，运算量更大，结果更好</p><h5 id="纹理太大"><a href="#纹理太大" class="headerlink" title="纹理太大"></a>纹理太大</h5><p>可以理解为一个pixel对应了多个纹素，因采样频率不足而导致摩尔纹+锯齿（走样）</p><p>解决方案：</p><p>Supersampling多重采样，性能开销过大，所以干脆舍弃超级采样的思路</p><p>==Mipmap算法：==</p><p>事先准备多张不同级别（D）的纹理贴图，每升一个级别，横纵纹素各减小一半，最后显存消耗仅为原来的$\frac{4}{3}$，如此分级之后，设屏幕空间下采样像素与相邻像素中心点之间的距离为L，在u-v坐标系找到这些像素的中心点对应的坐标，求出L在u-v坐标系下对应的纹素数量，做对数运算求得对应像素的纹理细节的级别，再以对应级别做==双线性插值==</p><p>由于这种方法中，D是整数，而并非连续的值，为了得到连续的效果，在做对数运算后对小数部分算一下权重，并取向下取整的D值与D+1两个级别，对着两个级别分别做一次双线性插值，最后对插值结果再进行一次插值，我们称这种方法为==三线性插值==</p><div class="table-container"><table><thead><tr><th><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p9-shading\求L.png" alt="求L"></th><th><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p9-shading\三线性插值.png" alt="三线性插值"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><strong>MipMap算法的局限</strong>：只能在u-v坐标系下做方块查询，有时候会造成过度模糊的情况</p><p>为了避免这种情况，引入==各向异性过滤==，在准备不同级别的纹理贴图时，不再是简简单单横纵纹素各减小一半进行分级，而是长减半宽不变 or 宽减半长不变 or 长和宽各减半三种情况各进行一次分级，显存消耗为原来的三倍，但性能方面并没有多少影响，这种方法就可以实现在u-v坐标系下进行矩形查询。</p><p>比各向异性更进一步的过滤，如EWA filtering 椭圆取样，则利用多次查询求平均值的方法来处理不规则区域，相应的性能开销就会比较大了</p><p>由上可知，在显存足够的情况下，各向异性过滤级别开越高越好</p><p>这块内容显然特别抽象，具体细节可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/144332091?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888">https://zhuanlan.zhihu.com/p/144332091?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888</a></p><h4 id="各种纹理贴图"><a href="#各种纹理贴图" class="headerlink" title="各种纹理贴图"></a>各种纹理贴图</h4><h5 id="环境光贴图"><a href="#环境光贴图" class="headerlink" title="环境光贴图"></a>环境光贴图</h5><p>假设光源无限远，只记录光照的方向信息，这种贴图被称作环境光贴图</p><p>e.g. Utah Teaport 犹他茶壶；Stanford Bunny 斯坦福兔子</p><ul><li><p>球面环境映射 Spherical Environment Map</p><p>球心为世界中心。类比地球仪展开铺平，存在纹理的拉升扭曲问题，解决方法：Cube Map</p></li><li><p>立方体贴图 Cube Map</p><p>将环境光照信息记录在一个立方体表面上，但会需要额外判断某一方向上的光照应该记录在立方体的哪个面上，计算量更大</p></li></ul><h5 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h5><p>记录了纹理的高度移动，并不改变原来模型的几何信息，通过法线扰动，得到模拟出来的着色效果，以假乱真</p><p><strong>计算法线的方法：</strong></p><div class="table-container"><table><thead><tr><th><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\计算法线方向1.png" alt="计算法线方向1"></th><th><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\计算法线方向2.png" alt="计算法线方向2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><strong>UV下的法线算法：</strong></p><p><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\UV下的法线算法.png" alt="UV下的法线算法"></p><p>局部坐标下，$n=(-\frac{dp}{du},-\frac{dp}{dv},1).normalized$</p><h5 id="置换贴图"><a href="#置换贴图" class="headerlink" title="置换贴图"></a>置换贴图</h5><p>与凹凸贴图类似，但置换贴图是真的改变了几何信息，去对模型的顶点做位移，会比凹凸贴图更加逼真，但对模型的精度（三角面数量）要求更高，并且运算量也会随之上升</p><p>DirectX有Dynamic的插值法，根据需要对模型做插值，看情况决定模型的细致程度</p><p>凹凸贴图vs.置换贴图：</p><p><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\凹凸贴图vs.位移贴图.png" alt="凹凸贴图vs.位移贴图"></p><h5 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h5><p>三维的纹理，并非真正生成了纹理的图，而是定义空间中任意点的颜色</p><p>定义三维空间中的噪声函数，再通过映射，得到预想的效果</p><h5 id="预计算着色"><a href="#预计算着色" class="headerlink" title="预计算着色"></a>预计算着色</h5><p>将环境光进行预计算处理，再附在原先纹理上做一层遮蔽，再将纹理贴到模型上</p><h5 id="三维渲染"><a href="#三维渲染" class="headerlink" title="三维渲染"></a>三维渲染</h5><p>Solid Modeling &amp;. Volume Rendering</p><p>广泛应用于物体渲染，如核磁共振等扫描后得到的体积信息，通过这些信息进行渲染，得到结果</p><div class="table-container"><table><thead><tr><th>程序纹理</th><th>预计算着色</th><th>三维渲染</th></tr></thead><tbody><tr><td><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\程序纹理.png" alt="程序纹理"></td><td><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\预计算着色.png" alt="预计算着色"></td><td><img src="/posts/11171/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\三维渲染.png" alt="三维渲染"></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（4）-几何</title>
      <link href="/posts/23425.html"/>
      <url>/posts/23425.html</url>
      
        <content type="html"><![CDATA[<h2 id="五、几何"><a href="#五、几何" class="headerlink" title="五、几何"></a>五、几何</h2><h3 id="几何的表达方式"><a href="#几何的表达方式" class="headerlink" title="几何的表达方式"></a>几何的表达方式</h3><h4 id="隐式几何"><a href="#隐式几何" class="headerlink" title="隐式几何"></a>隐式几何</h4><p>用空间中的满足一定条件的点的集合来表示面，隐式几何不会表示点的具体位置信息，而是告诉我们这些点满足的函数关系</p><p>我们很难看出隐式想表达的形状是什么，但对于判断点的位置关系（在内，在外还是在表面）会很方便</p><ul><li><p><strong>代数曲面</strong></p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\代数几何.png" alt="代数几何"></p></li><li><p><strong>CSG构造实体几何</strong></p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\CSG构造实体几何.png" alt="CSG构造实体几何"></p></li><li><p><strong>※ 距离函数</strong></p><p>对于任意一个几何，不直接描述其表面，而是描述空间中任意一点到这个表面的距离，如此一来空间中所有点都会被定义出一个距离值，把距离函数做出来，在做个belnding就可以达到融合效果</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\距离函数2.png" alt="距离函数2"></p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\距离函数1.png" alt="距离函数1"></p><p>距离函数应用：SDF</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\SDF.png" alt="SDF"></p><p>得到距离函数后，函数值为0的地方就是表面。类似的，水平集也用了同样的思想，在地理上类似定义是等高线，用等高线的思想确定表面位置</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\水平集.png" alt="水平集"></p><p>水平集应用：CT扫描</p></li><li><p><strong>分形几何</strong></p><p>自相似，递归，很难控制形状</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p10-几何1\分形几何.png" alt="分形几何"></p></li></ul><h4 id="显式几何"><a href="#显式几何" class="headerlink" title="显式几何"></a>显式几何</h4><p>直接给出点的位置，或者可以进行参数映射；然而想要判断内外时，显式的表达就很难进行表示</p><p><strong>点云</strong></p><p>用空间中一堆点的集合来表示物体，只要点足够密集，就看不到点与点之间的空隙，理论上可以表示任何几何，通常三维扫描得到的结果就是点云（点云可以转变为三角形）</p><p><strong>多边形网格</strong></p><p>或许是目前最为广为流传的三维几何表达方式</p><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p>德卡斯特里奥（de Casteljau）算法  生成<u>二次贝塞尔曲线</u></p><p>定义三个点 -&gt; 根据任意的 t 插值出点 -&gt; 不断重复 t在[0,1]间不断取值 -&gt; 得到曲线</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线 (3" alt="贝塞尔曲线 (3)">.png)</p><p><u>二次贝塞尔曲线</u>：<strong>递归</strong></p><div class="table-container"><table><thead><tr><th><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线 (2" alt="贝塞尔曲线 (2)">.png)</th><th><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线 (1" alt="贝塞尔曲线 (1)">.png)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h4 id="贝塞尔曲线的代数表示"><a href="#贝塞尔曲线的代数表示" class="headerlink" title="贝塞尔曲线的代数表示"></a>贝塞尔曲线的代数表示</h4><p>在每两个之间找一个时间t，相当于每两个之间线性插值</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线的代数表示 (2" alt="贝塞尔曲线的代数表示 (2)">.png)</p><p>把算法过程写成代数的形式（如图）</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线的代数表示 (4" alt="贝塞尔曲线的代数表示 (4)">.png)</p><p>推广到n阶，不难发现这其实是一个符合二项分布的多项式</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线的代数表示 (1" alt="贝塞尔曲线的代数表示 (1)">.png)</p><p>三次贝塞尔曲线的代数表示：</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲线的代数表示 (3" alt="贝塞尔曲线的代数表示 (3)">.png)</p><h4 id="贝塞尔曲线的性质"><a href="#贝塞尔曲线的性质" class="headerlink" title="贝塞尔曲线的性质"></a>贝塞尔曲线的性质</h4><ul><li>对称性：第 $i$ 项系数和倒数第 $i$ 项系数相同</li><li>必过起点终点，起始切线方向为前两个点连接的方向，终止切线方向为结尾两个点连接的方向</li><li>在仿射变换下，只需要对顶点做仿射变换，就能得到这个贝塞尔曲线在仿射变换下的结果</li><li>凸包性质：贝塞尔曲线始终会在<strong>包含了所有控制点的最小凸多边形</strong>中, 而不是按照控制点的顺序围成的最小多边形</li></ul><h4 id="逐段贝塞尔曲线"><a href="#逐段贝塞尔曲线" class="headerlink" title="逐段贝塞尔曲线"></a>逐段贝塞尔曲线</h4><p>控制点多了以后，贝塞尔曲线并不直观，很难控制，于是我们想到可以每次定义一段贝塞尔曲线，然后连起来</p><p>普遍习惯每四个控制点定义一段，并略去中间两点间的连线</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\逐段贝塞尔曲线.png" alt="逐段贝塞尔曲线"></p><h4 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h4><div class="table-container"><table><thead><tr><th>$C_0$连续：点相同</th><th>$C_1$连续：切线相同</th></tr></thead><tbody><tr><td><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\c0连续.png" alt="c0连续"></td><td><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\c1连续.png" alt="c1连续"></td></tr></tbody></table></div><h4 id="样条曲线"><a href="#样条曲线" class="headerlink" title="样条曲线"></a>样条曲线</h4><p><strong>样条</strong>：连续的曲线，由一系列控制点控制，满足一定的连续性，即可控的曲线</p><p><strong>B样条曲线</strong>有关信息可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/50626506">https://zhuanlan.zhihu.com/p/50626506</a></p><p><a href="https://www.bilibili.com/video/BV13441127CH?p=13">https://www.bilibili.com/video/BV13441127CH?p=13</a> 胡事民老师的课</p><h3 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h3><h4 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h4><p>u方向上画出四条贝塞尔曲线后，在这四个线上再取四个点，并认为这是个点是一组新的贝塞尔曲线的控制点，这些点在空间内向v方向扫描，便形成了贝塞尔曲面</p><p><img src="/posts/23425/-STUDY-\college\闫令琪_图形学入门\101\图片\p11-几何2\贝塞尔曲面.gif" alt="贝塞尔曲面"></p><h3 id="几何处理"><a href="#几何处理" class="headerlink" title="几何处理"></a>几何处理</h3><h4 id="曲面细分"><a href="#曲面细分" class="headerlink" title="曲面细分"></a>曲面细分</h4><h5 id="Loop细分（涡轮平滑）"><a href="#Loop细分（涡轮平滑）" class="headerlink" title="Loop细分（涡轮平滑）"></a>Loop细分（涡轮平滑）</h5><p>连接各边中点，并重新改变各个顶点位置，从而创造出更多三角形面，使得表面更加光滑（命名并不是因为算法与循环有关，而是该算法创始人的名字叫loop）</p><p><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/loop%E7%BB%86%E5%88%86.png" alt="loop细分"></p><p>该算法规定，一般情况下（不考虑边缘情况），对于新顶点，位置由下左图规定，而对于旧顶点，需要由旧顶点和新顶点位置共同确定</p><p>下右图中，n为该顶点的度（依附于某个顶点的边的条数），u为一个和n有关的数</p><div class="table-container"><table><thead><tr><th>新顶点</th><th>旧顶点</th></tr></thead><tbody><tr><td><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/loop%E7%BB%86%E5%88%86%E6%96%B0%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE.png" alt="loop细分新顶点位置"></td><td><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/loop%E7%BB%86%E5%88%86%E6%97%A7%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E8%B0%83%E6%95%B4.png" alt="loop细分旧顶点位置调整"></td></tr></tbody></table></div><h5 id="Catmull-Clark-细分"><a href="#Catmull-Clark-细分" class="headerlink" title="Catmull-Clark 细分"></a>Catmull-Clark 细分</h5><p>loop细分有一个前提，即只适用于三角形网格，而对于非三角形网格的细分，就需要借助catmull-clark算法</p><p>该算法定义面分为两种——四边面和非四边面，并定义度为4的顶点为非奇异点，其余点均为奇异点</p><p><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/catmull%EF%BC%881%EF%BC%89.png" alt="catmull（1）"></p><p>具体做法是，对每个非四边面都取其中的一个点（重心或者其他点），将其与该面的其他顶点分别连接，在这个过程中，会引入一个新的奇异点，并且在一次细分后，所有非四边面都变为了四边面，在后续的细分中，将不会引入新的奇异点</p><div class="table-container"><table><thead><tr><th><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/catmull%EF%BC%882%EF%BC%89.png" alt="catmull（2）"></th><th><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/catmull%EF%BC%883%EF%BC%89.png" alt="catmull（3）"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>对于细分后顶点位置的调整，先将顶点分为三大类</p><p>①新的在面上的点；②新的在边上的点；③旧的点</p><p>如下计算：</p><p><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/catmull%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E8%B0%83%E6%95%B4.png" alt="catmull顶点位置调整"></p><p>loop细分与catmull-clark细分不同的处理效果：</p><p><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/loop%E4%B8%8Ecatmull%E5%AF%B9%E6%AF%94.png" alt="loop与catmull对比"></p><p>具体推导过程可以参考：</p><p><a href="https://blog.csdn.net/McQueen_LT/article/details/106102609">https://blog.csdn.net/McQueen_LT/article/details/106102609</a></p><h4 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h4><h5 id="边坍缩"><a href="#边坍缩" class="headerlink" title="边坍缩"></a>边坍缩</h5><p>如何保证坍缩前后轮廓基本保持一致？    ——二次误差</p><p>二次误差度量：坍缩后的点和原本几个边（面）的距离的平方和最小</p><div class="table-container"><table><thead><tr><th><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%BA%8C%E6%AC%A1%E8%AF%AF%E5%B7%AE%E5%BA%A6%E9%87%8F.png" alt="二次误差度量"></th><th><img src="/posts/23425/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p12-%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86/%E4%BA%8C%E6%AC%A1%E8%AF%AF%E5%B7%AE%E5%BA%A6%E9%87%8F2.png" alt="二次误差度量2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>对每一条边都先计算一下二次误差，随后从二次误差最小的开始坍缩，由小到大</p><p>但这么做会引入一些问题：做一次坍缩后，其他边也跟着变了，他们的二次误差必须被重新计算</p><p>所以需要从二次度量误差中选最小的，取完最小的之后，我们要对它们的二次误差做一次更新，于是我们就要用到==优先队列 / 堆==这种数据结构，这种数据结构能让我们能取得二次误差最小值的同时也能动态更新其他受影响的元素</p><p>另外，这种通过对局部计算最优解，试图找到全局的最优解，是一个典型的贪心算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（5）-光线追踪</title>
      <link href="/posts/8491.html"/>
      <url>/posts/8491.html</url>
      
        <content type="html"><![CDATA[<h2 id="六、光线追踪"><a href="#六、光线追踪" class="headerlink" title="六、光线追踪"></a>六、光线追踪</h2><p>光栅化的着色是一种局部的现象，在其着色的过程中只会考虑着色点自己的信息，而不会考虑其他物体，甚至不会考虑物资自身的其他部分对着色点的影响。事实上这些都是会有遮挡的关系的，是会产生阴影的，为了解决这个问题，就有了光线追踪</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="Shadow-Mapping-阴影贴图"><a href="#Shadow-Mapping-阴影贴图" class="headerlink" title="Shadow Mapping 阴影贴图"></a>Shadow Mapping 阴影贴图</h4><p>核心思想：如果一个点不在阴影里，那么这个点可以被摄像机和光源都看到</p><p>局限：硬阴影，走样，只能处理点光源</p><p>具体实现细节：</p><p>① 先从光源看向场景，做一遍光栅化，不进行着色，只记录深度</p><p>② 再从摄像机看向场景，再做一遍光栅化，记录深度</p><p>③ 比较两次深度值，如果不相等，则说明该点在阴影中</p><p><strong>问题1</strong>：渲染出来的阴影比较脏</p><p><strong>原因</strong>：深度值的比较位浮点数比较，而判断浮点数相等势必会产生误差，虽然处理精度的方法有很多种，但并不能从本质上解决问题</p><p><strong>问题2</strong>：走样</p><p><strong>原因</strong>：本身储存的深度图存在分辨率限制，与渲染时的分辨率搭配不好的话，就会产生走样</p><p><img src="/posts/8491/-STUDY-\college\闫令琪_图形学入门\101\图片\p13-光线追踪\Shadow Mapping浮点误差.png" alt="Shadow Mapping浮点误差"></p><p>关于硬软阴影：本质是本影和半影的问题，只要存在软阴影，那么光源一定具有一定的体积</p><h4 id="Why-Ray-Tracing？"><a href="#Why-Ray-Tracing？" class="headerlink" title="Why Ray-Tracing？"></a>Why Ray-Tracing？</h4><p>由上可知，光栅化并做不好全局的效果，如软阴影，反射，环境光照</p><p>光栅化很快速，但渲染的质量不高；光线追踪的处理速度慢，但渲染的很准确</p><p>光栅化很容易做到实时，而光线追踪更多的应用于离线渲染（现在的实时光线追踪，这位更是重量级！）</p><p>首先定义光线——沿直线传播，不会发生碰撞，从光源到人眼</p><p>由光路的可逆性，在光线追踪的具体应用中，采用从人眼（认为是一个针孔摄像机）到光源的方法</p><p><strong>光线投射</strong>：人眼，成像平面，光源，物体</p><p><img src="/posts/8491/-STUDY-\college\闫令琪_图形学入门\101\图片\p13-光线追踪\光线投射.png" alt="光线投射"></p><p><u>从相机出发投射一条光线</u>，穿过成像平面，与着色点相连，如果光源能看见着色点（着色点不在阴影中），那么就生成一条有效光路，计算能量并着色（我们很容易知道这个着色点的法线，入射方向等信息，这时候可以用各种各样的着色模型（如Blinn Phong））</p><p>对于场景中的物体，我们假设光打到它之后会发生完美的折射与反射，而对于着色点，我们取光路与物体最近的交点（涉及深度测试）</p><p>总的来说，光线投射其实就是每个像素投射出去一条光线，求到和场景内物体的最近交点，通过该交点和光源连线来判定是否可见，然后算着色，写回像素的值</p><p>这个方法依旧只是弹射一次，但事实上光线是能在物体间弹射很多次，这时候就需要用到whitted光线追踪</p><h3 id="Whitted（递归）风格光线追踪"><a href="#Whitted（递归）风格光线追踪" class="headerlink" title="Whitted（递归）风格光线追踪"></a>Whitted（递归）风格光线追踪</h3><p><img src="/posts/8491/-STUDY-\college\闫令琪_图形学入门\101\图片\p13-光线追踪\whitted光线追踪.png" alt="whitted光线追踪"></p><p>如果图中的球是玻璃材质，那么之前从像素投射出去的光线，除了会在玻璃球表面发生发射，还有一部分会进入玻璃球发生折射，而whitted光线追踪，除了计算第一次光线投射的着色点外，对每个弹射点也进行了着色计算（损失多少能量，颜色值等）</p><h3 id="光线与物体求交"><a href="#光线与物体求交" class="headerlink" title="光线与物体求交"></a>光线与物体求交</h3><p>无论是之前的光线投射还是whitted风格光线追踪，都涉及到光线与物体求交问题</p><p>为了研究这个问题，我们需要先定义光线</p><p>一个光线可以有一个点（光源）和一个方向（光线方向）确定，则可设光线表达式：$r(t)=O+td$</p><h4 id="和隐式表面求交"><a href="#和隐式表面求交" class="headerlink" title="和隐式表面求交"></a>和隐式表面求交</h4><p>光线在t时间后到达的着色点：$r(t)=O+td$</p><p>隐式表面：$f(p)=0$    <code>//p是着色点</code></p><p>将$r(t)$代入，$f(r(t))=f(O+td)=0$</p><p>要判断是否与隐式表面相交，只要判断上面这个方程是否有解即可</p><p><img src="/posts/8491/-STUDY-\college\闫令琪_图形学入门\101\图片\p13-光线追踪\与隐式表面求交.png" alt="与隐式表面求交"></p><h4 id="和显式表面求交"><a href="#和显式表面求交" class="headerlink" title="和显式表面求交"></a>和显式表面求交</h4><p>核心：点如果在封闭形状内，向外打一条光线，得到的交点数量一定是奇数；如果在封闭形状外，则交点数一定是偶数</p><p>那么对于显示表面求交，最简单的做法就是遍历物体的所有三角形面，求交点数量，那么问题就简化为如何判断光线与三角形面求交（这种方法很慢，之后会提到包围盒的加速算法）</p><h4 id="与三角面求交"><a href="#与三角面求交" class="headerlink" title="与三角面求交"></a>与三角面求交</h4><p>平面可以由一个点和一个法线定义，三角面也不例外，在求交问题中，设光线和三角面交点位p，p满足：$(p-p’)·N=0$</p><p>复杂的做法是，将光线方程带入三角面方程，求得交点（下图），在用向量积判断交点是否在三角面内</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p13-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/%E4%B8%8E%E6%98%BE%E5%BC%8F%E8%A1%A8%E9%9D%A2%E6%B1%82%E4%BA%A4%EF%BC%881%EF%BC%89.png" alt="与显式表面求交（1）"></p><p>简便的做法，把求交点和判断这两步并作一步，即Möller-Trumbore算法</p><h4 id="Moller-Trumbore算法"><a href="#Moller-Trumbore算法" class="headerlink" title="Möller-Trumbore算法"></a>Möller-Trumbore算法</h4><p>如下图，左边是光线上的点，右边是用重心坐标表示的三角形内的点</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p13-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/M%C3%B6ller-Trumbore%E7%AE%97%E6%B3%95.png" alt="Möller-Trumbore算法"></p><p>解出来之后要判断是否合理， $t&gt;0？\ \ \ b_1,b_2,b_3&gt;0？$</p><p>算法推导：</p><p><a href="https://blog.csdn.net/zhanxi1992/article/details/109903792">https://blog.csdn.net/zhanxi1992/article/details/109903792</a></p><h4 id="轴对齐包围盒（AABB）求交"><a href="#轴对齐包围盒（AABB）求交" class="headerlink" title="轴对齐包围盒（AABB）求交"></a>轴对齐包围盒（AABB）求交</h4><p>上述算法的计算次数： 像素数×三角形数×弹射次数</p><p>显然，对每一帧来说，这样的计算量是非常大的，所以我们需要引入包围盒，将一个复杂的物体用简单的形状围起来</p><p>那么如果光线连包围盒都碰不到，那肯定碰不到包围盒里的物体</p><p>对于三维的情况，我们一般用长方体包围盒，更特殊的，轴对齐包围盒，即包围盒的每一个边都对应和一个坐标轴平行</p><p>接着就来考虑光线和包围盒求交的问题</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p13-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/AABB%E5%8C%85%E5%9B%B4%E7%9B%92.png" alt="AABB包围盒"></p><p>只有当光线进入了三组对面，才能说明光线进入了包围盒，同理，当光线在三组对面外，才可知光线离开了包围盒</p><p>如上图，取$t<em>{min}$里的max，作为进入包围盒的时间，取$t</em>{max}$里的min，作为离开包围盒的时间</p><p>若进入包围盒的时间小于离开包围盒的时间，说明有交点</p><p><strong>几个问题</strong>：光线是射线，如果t是负数，那说明交点在射线的反向延长线上，这是不合理的，下面做分类讨论：</p><ul><li>盒子在光线背后：${t<em>{enter}}&lt;0,t</em>{output}&lt;0$</li><li>光线起点在盒子内部：$t<em>{enter}&lt;0,t</em>{output}&gt;0$</li></ul><p>综上，$iff\ \ \ t<em>{enter}&lt;t</em>{output}且t_{output}&gt;0$，此时才能证明光线和包围盒有交点</p><p>why AABB？为什么使用轴对称包围盒？</p><p>因为轴对齐的情况下，我们可以在求t的时候只求某一轴的信息（光线在轴上的投影），而不用整个坐标，比点乘计算会更加容易</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p13-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%BD%B4%E5%AF%B9%E7%A7%B0%E5%8C%85%E5%9B%B4%E7%9B%92.png" alt="为什么使用轴对称包围盒"></p><h4 id="使用轴对齐包围盒加速光线追踪"><a href="#使用轴对齐包围盒加速光线追踪" class="headerlink" title="使用轴对齐包围盒加速光线追踪"></a>使用轴对齐包围盒加速光线追踪</h4><p>通过上述分析，我们已经知道了光线如何和包围盒求交，那么又要怎么在空间中确定这些包围盒的位置呢</p><p>（需要注意，以下对空间的划分都是光线追踪的预处理操作）</p><h5 id="均匀划分"><a href="#均匀划分" class="headerlink" title="均匀划分"></a>均匀划分</h5><p>假设光线与物体求交比光线与包围盒求交慢的多，那么我们需要对包围盒进行进一步加工</p><p>均匀划分的步骤如下：</p><p>找到场景包围盒 -&gt; 均匀划分该包围盒 -&gt; 判定与物体相交的子包围盒 -&gt; 与物体求交</p><p>如果一条光线向右上投射出去，为了确定这条光线与哪些子包围盒相交，简单的想法是他下一次交到的包围盒在他当前交到的右边或上边（如何光栅化一条线）</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E5%9D%87%E5%8C%80%E5%88%92%E5%88%86%E7%A9%BA%E9%97%B4%E6%AD%A5%E9%AA%A4.png" alt="均匀划分空间步骤"></p><p>所谓加速就是多做光线与盒子求交，少做光线与物体求交，那么我们来看一下均匀划分的加速效果</p><div class="table-container"><table><thead><tr><th><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E5%9D%87%E5%8C%80%E5%88%92%E5%88%86%E7%9A%84%E5%A4%AA%E5%B0%91.png" alt="均匀划分的太少"></th><th><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E5%9D%87%E5%8C%80%E5%88%92%E5%88%86%E7%9A%84%E5%A4%AA%E5%A4%9A.png" alt="均匀划分的太多"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>如果划分成1×1的格子，则没有加速效果；如果划分太密集，效率也不会高</p><p>根据经验，人们大概得出划分成场景中物体数目的27倍的格子数比较好</p><p>==格子的划分方法在大量均匀分布的物体上比较有效，然而在复杂空旷的场景中，会造成很多资源浪费==</p><h5 id="空间划分"><a href="#空间划分" class="headerlink" title="空间划分"></a>空间划分</h5><p>在网格均匀划分中划分出来的都是大小相同的格子，但在有些空旷的地方不需要这样划分，太浪费了，我们想在没物体的地方用大盒子，有物体的地方用密集的盒子，这也就引出了空间划分的方法</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.png" alt="空间划分"></p><h6 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h6><p>每一次把空间划分成八份，直到满足一定的停止规则（比如某一次划分8个子空间中7个为空）</p><p><u>缺点：维数越高越复杂，n维空间对应$2^n$叉树</u></p><h6 id="BSP树"><a href="#BSP树" class="headerlink" title="BSP树"></a><strong>BSP树</strong></h6><p>一种对空间二分的划分方法，每次选一个方向进行划分，与KD树的区别在于它不是横平竖直地切，且它会有越高维越不好计算的问题（砍开二维用线，砍开三维用面，维度越高越复杂）</p><h6 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h6><p>每次把空间划分为两份，x，y，z轴轮流切分，直到被切分节点中不存在物体则停止</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/KD%E6%A0%91.png" alt="KD树"></p><p><u>KD树如何加速光线追踪：</u></p><p>如图，如果一条光线与当前结点空间有交点，则继续寻找该结点的子节点，直到找到叶子结点，再与其中物体求交</p><p><u>缺点：</u></p><p>给出一个节点的包围盒，要判断他与物体哪些三角形有交集，才能进行后续着色，这种算法确实存在，但不太好写</p><p>其次，很多情况下一个物体和很多包围盒都有交集，它可能会存在很多个叶子节点中，会造成重复计算</p><p>由此我们引入另一种基于物体的划分方式——BVHs</p><h5 id="BVHs划分"><a href="#BVHs划分" class="headerlink" title="BVHs划分"></a>BVHs划分</h5><p>Bounding Volume Hierarchy</p><p>找到场景包围盒 -&gt; 每次将物体分为两堆 -&gt; 对两堆物体重新计算包围盒 -&gt; 直到一堆中物体少到一定程度</p><p>如何划分物体：</p><p>1°选取当前最长的轴的垂直方向作为划分方向</p><p>2°取中间的物体（第$\frac{n}{2}$个三角形）（快速选择算法）</p><p>1°或2°都可以，主要是为了保证二叉树的平衡（平衡二叉树？）</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/BVHs.png" alt="BVHs"></p><p>BVH这种储存结构，中间结点储存包围盒和子节点的指针，叶子结点储存包围盒和物体（的集合）</p><p>关于BVH如何加速光线追踪，可以参考下述伪代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Intersect(Ray ray,BVH node)</span><br><span class="line">&#123;</span><br><span class="line">if(node is a leaf node)</span><br><span class="line">&#123;</span><br><span class="line">test intersection with all objs;</span><br><span class="line">return closest intersection;</span><br><span class="line">&#125;</span><br><span class="line">hit1 = Intersect(ray , node.child1);</span><br><span class="line">hit2 = Intersect(ray , node.child2);</span><br><span class="line"></span><br><span class="line">return the closer of hit1,hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BVHs-vs-KD"><a href="#BVHs-vs-KD" class="headerlink" title="BVHs vs. KD"></a>BVHs vs. KD</h5><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/BVH%20vs.%20KD.png" alt="BVH vs. KD"></p><p>一个是对空间的划分，一个是基于物体的划分；KD树的包围盒不会发生重合，而BVHs会发生相交</p><h3 id="辐射度量学基础"><a href="#辐射度量学基础" class="headerlink" title="辐射度量学基础"></a>辐射度量学基础</h3><p>why：</p><p>Blinn-Phong着色模型中会设置一个数当做光照强度，但我们都不清楚这个数的真实的物理意义，甚至连单位是什么也不知道，研究过程中我们只是将这些物理量简化为一个数，另外Whitted风格的光线追踪所得到的结果也不是我们所想要的真实的效果（路径追踪会提到），而所有的这些都会被辐射度量学解决，这同样也是后面学习路径追踪的基础</p><p>辐射度量学给出了一系列度量方法和单位去定义光照，它定义了光照在空间中的属性，并且这在物理上是完全正确的</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><div class="table-container"><table><thead><tr><th style="text-align:center">物理量</th><th style="text-align:center">符号</th><th style="text-align:center">中文翻译</th><th style="text-align:center">简单定义</th><th style="text-align:center">单位</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">Radiant Energy</td><td style="text-align:center">Q</td><td style="text-align:center">辐射能量</td><td style="text-align:center">电磁波形式的能量</td><td style="text-align:center">焦耳（J）</td><td style="text-align:center">\</td></tr><tr><td style="text-align:center">Radiant Flux</td><td style="text-align:center">P</td><td style="text-align:center">辐射功率/辐射通量</td><td style="text-align:center">单位时间内的辐射能量</td><td style="text-align:center">瓦特（w）</td><td style="text-align:center">$P=\frac{dQ}{dt}$</td></tr><tr><td style="text-align:center">Radiant Intensity</td><td style="text-align:center">I</td><td style="text-align:center">辐射强度</td><td style="text-align:center">点源向某单位立体角发射的辐射功率</td><td style="text-align:center">w/sr</td><td style="text-align:center">$I=\frac{dP}{d\omega}$</td></tr><tr><td style="text-align:center">Irradiance</td><td style="text-align:center">E</td><td style="text-align:center">辐（射）照度</td><td style="text-align:center">受照面单位面积上的辐射功率</td><td style="text-align:center">w$/m^2$</td><td style="text-align:center">$E=\frac{dP}{dA}$</td></tr><tr><td style="text-align:center">Radiance</td><td style="text-align:center">L</td><td style="text-align:center">辐（射）亮度</td><td style="text-align:center">单位投影面积、单位立体角上的辐射功率</td><td style="text-align:center">w$/m^2$sr</td><td style="text-align:center">$L=\frac{d^2P}{dAd\omega cos(\theta)}$</td></tr></tbody></table></div><p>光学中辐射强度的单位：$\frac{W}{sr}=\frac{lm}{sr}=candela=cd$</p><p>$\Omega/\omega$：立体角；$A$：受照面面积</p><p>sr：球面度，立体角国际单位</p><p>lm：流明，光通量国际单位</p><p>cd：坎德拉，光强单位，SI 7大基本单位之一</p><p>光通量和辐射通量：</p><p>光通量与辐射通量的量纲相同，但辐射通量是一个辐射度量学上的概念，是一个描述光源辐射强弱程度的客观物理量，而光通量是一个光 学概念，是一个属于把辐射通量与人眼的视觉特性联系起来评价的主观物理量，或者说光通量是按光对人眼所激起的明亮感觉程度所估计的辐射通量</p><h4 id="立体角"><a href="#立体角" class="headerlink" title="立体角"></a>立体角</h4><p>为了理解光线在空间中辐射的过程，我们需要引入立体角的概念</p><p>平面情况下，弧度制角度可以由$\theta=\frac{l}{r}$计算得到，仿照二维情况，立体角可以由$\omega=\frac{A}{r^2}$定义</p><p>其中A如图所示，是立体角锥体在球面上截出的一块面积</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E7%AB%8B%E4%BD%93%E8%A7%92%E6%A6%82%E5%BF%B51.png" alt="立体角概念1"></p><p>采用微分的思想求A的面积，可由简单推导得到</p><script type="math/tex; mode=display">dA=(r·d\theta)·(rsin(\theta)·d\phi)=r^2sin(\theta)d\phi d\theta\\\d\omega=\frac{dA}{r^2}=sin(\theta)d\phi d\theta</script><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p14-%E5%85%89%E8%BF%BD%EF%BC%8C%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/%E5%BE%AE%E5%88%86%E7%AB%8B%E4%BD%93%E8%A7%92.png" alt="微分立体角"></p><p>对微分立体角进行全积分，可以得到立体角的范围</p><script type="math/tex; mode=display">\Omega=\int_{S^2}\int_0^\pi sin(\theta)d\phi d\theta=4\pi\\\omega\in[0,4\pi]</script><p>具体推导过程参考：<a href="https://blog.csdn.net/LoseInVain/article/details/108630648">https://blog.csdn.net/LoseInVain/article/details/108630648</a></p><h4 id="Irradiance（辐照度）"><a href="#Irradiance（辐照度）" class="headerlink" title="Irradiance（辐照度）"></a>Irradiance（辐照度）</h4><p>定义：受照面单位面积上的辐射功率，即在单位时间内，每个单位面积上接受到的光照的能量</p><p>公式：$E=\frac{\mathrm{d}P}{\mathrm{d}A}·cos(\theta)=\frac{\mathrm{d}Q}{\mathrm{d}A\mathrm{d}t}·cos(\theta)$</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E8%BE%90%E7%85%A7%E5%BA%A6.png" alt="辐照度"></p><p>将辐射度量学里的功率换成光学里的流明，公式同样成立，光学中辐照度对应物理量为lux（勒克斯）</p><p>同样类似Blinn-Phone模型，这里也需要考虑光线和受照面的角度问题</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%B0%E4%BC%AF%E7%89%B9%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86.png" alt="兰伯特余弦定理"></p><p>如上三图，兰伯特余弦定理</p><p>左图光线垂直受照面，直接代公式；中图夹角60°，六根光线只照到三根，乘cos60°结果正确</p><p>更普遍的情况如右图，要乘以光线和受照面法线的夹角，写进代码就是 $l·n$</p><p>兰伯特余弦定理也可以解释地球的四季变换，北半球夏天太阳直射北半球，北半球的Irradiance当然更多，也就更热；而当北半球是冬天的时候，光线与北半球地球表面的夹角变大，cos值变小，Irradiance减少，冬天也就更冷</p><p>而在讲Blinn-Phone漫反射模型的时候，我们曾提到过，光照的辐射能量可以假设集中在一个球壳上，同一球面上光能处处相等，而随着球壳半径的增长，单位面积上的光能也呈$r^2$衰减</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E8%BE%90%E7%85%A7%E5%BA%A6%E8%A1%B0%E5%87%8F.png" alt="辐照度衰减"></p><p>如图，在最里面的单位球上$E=\frac{P}{4\pi}$，而在外层球壳上，$E’=\frac{P}{4\pi r^2}=\frac{E}{r^2}$</p><p>在学了辐照度概念之后，我们就可以知道这里光能衰减的并不是Radiant Intensity，而是Irradiance</p><p>对于Radiant Intensity，随r的增长，它的值保持不变</p><h4 id="Radiance（辐亮度）"><a href="#Radiance（辐亮度）" class="headerlink" title="Radiance（辐亮度）"></a>Radiance（辐亮度）</h4><p>定义：单位投影面积、单位立体角上的辐射功率，是描述环境中光的分布的基本场量</p><p>公式：</p><script type="math/tex; mode=display">L=\frac{\mathrm{d}^2P}{\mathrm{d}Ad\omega cos(\theta)}</script><p>注意这里的2是二次微分标记，即$dA,d\omega$各做一次微分，不是平方标记！</p><p>准确的光线追踪与radiance的关系非常大，其渲染就是在计算radiance</p><p>同样的，对于光学来说，辐亮度也有他自己的另一个单位，nit（尼特）</p><script type="math/tex; mode=display">[\frac{w}{m^2sr}][\frac{cd}{m^2}=\frac{lm}{m^2sr}=nit]</script><h4 id="Radiance-amp-Irradiance-amp-Intensity之间的联系与区别"><a href="#Radiance-amp-Irradiance-amp-Intensity之间的联系与区别" class="headerlink" title="Radiance &amp; Irradiance &amp; Intensity之间的联系与区别"></a>Radiance &amp; Irradiance &amp; Intensity之间的联系与区别</h4><p>从公式看起</p><script type="math/tex; mode=display">L=\frac{\mathrm{d}^2P}{\mathrm{d}Ad\omega cos(\theta)};\ \ \ I=\frac{\mathrm{d}P}{\mathrm{d}\omega};\ \ \ E=\frac{\mathrm{d}P}{\mathrm{d}A}\\L=\frac{\mathrm{d}E}{\mathrm{d}\omega cos(\theta)}^① =\frac{\mathrm{d}I}{\mathrm{d}A cos(\theta)}^②</script><p>从放射（放出能量）的角度来解释，Radiance表示单位面积上 因吸收了能量 而朝某个方向==辐射出去多少能量==</p><p>从入射（吸收能量）的角度来解释，Radiance表示单位面积上 所有接收到的能量中的某一束，即==Irradiance在某一方向上的分量==</p><p>而对于Intensity，辐射强度代表的是所有在某一单位立体角方向上辐射出的能量</p><p>Radiance代表这个Intensity在某个单位面积dA上的投影 / 分量</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E8%BE%90%E7%85%A7%E5%BA%A6&amp;%E8%BE%90%E4%BA%AE%E5%BA%A6.png" alt="辐照度&amp;辐亮度"></p><p>Radiance和Irradiance的区别和联系在图形学中非常重要，总结来说就是：</p><p>Radiance是某个单位面积向某个单位立体角辐射出去的能量，Irradiance是某个单位面积上接受到来自四面八方的能量</p><p>区别就在于辐亮度Radiance有方向的概念，而辐照度Irradiance没有</p><p>把半球面上的所有Radiance积分起来得到的就是Irradiance</p><h3 id="双向反射分布函数（BRDF）"><a href="#双向反射分布函数（BRDF）" class="headerlink" title="双向反射分布函数（BRDF）"></a>双向反射分布函数（BRDF）</h3><p>BRDF：Bidirectional Reflectance Distribution Function  双向反射分布函数</p><p>BSDF：Bidirectional Scattering Distribution Function  双向散射分布函数</p><p>BTDF：Bidirectional Transmittance Distribution Function  双向透射分布函数</p><p>BSSRDF：Bidirectional Scattering-Surface Reflectance Distribution Function  双向散射表面反射（次表面散射）分布函数</p><p>以上为PBR知识体系下渲染方程所涉及的BxDF</p><p>回归正题，我们之前所说的反射情况，当发生镜面反射时，光线会朝一个方向反射，当发生漫反射时，光线会向四面八方反射</p><p>在我们之前的理解中，反射就是光线到达物体表面后偏移到另一个方向，而在学了辐射度量学之后，我们可以换一个角度思考这个过程</p><p>假设光线到达物体表面后，被物体表面吸收，而后再由物体表面发射到其他方向去，也就是用Radiance和Irradiance来解释反射</p><p><strong>吸收过程</strong>：$\mathrm{d}E(\omega<em>{input})=L(\omega</em>{input})cos(\theta<em>{input})\mathrm{d}\omega</em>{input}$        参照①号公式</p><p>表示单位面积由$\omega_{input}$方向上的光线吸收得到的Irradiance</p><p><strong>辐射过程</strong>：$\mathrm{d}L(\omega<em>{output})\ \ \ (due\ \ to\ \ \mathrm{d}E(\omega</em>{input}))$</p><p>表示单位面积在经过吸收过程后向$\omega_{output}$方向上反射出去的Radiance</p><p>由上可知，我们很容易求得单位面积从某一方向吸收了多少能量，而很难求出吸收之后辐射出去的Radiance分布情况</p><p>于是我们就定义一种函数来描述这种Radiance的分布：</p><script type="math/tex; mode=display">\mathrm{d}L(\omega_{output})=f_r(\omega_{input}\rightarrow\omega_{output})·\mathrm{d}E(\omega_{input})\\f_r(\omega_{input}\rightarrow\omega_{output})=\frac{\mathrm{d}L(\omega_{output})}{\mathrm{d}E(\omega_{input})}=\frac{\mathrm{d}L(\omega_{output})}{L(\omega_{input})cos(\theta_{input})\mathrm{d}\omega_{input}}</script><p>这个函数就是BRDF双向反射分布函数，其实它就是定义了一个比例（该比例由材质决定）</p><script type="math/tex; mode=display">f_r(\omega_{input}\rightarrow\omega_{output})=\frac{吸收后向某立体角方向辐射出去的 Radiance}{辐射前某单位面积\mathrm{d}A接收到的Irradiance}</script><p>表示的是一个吸收与辐射的转化比例，即某个光线打到物体表面后，往不同方向反射的能量分布</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/BRDF.png" alt="BRDF"></p><p>现在再来考虑镜面反射和漫反射，我们会发现镜面反射辐射出去的能量全都集中在反射方向上，而漫反射则是将吸收的能量均匀分配到了各个方向</p><p>如果忽略公式本身的推导过程，其实BRDF描述的就是物体和光线之间的相互作用</p><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><h4 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h4><p>上述分析中，$dL(\omega<em>{output})$是某单位面积在$\omega</em>{input}$方向上吸收了$dE(\omega<em>{input})$后向$\omega</em>{output}$辐射的能量</p><p>而这仅仅是$\omega<em>{input}$方向上吸收得到的$dL(\omega</em>{output})$，我们的研究需要的是这个单位面积从各个方向上吸收了能量而在$\omega_{output}$上总共辐射的能量</p><p>因此我们需要对整个半球面求积分，来累加$dL(\omega_{output})$</p><script type="math/tex; mode=display">L(p,\omega_{exit})=\int_{H^2}f_r(p,\omega_{input}\rightarrow\omega_{exit})·dE(p,\omega_{input})=\int_{H^2}f_r(p,\omega_{input}\rightarrow\omega_{exit})·L(p,\omega_{input})cos(\theta_{input})d\omega_{input}</script><p>方程的（）中多出来的p表示入射（反射）点</p><p>另外，在考虑反射方程的时候，我们还要注意：</p><p>反射点接受的能量（Irradiance）并不只是来自于光源，还会来自别的表面反射来的光（Irradiance）</p><p>从反射点反射出去的能量（Radiance）也并不只会反射到Camera或者人眼，还会作为Irradiance反射到其他的面上</p><p>所以理论上的反射方程定义应该带有递归的思想，也因此，光线反射的次数不同，得到的最终效果也就不会不同</p><p>但是我们目前先不考虑这些，暂且先用上面这个反射方程当做通用的方程</p><h4 id="渲染方程-1"><a href="#渲染方程-1" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>渲染方程与反射方程相比只是多加了一个自发光的项</p><p>渲染效果 = 反射光 + 自发光，方程如下：</p><script type="math/tex; mode=display">L(p,\omega_{output})=L_{emission}+\int_{\Omega+}L(p,\omega_{input})·f_r(p,\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})d\omega_{input}</script><p>注意其中$\omega^+$和$H^2$是等价的，都是表示半球面 积分区域，并且在渲染方程中，假设入射出射所有的向量都是由内指向外的</p><h4 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h4><p>如果只有一个点光源，那么反射光=自发光+入射光×BRDF×入射光与法线的夹角</p><p>如果有很多个点光源，那么反射光就是把所有点光源的反射光能量加起来</p><script type="math/tex; mode=display">L(p,\omega_{output})=L_{emission}+\sum L(p,\omega_{input})·f_r(p,\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})</script><p>如果存在面光源，那么将这个面光源当成点光源的集合，求积分</p><script type="math/tex; mode=display">L(p,\omega_{output})=L_{emission}+\int_{\Omega}L(p,\omega_{input})·f_r(p,\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})d\omega_{input}</script><p>如果不止光源，还有其他物体反射来的光，则把其他物体的反射面当成光源，递归</p><script type="math/tex; mode=display">L(p,\omega_{output})=L_{emission}+\int_{\Omega}L(X',\omega_{input})·f_r(X',\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})d\omega_{input}</script><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B1.png" alt="渲染方程1"></p><h5 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h5><p>为方便后续理解，将整个渲染方程简写</p><script type="math/tex; mode=display">L(p,\omega_{output})=L_{emission}+\int_{\Omega}L(X',\omega_{input})·f_r(X',\omega_{input}\rightarrow\omega_{output})·(n·\omega_{input})d\omega_{input}\\\downarrow\\L(u)=e(u)+\int L(v)K(u,v)dv\\\downarrow\\L=E+KL</script><p>e(u)：自发光<br>L(v)：吸收其他物体反射过来的光后辐射出来的Irradiance<br>K(u,v)：BRDF算子<br>u，v表示两个不同的反射位置</p><p>L、E是向量，K是算子/矩阵</p><p>化简，求出L</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B2.png" alt="渲染方程2"></p><p>利用算子的运算性质（求逆以及泰勒展开）进一步对L进行变换</p><p>最后我们得到的L这种形式可以视作以 光的弹射次数 为区分的很多项，把光线弹射的次数的项累加起来，就得到了全局光照渲染方程</p><p>如果用渲染方程来理解光栅化，可以发现光栅化只做了全局光照的前两步，即自发光和直接光照</p><p>从这里再理解光线追踪一开始说的光栅化的不足，豁然开朗</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E7%94%A8%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E7%90%86%E8%A7%A3%E5%85%89%E6%A0%85%E5%8C%96.png" alt="用渲染方程理解光栅化"></p><p>随着展开次数的增加，渲染效果如下图所示</p><div class="table-container"><table><thead><tr><th><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A71.png" alt="全局光照1"></th><th><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A72.png" alt="全局光照2"></th></tr></thead><tbody><tr><td><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A73.png" alt="全局光照3"></td><td><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A74.png" alt="全局光照4"></td></tr><tr><td><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A75.png" alt="全局光照5"></td><td><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p15-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%EF%BC%8C%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A76.png" alt="全局光照6"></td></tr></tbody></table></div><p>前几张的对比效果非常明显，注意到两次反射和四次反射中，图片上方的灯由黑色转为透明，这是因为如果只做两次反射，光线只能被允许进入玻璃内，而无法从玻璃中透射出来，而四次反射则可以让光线从中射出，因此反射四次的灯是透明的</p><p>另外，不难发现8次反射和16次反射得到的结果并没有差太多，这也恰恰证明了渲染方程满足泰勒展开级数收敛这一性质</p><h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3><p>需要用到的概率论知识点（建议复习）：离散/连续型随机变量的分布，连续型随机变量的概率密度函数（PDF），数学期望</p><p>why：正常的定积分（黎曼积分）都要求有解析式才能够进行计算，而大多数情况解析式是求不出来的。蒙特卡洛积分提供了一种求解这些比较难以计算的积分的近似值的思路</p><p>what：在积分区域上随机采样，若采样方式为均匀采样（采样pdf为均匀分布），则认为样本和采样值的乘积 $xf(x)$ 为单次采样的积分结果，随后多次采样取平均，得到最终近似结果：</p><script type="math/tex; mode=display">F_N=\frac{b-a}{N}\sum_{i=1}^{N}{f(X_i)}</script><p>可以借助之前黎曼积分的面积微元进行理解，蒙特卡洛积分就是求了一个面积的平均值</p><p>更一般的，若采样方式并非均匀，而是满足一种概率密度函数（pdf），则积分结果如下：</p><script type="math/tex; mode=display">F_N=\frac{1}{N}\sum_{i=1}^{N}\frac{f(X_i)}{pdf(X_i)}\ ,\ (X_i\sim pdf(x))</script><p>其中，N为采样次数，$X_i$为随机变量（采样值）</p><p>这里除以$pdf(X_i)$可以理解为一种加权，哪里采样的多哪里就多做平均</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPUGems3：</span><br><span class="line">...</span><br><span class="line">However, when we skew sample directions, not all estimates of the integral are equal, and thus we must weight them accordingly when averaging all the samples. For instance, one sample in a low-value region of the PDF is representative of what would be many samples if uniform sampling were used. Similarly, one sample in a high-value PDF region represents only a few samples with uniform sampling. To compensate for this property of the PDF-proportional sampling, we multiply each sample by the inverse of the PDF.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E5%AE%9A%E4%B9%89.png" alt="蒙特卡洛积分定义"></p><h3 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h3><p>Whitted-Style光线追踪的做法是，光线在镜面反射表面弹射，而在漫反射表面停止，这显然是不符合现实的</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/Whitted%EF%BC%9F(1" alt="Whitted？(1)">.png)</p><p>其中一个问题，拿经典的Utah teaport为例，whitted光追只能做左图的光照效果，而对于那种有光泽但不全是镜面反射的glossy材质（右图），whitted做出来的效果并不尽如人意</p><p>第二个问题，whitted风格光线追踪不考虑漫反射，虽然递归的思想是正确的，但就像下图（康奈尔盒子）所示，whitted的天花板由于接收不到来自环境光照，呈现一个全黑的状态，并且whitted渲染出的长方体并没有表现红墙和绿墙上反射过来的带有色彩的光，相比之下，路径追踪的结果就真实很多</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/Whitted%EF%BC%9F(2" alt="Whitted？(2)">.png)</p><h4 id="求解渲染方程"><a href="#求解渲染方程" class="headerlink" title="求解渲染方程"></a>求解渲染方程</h4><p>对于之前的渲染方程，我们可以用蒙特卡洛积分法进行求解</p><p>忽略自发光项（仅计算直接光照），简单考虑均匀采样的情况，半球立体角范围$[0,2\pi]$，因此$pdf(x)=\frac{1}{2\pi}$</p><script type="math/tex; mode=display">L(p,\omega_{output})=\int_{\Omega+}L(p,\omega_{input_i})·f_r(p,\omega_{input_i}\rightarrow\omega_{output})·(n·\omega_{input_i})d\omega_{input_i}\\\approx\frac{1}{N}\sum_{i=1}^{N}\frac{L(p,\omega_{input_i})·f_r(p,\omega_{input_i}\rightarrow\omega_{output})·(n·\omega_{input_i})}{pdf(\omega_{input_i})}</script><p>用伪代码表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w_o)</span><br><span class="line">Randomly choose N directions wi~pdf <span class="comment">//采样N个方向分别打光</span></span><br><span class="line">Lo = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> each wi</span><br><span class="line">&#123;</span><br><span class="line">Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line"><span class="keyword">if</span> a ray hit the light <span class="comment">//若打到光源，则累加</span></span><br><span class="line">Lo += (<span class="number">1</span>/N) * L_i * f_r * cosine / pdf(wi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Lo;</span><br></pre></td></tr></table></figure><p>接着，引入间接光照</p><p>要知道着色点P因Q的反射获得多少能量，其实就相当于摄像机在P点处计算Q的直接光照</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E9%97%B4%E6%8E%A5%E5%85%89%E7%85%A7%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA.png" alt="间接光照路径追踪"></p><p>那么就只需要在上述伪代码中加一条判断，看看这条光线有没有打到其他物体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w_o)</span><br><span class="line">Randomly choose N directions wi~pdf <span class="comment">//采样N个方向分别打光</span></span><br><span class="line">Lo = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> each wi</span><br><span class="line">&#123;</span><br><span class="line">Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line"><span class="keyword">if</span> ray r hit the light <span class="comment">//若打到光源，则累加</span></span><br><span class="line">Lo += (<span class="number">1</span>/N) * L_i * f_r * cosine / pdf(wi);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ray r hit an object at q</span><br><span class="line">Lo += (<span class="number">1</span>/N) * shade(q,-wi) * f_r * cosine / pdf(wi); <span class="comment">//若打到物体，则递归</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Lo;</span><br></pre></td></tr></table></figure><p>至此，基本的求解渲染方程已经有了大概的架构，但代码依然存在一些不可忽视的问题</p><h4 id="完善代码"><a href="#完善代码" class="headerlink" title="完善代码"></a>完善代码</h4><p>递归递归，有递有归，无非就是要考虑==问题传递的可行性==和==有没有归==这两方面因素</p><h5 id="问题传递的可行性"><a href="#问题传递的可行性" class="headerlink" title="问题传递的可行性"></a>问题传递的可行性</h5><p>p的着色需要q的环境光照信息，而q的环境光照信息又必须包含其他物体的环境光照信息，如此需要追踪的光线数量会呈指数级增长</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%981.png" alt="路径追踪递归问题1"></p><p>只有当采样数为1的时候，即N=1时，才不会受到这种影响，路径追踪也因此得名（N$\neq$1时称为分布式光线追踪）</p><p>虽然但是，这样一来误差就会特别大，渲染结果势必会有非常多的噪点，为了解决这个问题，我们对单个像素计算多次路径追踪结果，随后求平均，这个过程其实也用到了蒙特卡洛方法</p><p>修改伪代码，得到路径追踪渲染方程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w_o)</span><br><span class="line">&#123;</span><br><span class="line">Randomly choose One directions wi~pdf <span class="comment">//采样1个方向打光</span></span><br><span class="line">Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line"><span class="keyword">if</span> ray r hit the light <span class="comment">//若打到光源，则累加</span></span><br><span class="line"><span class="keyword">return</span> L_i * f_r * cosine / pdf(wi);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ray r hit an object at q</span><br><span class="line"><span class="keyword">return</span> shade(q,-wi) * f_r * cosine / pdf(wi); <span class="comment">//若打到物体，则递归</span></span><br><span class="line"><span class="keyword">return</span> Lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ray_generation(cam_pos,pixel)</span><br><span class="line">&#123;</span><br><span class="line">Uniformly choose N sample positions within the pixel; <span class="comment">//对一个像素采样N个路径</span></span><br><span class="line"><span class="comment">//对每条路径计算着色后进行累加，注意该处pdf和shade函数中的pdf并不相同，这里是对像素采样的pdf</span></span><br><span class="line">    <span class="keyword">for</span> each sample in the pixel</span><br><span class="line">&#123;</span><br><span class="line">shoot a ray <span class="title function_">r</span><span class="params">(cam_pos,cam2sample)</span>;</span><br><span class="line"><span class="keyword">if</span> ray r hit the scene at p</span><br><span class="line">pixel_radiance += <span class="number">1</span>/N * shade(p,sample2cam)/pdf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pixel_radiance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归结束条件"><a href="#递归结束条件" class="headerlink" title="递归结束条件"></a>递归结束条件</h5><p>很容易看出，上述算法的递归没有终止条件，放到现实中这也是非常合理的，因为现实中的光并不会弹射一定次数后终止弹射，而会一直弹射下去，在算法中强行设置终止次数结束递归不满足现实情况的能量守恒定律，会有一定亮度差异（弹射3次和弹射17次的亮度差异是非常明显的），为了解决这一问题，我们需要用到与俄罗斯轮盘赌类似的思想</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E4%BF%84%E7%BD%97%E6%96%AF%E8%BD%AE%E7%9B%98%E8%B5%8C.png" alt="俄罗斯轮盘赌"></p><p>这个思想其实就是一个伯努利分布（均匀分布）概念，让光线在每个弹射点都有一定概率继续弹射，设这个概率为p，那么光线停止弹射的概率为（1-p），为了得到相同的路径追踪结果，意味着这个伯努利实验的期望值必须保持Lo不变，那么我们可以巧妙的认为p概率继续弹射得到的能量是$\frac{Lo}{p}$（终止弹射的结果很自然就是0）</p><script type="math/tex; mode=display">E=P·\frac{Lo}{P}+(1-p)·0=Lo</script><p>总结到伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shade(p,w_o)</span><br><span class="line">&#123;</span><br><span class="line">Manually specify a probability P_RR；</span><br><span class="line">Randomly select ksi in a uniform dist. in [<span class="number">0</span>,<span class="number">1</span>]； <span class="comment">//取0-1的一个随机数</span></span><br><span class="line"><span class="keyword">if</span> (ksi &gt; P_RR)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">Randomly choose One directions wi~pdf <span class="comment">//采样1个方向打光</span></span><br><span class="line">Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line"><span class="keyword">if</span> ray r hit the light</span><br><span class="line"><span class="keyword">return</span> L_i * f_r * cosine / pdf(wi) / P_RR;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ray r hit an object at q</span><br><span class="line"><span class="keyword">return</span> shade(q,-wi) * f_r * cosine / pdf(wi) / P_RR;</span><br><span class="line"><span class="keyword">return</span> Lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们就有了一个合理的递归终止条件</p><p><em>思考：闫老师上课提了一个问题，对于分布式光线追踪，这个期望值是多少</em></p><p><em>答：$E=\frac{p}{(1-p)^2}$，证明如下</em></p><script type="math/tex; mode=display">\sum_{n=1}^\infty np^n=p+2p^2+3p^3+···+np^n ①\\p\sum_{n=1}^\infty np^n=p^2+2p^3+···+(n-1)p^n+np^{n+1} ②\\①-②:(1-p)\sum_{n=1}^\infty np^n=p+p^2+p^3+···+p^n-np^{n+1}=\sum_{n=1}^\infty p^n=\frac{p}{1-p}\\E=\sum_{n=1}^\infty np^n=\frac{p}{(1-p)^2}</script><h4 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h4><p>至此，我们的路径追踪算法已经做到完全正确，但又出现了一个矛盾点，即像素的采样率</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E5%83%8F%E7%B4%A0%E9%87%87%E6%A0%B7%E7%8E%87%E5%B7%AE%E5%BC%82.png" alt="像素采样率差异"></p><p>上左图为采样率较低的情况，渲染速度快，效果差，右图采样率较高，效果好，但渲染速度慢</p><p>引发这个矛盾的原因是光源大小的不确定性，我们的算法在计算间接光照的时候，可能在采样路径半当中还没弹射到光源就被俄罗斯轮盘终止掉了，相当于这次计算算了个寂寞。面对大的光源，这种情况会很少，而一旦碰上了小光源，这种浪费现象会频繁发生，这是我们不希望看到的，所以我们就想能不能不用这种基于着色点采样的方式，而改为一种基于光源的pdf</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E5%9D%87%E5%8C%80%E9%87%87%E6%A0%B7%E7%9A%84%E7%BC%BA%E7%82%B9.png" alt="路径追踪均匀采样的缺点"></p><p>先不考虑光源和着色点之间有物体阻挡这种情况，把光源视为一个矩形表面，直接在光源上采样，就不会发生这种浪费</p><p>设着色点法线为n，光源平面的法线n’，如图</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E5%AF%B9%E5%85%89%E6%BA%90%E8%BF%9B%E8%A1%8C%E9%87%87%E6%A0%B7.png" alt="对光源进行采样"></p><p>设光源平面面积为A，采样面积dA，则对光源均匀采样的pdf为$\frac{1}{A}$（原因见上图ppt），问题是，之前提渲染方程的时候，都是采样到哪个点就计算哪个点的立体角的积分，这里在光源上采样，却还用着着色点的立体角微分，这显然是不对的</p><p>因此，我们需要对积分域做一个变换，即找到$d\omega$和$dA$的关系</p><p>先算$dA·cos\theta’$求出$dA$在$d\omega$上的投影，再通过立体角定义，求得</p><script type="math/tex; mode=display">d\omega=\frac{dAcos\theta'}{|x'-x|^2}</script><p>重写渲染方程</p><script type="math/tex; mode=display">L(p,\omega_{output})=\int_{\Omega+}L(p,\omega_{input_i})·f_r(p,\omega_{input_i}\rightarrow\omega_{output})·cos\theta \ d\omega_{input_i}\\=\int_{\Omega+}L(p,\omega_{input_i})·f_r(p,\omega_{input_i}\rightarrow\omega_{output})·\frac{cos\theta ·cos\theta'}{|x'-x|^2} \ dA</script><p>之前对着色点采样，是一条路径上每弹射一次就判断一次是否继续递归，对于光源采样，思路要进行微调，即分为两部分计算，一部分是光源直接对着色点的影响，另一部分是光源的间接影响</p><p>翻译到伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shade(p,wo)</span><br><span class="line">&#123;at x<span class="number">&#x27;</span>;<span class="comment">//pdf_light = 1/A</span></span><br><span class="line">    L_dir = L_i * f_r * <span class="built_in">cos</span>θ * <span class="built_in">cos</span>θ<span class="string">&#x27; / |x&#x27;</span>-p|^<span class="number">2</span> / pdf_light;</span><br><span class="line"></span><br><span class="line"># Contribution from other reflectors</span><br><span class="line">L_indir = <span class="number">0.0</span>;</span><br><span class="line">Test Russian Roulette with probability P_RR;</span><br><span class="line">    Uniformly sample the hemisphere toward wi;<span class="comment">//pdf_hemi = 1 / 2pi</span></span><br><span class="line">    Trace a ray <span class="title function_">r</span><span class="params">(p,wi)</span>;</span><br><span class="line">    <span class="keyword">if</span> ray r hit a non-emitting object at q</span><br><span class="line">        L_indir = shade(q,-wi) * f_r * <span class="built_in">cos</span>θ / pdf_hemi / P_RR;</span><br><span class="line">    <span class="keyword">return</span> L_dir + L_indir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还没完，回到没考虑的光源和着色点之间有物体阻挡的情况，需要额外再加一个判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shade(p,wo)</span><br><span class="line">&#123;</span><br><span class="line"># Contribution from the light source.</span><br><span class="line">    Uniformly sample the light at x<span class="number">&#x27;</span>;<span class="comment">//pdf_light = 1/A</span></span><br><span class="line">    Shoot a ray from p to x<span class="number">&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> the ray is not blocked in the middle</span><br><span class="line">    L_dir = ...</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>总结一下路径追踪的整体思路：由像素采样打出追踪路径确定需要计算的着色点，再光源采样计算每个着色点的着色信息，返回给像素</p><p>看下结果</p><p><img src="/posts/8491/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p16-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%E7%BB%93%E6%9E%9C%E5%87%A0%E4%B9%8E100%25%E6%AD%A3%E7%A1%AE.png" alt="路径追踪结果几乎100%正确"></p><p>可以看到，路径追踪几乎可以做到100%正确</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现代的光线追踪已经不再仅仅是指Whitted风格光线追踪了，Ray-Tracing可以被理解为一切模拟光线传播的方法的集合，如双向路径追踪，光子映射等等等等。计图是一个很深的坑，一门入门课肯定有很多东西覆盖不到，就拿路径追踪来说——</p><p>蒙特卡洛积分应该用什么pdf？（重要性采样）</p><p>计算机自带的随机数真的正确么？（随机数质量）</p><p>对着色点采样和对光源采样二者能否结合？（多重重要性采样 IMS）</p><p>对像素的采样需要如何加权？</p><p>最后得到的结果是radiance，如何转化为像素颜色？（伽马矫正）</p><p>……</p><p>路径追踪仍然是入门级别的内容……敬畏科学吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（6）-材质与外观</title>
      <link href="/posts/53257.html"/>
      <url>/posts/53257.html</url>
      
        <content type="html"><![CDATA[<p>之前我们为了描述单位受照面吸收能量后辐射出去的Radiance分布情况，引入了BRDF函数，这个函数表示了材质如何与光线作用</p><p>而之后我们研究物体的材质和外观，就是在研究这些函数</p><h3 id="漫反射材质"><a href="#漫反射材质" class="headerlink" title="漫反射材质"></a>漫反射材质</h3><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8.png" alt="漫反射材质"></p><p>在Blinn-Phong模型中，讨论漫反射系数的时候，我们只是经验性的引入$\frac{I}{r^2}$来表示到达着色点的能量</p><script type="math/tex; mode=display">L_d=k_d(\frac{I}{r^2})max(0,n·l)</script><p>在学完渲染方程后，我们知道这其实并不准确，现在用$f_r$来准确计算这个漫反射系数</p><p>假设任意方向的入射光和出射光的Radiance和Irradiance都相等，着色点不吸收任何能量，且自发光项为0</p><p>则依渲染方程，可推出$f_r$如下</p><script type="math/tex; mode=display">L_o=\int_{\Omega^+} L_i \cdot f_r \cdot cos\theta_i\, \mathrm{d}\omega_i=L_i \cdot f_r\int_{\Omega^+} cos\theta_i \, \mathrm{d}\omega_i\\\int_{\Omega^+} cos\theta_i\, \mathrm{d}\omega_i=\int_{\Omega^+} cos\theta_i \ sin\theta_i \, \mathrm{d}\theta_i \, \mathrm{d}\phi_i=\int_0^{2\pi}\int_0^{\frac{\pi}{2}}sin\theta_i \, \mathrm{d}\sin\theta_i \ \, \mathrm{d}\phi_i= \pi\\L_o=f_rL_i\pi\Longrightarrow f_r=\frac{L_o}{L_i \pi}=\frac{1}{\pi}\\</script><p>定义一个反射率（albedo）$\rho\in[0,1]$与$f_r$相乘，于是通过$f_r$就可以控制材质的颜色变化</p><script type="math/tex; mode=display">f_r=\frac{\rho}{\pi}\in[0,\frac{1}{\pi}]</script><h3 id="光泽材质"><a href="#光泽材质" class="headerlink" title="光泽材质"></a>光泽材质</h3><p>光泽材质是介于漫反射材质与理想镜面反射材质之间的一种材质，光线的反射方向集中在一个小范围内</p><p>生活中的光泽材质有如打磨过的铜镜或者其他的一些金属材质</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%85%89%E6%B3%BD%E6%9D%90%E8%B4%A8.png" alt="光泽材质"></p><h3 id="理想反射-折射材质"><a href="#理想反射-折射材质" class="headerlink" title="理想反射/折射材质"></a>理想反射/折射材质</h3><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E7%90%86%E6%83%B3%E5%8F%8D%E5%B0%84%E6%8A%98%E5%B0%84%E6%9D%90%E8%B4%A8.png" alt="理想反射折射材质"></p><p>光线到达材质表面被吸收一部分，同时发生镜面反射和镜面折射，这种材质被称为Ideal reflective / refractive material</p><h4 id="（完美）镜面反射"><a href="#（完美）镜面反射" class="headerlink" title="（完美）镜面反射"></a>（完美）镜面反射</h4><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%AE%8C%E7%BE%8E%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84.png" alt="完美镜面反射"></p><p>公式分为两部分，左图（正视图）观察入射角和出射角，右图（俯视图）观察方位角</p><p>写出正确的完美镜面反射BRDF方程需要用到δ函数，在此从略</p><p>δ函数：<a href="https://wuli.wiki/online/Delta.html#note2">https://wuli.wiki/online/Delta.html#note2</a></p><h4 id="镜面折射"><a href="#镜面折射" class="headerlink" title="镜面折射"></a>镜面折射</h4><p>光从一种透明介质斜射入另一种透明介质时，由于光在两种介质中传播速度不同而使传播方向发生偏转的现象称为折射（初中物理）</p><p>生活中的折射现象有如：</p><p>三棱镜色散（不同波长的色光有不同的折射率）（依然用几何光学描述，不涉及波粒二象性等内容）</p><p>海水焦散，Caustics（不合适的翻译，主要还是由折射后聚焦引发，与散射关系不大）</p><h5 id="斯涅耳定律"><a href="#斯涅耳定律" class="headerlink" title="斯涅耳定律"></a>斯涅耳定律</h5><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%96%AF%E6%B6%85%E8%80%B3%E5%AE%9A%E5%BE%8B.png" alt="斯涅耳定律"></p><p>入射材质折射率 × 入射角正弦 = 出射材质折射率 × 折射角正弦</p><p>由图右侧常见折射率，钻石折射率较大，这就意味着光线通过钻石发生的偏转幅度比较大，这也是为什么钻石闪闪发光的原因</p><p>进一步推导</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%8A%98%E5%B0%84%E5%AE%9A%E5%BE%8B.png" alt="折射定律"></p><p>我们发现，折射的发生条件是入射材质的折射率小于出射材质折射率，一旦大于，就会发生全反射现象</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%96%AF%E6%B6%85%E8%80%B3%E7%AA%97.png" alt="斯涅耳窗"></p><p>人在水底只能看到锥形视野范围内的光，也是因为折射，相关现象被称为斯涅耳窗（snell’s window）</p><h4 id="双向散射分布函数（BSDF）"><a href="#双向散射分布函数（BSDF）" class="headerlink" title="双向散射分布函数（BSDF）"></a>双向散射分布函数（BSDF）</h4><p>描述反射的分布函数被称为双向反射分布函数（BRDF），那么描述折射也需要一种分布函数</p><p>这种分布函数被称为双向折射(透射)分布函数（BTDF）</p><p>BRDF和BTDF统称为双向散射分布函数（BSDF）</p><script type="math/tex; mode=display">f_s=f_r+f_t</script><h4 id="菲涅尔项"><a href="#菲涅尔项" class="headerlink" title="菲涅尔项"></a>菲涅尔项</h4><p>观察下图中视角与反射结果的关系</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E8%8F%B2%E6%B6%85%E5%B0%94%E5%8F%8D%E5%B0%84%E4%BE%8B%E5%AD%90.png" alt="菲涅尔反射例子"></p><p>我们很容易发现，当我们用几乎垂直的视角看下去，基本看不到什么反射，而当我们的视角几乎水平时，反射结果特别明显</p><p>这是因为光线以不同角度入射会有不同的反射率，也就是所谓的菲涅尔效应</p><p>生活中的菲涅尔效应还有例如：</p><p>正对着窗子看能看清窗外景色，侧着看窗外看到大多室内的反射</p><p>站在湖边，透过近处的湖水能看见水底的情况，而望向远处只能看到群山的倒影</p><p>……</p><p>另外，在相同的入射角情况下，不同的材质也具有不同的反射率，即具有不同的菲涅尔项</p><p>下图即为两种不同的材质对应的菲涅尔项数据</p><div class="table-container"><table><thead><tr><th style="text-align:center">折射率为1.5的绝缘体</th><th style="text-align:center">导体</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B91.png" alt="菲涅尔项1"></td><td style="text-align:center"><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B92.png" alt="菲涅尔项2"></td></tr></tbody></table></div><p>图中另外两条虚线表示光的极化性质，即光只沿一个方向振动情况下的菲涅尔项，现在的渲染器很少考虑这种情况</p><p>由图对应到现实一目了然，生活中各种金属的反射率一直都很高，所以我们习惯用镀银的玻璃作为镜子而不是用玻璃…</p><p>为了计算菲涅尔项，有非常复杂的公式，通过极化的菲涅尔数据做平均得到结果</p><p>但我们也有简单的近似（施利克近似 Schlick’s approximation），如图</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E8%AE%A1%E7%AE%97%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B9.png" alt="计算菲涅尔项"></p><p>这种近似方法认为菲涅尔曲线就是一条从  0°入射角菲涅尔项到90°入射角  的单调增函数，90°时$R_0=1$</p><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/303168568">光的反射与折射——从Snell、Fresnel到Schlick - 知乎 (zhihu.com)</a></p><h3 id="微表面模型"><a href="#微表面模型" class="headerlink" title="微表面模型"></a>微表面模型</h3><p>从理论上来说，地球表面是凹凸不平的，具有沙漠山丘等复杂地形，但在非常远的距离下拍摄，如下图所示的卫星图，我们却看到了如同在光滑球面上一样的高光</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%8D%AB%E6%98%9F%E5%9B%BE.png" alt="卫星图"></p><p>由此我们提出微表面模型，假设离得足够远的时候，微观表面可以被忽略，而最后看到一个宏观的结果</p><p>用微表面理论解释漫反射，即从微观看漫反射表面，每个微元表面都是完美镜面反射，都有各自的法线（微观上看是几何）</p><p>我们可以通过研究这些法线的分布来描述物体表面的粗糙程度</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E6%B3%95%E7%BA%BF%E5%88%86%E5%B8%83.png" alt="微表面法线分布"></p><p>镜面反射的法线方向分布比较集中，而漫反射表面的法线分布比较分散</p><p>有了微表面模型，我们就可以提出在微表面下的更精确的BRDF方程</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E6%A8%A1%E5%9E%8BBRDF.png" alt="微表面模型BRDF"></p><p>如图，F为菲涅尔项；D为法线分布，查询半程向量是否在法线分布内；G为几何项，由于在微表面上，对于那些几乎和表面平行的入射光，很容易发生互相遮挡的现象，从而使得部分微表面失去作用，我们把这种光线角度称为掠射角度（Grazing Angle），在这种角度下的着色会非常亮，G项就起到了一定的修正作用</p><script type="math/tex; mode=display">NDF_{GGTR}(n, h, \alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2 (\alpha^2 - 1) + 1)^2}\\G_{SchlickGGX}(n, v, k) = \frac{n \cdot v} {(n \cdot v)(1 - k) + k },\ (k_{direct} = \frac{(\alpha + 1)^2}{8},\ k_{IBL} = \frac{\alpha^2}{2})\\G(n, v, l, k) = G_{sub}(n, v, k) G_{sub}(n, l, k)\\F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0) ( 1 - (h \cdot v))^5 \\L_o(p,\omega_o) = \int\limits_{\Omega} (k_d\frac{c}{\pi} + \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}) L_i(p,\omega_i) n \cdot \omega_i \mathrm{d}\omega_i</script><div class="table-container"><table><thead><tr><th><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%20(2" alt="微表面 (2)">.png)</th><th><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%20(3" alt="微表面 (3)">.png)</th><th><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%BE%AE%E8%A1%A8%E9%9D%A2%20(1" alt="微表面 (1)">.png)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>微表面模型可以得到非常真实的渲染结果，因为他本身就是基于物理的渲染（PBR/PBS）</p><p>当然，微表面也有他的缺点，有时因为diffuse的太少，需要手动往上加点参数调节</p><h3 id="各向同性-各向异性材质"><a href="#各向同性-各向异性材质" class="headerlink" title="各向同性/各向异性材质"></a>各向同性/各向异性材质</h3><p>各向同性（IsotropicMaterials）：微表面不存在方向性<br>各向异性（Anisotropic Materials）：微表面存在方向性</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%90%8C%E6%80%A7%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7.png" alt="各向同性各向异性"></p><p>对于BRDF来说，这里所说的方向性就是指，如果入射光和出射光做一定方位角的旋转前后，BRDF方程不变，那么这种材质就是各向同性的，反之则为各向异性</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7.png" alt="各向异性"></p><p>再看几个各向异性的例子</p><div class="table-container"><table><thead><tr><th style="text-align:center">不锈钢</th><th style="text-align:center">尼龙</th><th style="text-align:center">天鹅绒</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E4%BE%8B1.png" alt="各向异性例1"></td><td style="text-align:center"><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E4%BE%8B2.png" alt="各向异性例2"></td><td style="text-align:center"><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E4%BE%8B3.png" alt="各向异性例3"></td></tr></tbody></table></div><h3 id="BRDF性质总结"><a href="#BRDF性质总结" class="headerlink" title="BRDF性质总结"></a>BRDF性质总结</h3><ul><li>非负性：描述能量分布</li><li>线性性：可以被拆分成不同项的线性组合（ambient，diffuse，specular）</li></ul><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/BRDF%E9%9D%9E%E8%B4%9F%E6%80%A7%E7%BA%BF%E6%80%A7%E6%80%A7.png" alt="BRDF非负性线性性"></p><ul><li>可逆性：调换入射出射方向，BRDF渲染结果严格不变</li><li>能量守恒：出射光线的能量永远不能超过入射光线的能量</li></ul><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/BRDF%E5%8F%AF%E9%80%86%E6%80%A7%E8%83%BD%E9%87%8F%E5%AE%88%E6%81%92.png" alt="BRDF可逆性能量守恒"></p><ul><li>各向同/异性：如果是各项同性材质，则BRDF值只和相对方位角有关，四维的BRDF材质可以被降维为三维，并且根据可逆性，结果不需要考虑方位角的正负</li></ul><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/BRDF%E5%90%84%E9%A1%B9%E5%90%8C%E6%80%A7.png" alt="BRDF各项同性"></p><h3 id="BRDF的测量"><a href="#BRDF的测量" class="headerlink" title="BRDF的测量"></a>BRDF的测量</h3><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E7%90%86%E8%AE%BAor%E5%AE%9E%E9%99%85.png" alt="理论or实际"></p><p>如图，推算出来的菲涅尔项和实际测量出来的往往会有很大差距，跟不用说BRDF了</p><p>如果工业上能直接测量材质的BRDF，就不需要如此复杂的理论推导而能直接使用数据了</p><p>测量BRDF的大致过程如下图所示</p><p><img src="/posts/53257/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p17-%E6%9D%90%E8%B4%A8%E4%B8%8E%E8%89%B2%E5%BD%A9/%E6%B5%8B%E9%87%8FBRDF%E5%A4%A7%E8%87%B4%E5%8E%9F%E7%90%86.png" alt="测量BRDF大致原理"></p><p>给定一个着色点，通过改变入射和出射的角度（改变光源与相机位置）进行测量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foreach outgoing direction wo</span><br><span class="line">move light to illuminate surface with a thin beam from wo</span><br><span class="line">for each incoming direction wi</span><br><span class="line">move sensor to be at direction wi from surface</span><br><span class="line">measure incident radiance</span><br></pre></td></tr></table></figure><p>如算法伪代码所示，这样测出来的BRDF是四维的，这样的测量是非常费时的</p><p>为了提高效率，我们可以尽量让材质呈各向同性</p><p>就像之前说的，这不仅可以让BRDF从四维降至三维，还能由光路可逆性再砍去一半的测量</p><p>最后，关于BRDF的储存，有一个著名的库 <code>MERL BRDF Database</code>，是三菱电子实验室和MIT合作的项目，不做细说</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（7）-渲染前沿话题</title>
      <link href="/posts/10168.html"/>
      <url>/posts/10168.html</url>
      
        <content type="html"><![CDATA[<p>多图预警</p><h3 id="高级光线传播方式"><a href="#高级光线传播方式" class="headerlink" title="高级光线传播方式"></a>高级光线传播方式</h3><p>首先需要引入数理统计中关于有偏和无偏的概念</p><p>什么是无偏估计：<a href="https://www.zhihu.com/question/22983179">https://www.zhihu.com/question/22983179</a></p><p>之前提到的蒙特卡洛方法是一种光线追踪中常用的估计方法，具体来说，是在求解渲染方程时，以特定的pdf分布对被积函数进行采样，再用采样到的样本来估计积分值的一种方法，但那时我们并没有提及什么样的pdf采样是最好的，这就涉及有偏和无偏的概念</p><p>如果样本得到的期望值与总体的期望值相等，那么这种估计就被称为无偏的，反之则有偏</p><p>除了无偏性，还有两种判断估计的准确性的评判标准——有效性和一致性（相合性）</p><p>暂且不提有效性，如果采样的样本数量趋近于无穷时，样本统计量的期望收敛于总体统计量的期望，则称这种估计是一致的</p><p>有了以上统计学概念，再继续分类来看现代图形学的几种高级光线传播方式</p><h4 id="无偏光线传播方法"><a href="#无偏光线传播方法" class="headerlink" title="无偏光线传播方法"></a>无偏光线传播方法</h4><h5 id="双向路径追踪（BDPT）"><a href="#双向路径追踪（BDPT）" class="headerlink" title="双向路径追踪（BDPT）"></a>双向路径追踪（BDPT）</h5><p>之前所说的路径追踪利用了光路可逆性，通过形成相机到光源的==单向路径==来计算光照结果</p><p>而双向路径追踪，顾名思义，就是从光源和相机分别打出一些半路径，最后连接两条半路径的端点，形成整条路径</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BDPT%E5%8E%9F%E7%90%86.png" alt="BDPT原理"></p><p>请注意，BDPT的原理看起来很简单，但实际实现起来非常困难（如果能实现，那么独立写渲染器也应该不在话下了）</p><p>这种方法适用于那些光线传播在光源一侧比较好计算的情况</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BDPT%E6%95%88%E6%9E%9C.png" alt="BDPT效果"></p><p>就如上图所示，整个场景的光源只有左上角的聚光灯和右侧打向左侧的聚光灯，其余部分都由环境光照照亮，这就意味着使用传统路径追踪打出的路径的第一个弹射点大概率是漫反射表面，反射路径弹向光源的概率小，没弹几次就被俄罗斯轮盘终止了，这就会很难计算到光源的信息，从而形成大量噪点。为了解决这个问题，从光源采样是一个优化方法，而BDPT则是另一个更高级的解决方案，从图中可以看出，双向路径追踪的效果是非常好的</p><h5 id="Metropolis光线传播"><a href="#Metropolis光线传播" class="headerlink" title="Metropolis光线传播"></a>Metropolis光线传播</h5><p>Metropolis光线传播方法主要利用了马尔科夫链做蒙特卡洛估计（Markov Chain Monte Carlo，MCMC，马尔科夫链蒙特卡洛法），这种估计方法与之前介绍的蒙特卡洛方法的主要区别在于采样方式，之前在对像素多重采样的时候，我们所用的蒙特卡洛估计都是均匀采样，而马尔科夫链通俗来讲就是在已采样样本附近生成一个新样本继续做后续估计，每个样本之间不再独立，也就是说每次对当前像素的采样都基于上次对该像素的采样，这种采样方法得到的pdf可以与被积函数形状保持基本一致，采样的效果也就比均匀采样更好</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/MLT%E5%8E%9F%E7%90%86.png" alt="MLT原理"></p><p>上图所示原理，即在已有路径（蓝）基础上加以扰动，得到新光路（橙）</p><p>注意这里是对像素采样，而不是在解渲染方程</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/MLT%E6%95%88%E6%9E%9C.png" alt="MLT效果"></p><p>从图中也明显可以看出MLT的强大</p><p>这种方法尤其适用于复杂的光线传播情况，如半掩着门的房间，或者发生焦散的水体（SDS路径，specular→diffuse→specular）等，因为这些复杂的光线传播一旦找到一条路径，就可以不断在周围找到更多的路径，从而达到以更快速度获得更高质量渲染结果的目的</p><p>但是，这不代表这种方法没有它的局限</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/MLT%E7%BC%BA%E7%82%B9.png" alt="MLT缺点"></p><p>用了这种算法之后，对于每个像素来说，其渲染时间是很难从理论上计算出来的，也就很难用来去渲染动画，并且，因为他所有的操作过程都是局部的，每个像素渲染时收敛所需的时间都不一样，这就导致图片看上去比较脏（图中砖缝尤为明显）</p><h4 id="有偏光线传播方法"><a href="#有偏光线传播方法" class="headerlink" title="有偏光线传播方法"></a>有偏光线传播方法</h4><h5 id="光子映射（Photon-Mapping）"><a href="#光子映射（Photon-Mapping）" class="headerlink" title="光子映射（Photon Mapping）"></a>光子映射（Photon Mapping）</h5><p>光源打出光线的过程可以被理解为不断打出光子的过程，光子映射（PM）就利用了这一想法</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/PM%E5%8E%9F%E7%90%86.png" alt="PM原理"></p><p>整个过程分为两步</p><ul><li>先从光源出发打出光子，让其在空间内传播散射，直到打到漫反射表面为止</li><li>然后再从摄像机打出路径，进行着色计算，着色点的亮度取决于光子的密度</li></ul><p>具体做法是对每个着色点，取其附近的N个光子，做密度估计（树状结构实现算法），$\rho=\frac{N}{A}$</p><p>A可以由球形包围盒与表面求交得到（方法不唯一）</p><p>但这又有一个问题，我们直接来看效果</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/PM%E6%95%88%E6%9E%9C.png" alt="PM效果"></p><p>很容易发现，在做密度估计的时候，N小了噪声会非常大，N大了图像又会变得模糊</p><p>这是因为光子映射本身就是一个有偏的方法，算密度应该用$\frac{N}{dA}$，而我们的密度估计时用的是$\triangle A$，$\frac{N}{dA}\neq\triangle A$，只有$\triangle A$足够小才能做到正确估计，否则多少会有点糊</p><p>为了让$dA$足够小，可以在一开始发射光子的时候就多发射点，提高采样数，那么同样多的N对应的$dA$就会相对小，也就是说，这种方法虽然有偏，但他是一致的</p><p>那么为什么不能取固定的$\triangle A$来数里面的N呢？因为这样一来$\triangle A$就锁死了，永远不会靠近$dA$，采样多，$\triangle A$里的N确实是会变多，但那也只是结果变亮而已，换句话说这样的结果是有偏且不一致的，因此我们通常采用前一种方法</p><h5 id="顶点连接-合并（VCM）"><a href="#顶点连接-合并（VCM）" class="headerlink" title="顶点连接/合并（VCM）"></a>顶点连接/合并（VCM）</h5><p>VCM（Vertex connection and merging）就是把双向路径追踪和光子映射结合起来的一种方法</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/VCM.png" alt="VCM"></p><p>双向路径追踪会发生两条子路径端点非常接近的情况（在同一个局部面积内），这时候BDPT就认为这种路径无效，就是一种浪费</p><p>对于这种情况，VCM就认为其中一条路径打过来的不是光线而是光子，用光子映射的方法把两条路径的贡献结合起来，避免了这种浪费</p><p>现实在电影行业以及许多实践中，也确实使用了VCM这种方法</p><h4 id="实时辐射度（Instant-Radiosity）"><a href="#实时辐射度（Instant-Radiosity）" class="headerlink" title="实时辐射度（Instant Radiosity）"></a>实时辐射度（Instant Radiosity）</h4><p>有时候也被称为“很多光源的算法”(VPL / many light methods)，核心思想是将每个被照亮的表面都作为虚拟的点光源来看待，再具体点，这种算法是把光源打出的光线所打到的地方作为二级光源，计算着色时遍历这些二级光源叠加计算</p><p>优点：速度快，在漫反射场景中效果很好</p><p>缺点：当虚拟光源离着色点特别近的时候，会出现反常亮点，类似漏光的现象，这和之前路径追踪对光源采样的距离平方项有关；另外，这种方法无法处理光泽材质</p><h3 id="高级外观建模方法"><a href="#高级外观建模方法" class="headerlink" title="高级外观建模方法"></a>高级外观建模方法</h3><h4 id="非表面模型"><a href="#非表面模型" class="headerlink" title="非表面模型"></a>非表面模型</h4><h5 id="散射介质"><a href="#散射介质" class="headerlink" title="散射介质"></a>散射介质</h5><p>光线进入散射介质会发生两件事——被吸收或者散射</p><p>光线走多远被吸收，由介质的吸收能力决定；光线以何种方式散射，由介质的相位函数决定</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E7%9B%B8%E4%BD%8D%E5%87%BD%E6%95%B0.png" alt="相位函数"></p><p>渲染方法：直线传播 -&gt; 散射 -&gt; 直线传播 -&gt; 散射 -&gt;  直线传播  -&gt;  … -&gt;  吸收</p><p>对每个发生散射的着色点，与光源连接，计算路径的贡献</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E6%95%A3%E5%B0%84%E4%BB%8B%E8%B4%A8%E6%B8%B2%E6%9F%93.png" alt="散射介质渲染"></p><p>电影《超能陆战队》中旧京山（San Fransokyo，三藩京，虚构城市）场景的雾效就应用了散射介质</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Big%20Hero.png" alt="Big Hero"></p><h5 id="头发-毛发"><a href="#头发-毛发" class="headerlink" title="头发/毛发"></a>头发/毛发</h5><p>先来看一个简单的模型</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Kajiya%20Kay.png" alt="Kajiya Kay"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Kajiya%20Kay%E6%95%88%E6%9E%9C.png" alt="Kajiya Kay效果"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>首先，Kajiya-Kay模型将头发丝看做一个可弯曲的圆柱，这也是之后所有其他方法的基础</p><p>然后该模型认为，光线打到头发上会呈圆锥状散射（类似specular），同时又会被散射到四面八方（类似diffuse）</p><p>可以看到，这种diffuse+specular 的模拟效果并不尽如人意，但值得肯定的是，Kajiya-Kay模型为后续模型的提出奠定了基础</p><p>后来提出的Marschner模型，在Kajiya-Kay模型基础上，得到了广泛应用</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner.png" alt="Marschner"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner%E6%95%88%E6%9E%9C.png" alt="Marschner效果"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>这个模型不再简单将头发丝视为圆柱，而是更进一步认为“圆柱”由“角质层”和“皮质层”组成</p><p>而光线的作用过程也更加复杂，总共分为三类：</p><ul><li>T：直接反射</li><li>TT：穿进“皮质层”，再从“角质层”穿出</li><li>TRT：穿进“皮质层”，在内部反射，再从“角质层”穿出</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">T</th><th style="text-align:center">TT</th><th style="text-align:center">TRT</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner%20(2" alt="Marschner (2)">.png)</td><td style="text-align:center"><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner%20(1" alt="Marschner (1)">.png)</td><td style="text-align:center"><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Marschner%20(3" alt="Marschner (3)">.png)</td></tr></tbody></table></div><p>可以看到效果还是非常不错的</p><p>以上模型都是对人类头发来说的，那么更进一步，应用到动物毛发效果如何？</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%8A%A8%E7%89%A9%E6%AF%9B%E5%8F%91.png" alt="动物毛发"></p><p>明显不一样，显然右图更接近真实我们想要的效果</p><p>下面从生物学角度深入探讨人类动物毛发的结构区别</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%8A%A8%E7%89%A9%E6%AF%9B%E5%8F%91%E7%94%9F%E7%89%A9%E5%AD%A6%E7%BB%93%E6%9E%841.png" alt="动物毛发生物学结构1"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%8A%A8%E7%89%A9%E6%AF%9B%E5%8F%91%E7%94%9F%E7%89%A9%E5%AD%A6%E7%BB%93%E6%9E%842.png" alt="动物毛发生物学结构2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>除了角质和皮质，毛发还具有髓质结构，并且动物毛发的髓质明显比人类毛发的髓质粗不少</p><p>于是我们的闫令琪老师就提出了一种双层圆柱模型来模拟这种情况</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/double%20cylinder.png" alt="double cylinder"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/double%20cylinder%E6%95%88%E6%9E%9C.png" alt="double cylinder效果"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>该模型在Marschner模型的T，TT，TRT基础上又加了两个计算项：TTs和TRTs</p><ul><li>TTs：TT传进“皮质层”时打到髓质发生散射，再从“角质层”穿出</li><li>TRTs：TRT进入“皮质层”时发生发射，来回打到两次髓质，最后从“角质层”穿出</li></ul><p>可以看到，髓质对毛发色彩表现的影响还是非常大的，相关理论已被应用到《狮子王》《猩球崛起》等影视作品中</p><h5 id="颗粒材质"><a href="#颗粒材质" class="headerlink" title="颗粒材质"></a>颗粒材质</h5><p>砂砾，谷物，粉末这些材质都属于颗粒材质，这些材质渲染的计算量非常大，但可以做一些简化，用百分比来表示单个渲染单元的组成成分，不过即使如此，颗粒材质至今仍然没有得到有效的优化</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E9%A2%97%E7%B2%92%E6%9D%90%E8%B4%A8.png" alt="颗粒材质"></p><h4 id="表面模型"><a href="#表面模型" class="headerlink" title="表面模型"></a>表面模型</h4><h5 id="半透明材质"><a href="#半透明材质" class="headerlink" title="半透明材质"></a>半透明材质</h5><p>玉石这类材质是半透明材质（Translucent）的典型代表，注意translucent和semitransparent的区别，这里说的半透明是光线在材质内发生散射，最后从另一个点出来，对应到物理，这种现象被称为次表面散射</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E6%AC%A1%E8%A1%A8%E9%9D%A2%E6%95%A3%E5%B0%84.png" alt="次表面散射"></p><p>现实中可能用到次表面散射的情景有如渲染人耳，牛奶等材质，可以看到，光线通过人耳后并未被完全阻挡，而是表现为红光</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF.png" alt="BSSRDF"></p><p>在图形学中，通常使用BSSRDF方程来描述次表面散射，它可以被认为是BSDF的拓展，BSDF计算贡献时只会计算当前着色点，而BSSRDF还需要考虑其他渲染单元射入的光线，因为这些光线在材质内发生散射后，同样有可能对当前着色点的能量造成影响</p><p>来看看BSSRDF的效果</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF%E6%95%88%E6%9E%9C1%EF%BC%881%EF%BC%89.png" alt="BSSRDF效果1（1）"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF%E6%95%88%E6%9E%9C1%EF%BC%882%EF%BC%89.png" alt="BSSRDF效果1（2）"></th></tr></thead><tbody><tr><td><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF%E6%95%88%E6%9E%9C2.png" alt="BSSRDF效果2"></td><td><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/BSSRDF%E6%95%88%E6%9E%9C3.png" alt="BSSRDF效果3"></td></tr></tbody></table></div><p>在应用时，我们也可以用Dipole方法做近似，即在表面上下各假设一个虚拟光源，来模拟次表面散射的光照效果</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/Dipole%E8%BF%91%E4%BC%BC.png" alt="Dipole近似"></p><h5 id="布料模拟"><a href="#布料模拟" class="headerlink" title="布料模拟"></a>布料模拟</h5><p>我们先来看布料的微观组成：纤维 -&gt; 纱线 -&gt; 布料</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%B8%83%E6%96%99%E7%BB%84%E6%88%90.png" alt="布料组成"></p><p>其中编制方法还分woven和knitted两种，不再细说</p><p>下面来看布料模拟中常用的几种方法，最简单粗暴的，直接根据不同布料给出BRDF，但这种方法无法渲染天鹅绒等材质</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F2.png" alt="布料模拟2"></p><p>因为天鹅绒本身就不能归为表面模型，所以接下去我们直接把布料看做是空间中的微小体积的集合，当做散射介质就像渲染云雾那样去渲染布料，这个计算量是肉眼可见的大</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F3.png" alt="布料模拟3"></p><p>当这些体积被细分到纤维级别时，计算量是难以想象的，但效果也无限接近真实</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F4.png" alt="布料模拟4"></p><h5 id="细节模型"><a href="#细节模型" class="headerlink" title="细节模型"></a>细节模型</h5><p>至今为止讲的所有真实感渲染都忽略了一件事，那就是现实世界中的物体大多数都是不完美的，多多少少都会带点瑕疵，比如风雨灰尘在车漆上留下的细微划痕，或物件老化磨损，等等等等，现实世界的情况往往比理论更加复杂</p><p>想要在渲染时考虑这些微小的因素，我们在之前提到微表面模型的时候有强调过使用法线分布来描述微观表面的起伏，但那时候说的法线分布，大部分是正态分布之类的简单分布，这并不是我们真正想要的</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E5%9B%9E%E9%A1%BE.png" alt="微表面回顾"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E5%9B%9E%E9%A1%BE2.png" alt="微表面回顾2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>我们当然可以人为的往这些分布上加一些细节扰动，但想真正把它渲染出来是非常困难的</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E7%BB%86%E8%8A%82%E6%A8%A1%E5%9E%8B.png" alt="细节模型"></p><p>闫神：《关于自己的头像是自己渲染了一个月的研究结果这档事》</p><p>除此之外，细节模型还存在一个问题，就是在计算镜面反射时，如果法线分布比较复杂，就很难建立有效的，从光源到微表面再到摄像机的光线通路，为了解决这个问题，我们让每个像素打出路径时都对应一个范围，如图，把整块范围内的法线分布整合起来得到P-NDF，从而简化计算</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/P%20NDF1.png" alt="P NDF1"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/P%20NDF2.png" alt="P NDF2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>单独看这些P-NDF，单个像素覆盖的微表面范围大小不同，P-NDF所呈现出来的特点也各不相同</p><p>当范围选取的大，P-NDF会趋于符合一些统计学规律，而当范围选取的小，这些P-NDF则会展现出一些很奇妙的形态</p><p>并且，不同类型的法线分布也会得到不同的P-NDF图像，各向同性的P-NDF与各向异性材质完全不同</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/P%20NDF3.png" alt="P NDF3"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/P%20NDF4.png" alt="P NDF4"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>再深入，就要考虑到微表面上光的波粒二象性了，比如干涉衍射，这些太复杂，并且只有在很小的尺度下，波动性才会起作用，在这里就不细说了，但可以看看考虑了波动光学的BRDF和几何光学BRDF的区别：</p><div class="table-container"><table><thead><tr><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E5%BE%AE%E8%A1%A8%E9%9D%A2%E7%9A%84%E6%B3%A2%E5%8A%A8%E6%80%A7.png" alt="微表面的波动性"></th><th><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E8%80%83%E8%99%91%E5%BE%AE%E8%A1%A8%E9%9D%A2%E7%9A%84%E6%B3%A2%E5%8A%A8%E6%80%A7%E7%9A%84BRDF.png" alt="考虑微表面的波动性的BRDF"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>结果和几何光学极为相近，但它的图像是不连续的</p><h4 id="程序化生成材质"><a href="#程序化生成材质" class="headerlink" title="程序化生成材质"></a>程序化生成材质</h4><p>之前再说纹理的时候就有简单提到过程序纹理，对应到材质这块，这个过程就是通过程序来指导材质的生成</p><p>这里的程序化生成并没有真正的生成材质，而是将这个材质信息定义为空间中的一些噪声函数，在后续生成时动态的查询它</p><p>（存储三维的纹理会耗费很多内存）</p><p>噪声函数的应用非常广泛，比如可以二值化定义车锈</p><p><img src="/posts/10168/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p18-%E6%B8%B2%E6%9F%93%E5%89%8D%E6%B2%BF%E8%AF%9D%E9%A2%98/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90%E8%BD%A6%E9%94%88.png" alt="程序化生成车锈"></p><p>现在应用最广泛的噪声函数是柏林噪声（Perlin Noise），有了这些噪声函数，我们不仅可以程序化生成材质，还可以程序化生成地形，程序化生成水面等，另外，由于这个噪声函数是定义在空间中的，所以如果我们在空间里切割一块木头（或其他材质），是能看到里面的纹理的，这是二维材质做不到的</p><p>Substance Designer是目前工业上用来程序化生成材质的工具之一，它并非如上所述定义了函数供后续查询，而是直接生成了材质拿去用…</p><p>这个工具也渐渐的成为了目前游戏TA必备的工具技能之一</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（8）-相机，透镜，光场</title>
      <link href="/posts/5531.html"/>
      <url>/posts/5531.html</url>
      
        <content type="html"><![CDATA[<p>这一章内容比较独立，相较之前是一个全新的话题（个人认为老师这块讲的有点乱，所以对顺序做了一定调整）</p><h3 id="成像"><a href="#成像" class="headerlink" title="成像"></a>成像</h3><p>成像方法大体上可以分为合成成像（Synthesis）和捕捉成像（Capture）两种，我们之前讲的光栅化成像和光线追踪就都属于合成方法成像，而另一类捕捉成像，则是直接捕捉现实图片，相机成像就是一个典型的例子</p><p>关于其他的一些成像方法，如研究光在极短时间内如何传播（Transient Imaging）等，目前也正在研究之中…</p><p>整个成像的范畴更多是在计算摄影学（Computational Photography）中研究，算是计算机图形学的一个交叉学科</p><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><h4 id="小孔成像与针孔相机"><a href="#小孔成像与针孔相机" class="headerlink" title="小孔成像与针孔相机"></a>小孔成像与针孔相机</h4><p>最早人们从小孔成像开始研究相机，以小孔成像为原理的相机叫做针孔相机</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%B0%8F%E5%AD%94%E6%88%90%E5%83%8F.png" alt="小孔成像"></p><p>针孔相机拍出的东西是没有深度可言的，像的所有地方都是锐利的，而透镜成像则会产生虚化，这在之后会进一步展开讨论</p><p>之前光线追踪所用的相机就可以看做是一个针孔相机模型，所以我们的渲染结果得不到景深的模糊效果</p><p>如果想要得到带有景深的渲染效果，则必须考虑如何在计算机中模拟光线和透镜的作用</p><p>注意，成像过程中，透镜或小孔是不可或缺的，因为我们如果要使我们成的像清晰，必须清楚的区分来自各个不同方向的光，如果直接把感光元件放在捕捉对象面前，感光元件上任何一个点都会收集到来自不同方向的光照信息，叠加计算记录的就是Irradiance，而Irradiance是没有方向的概念的，成像自然会糊。换句话说，传感器没法直接记录Radiance，所以只能依靠透镜或小孔来辅助</p><p>（现实中是存在直接记录Radiance的相机的（光场相机），这在后面会提到）</p><h4 id="传感器与视场"><a href="#传感器与视场" class="headerlink" title="传感器与视场"></a>传感器与视场</h4><p>传感器（sensor）（or感光元件）是用来捕捉记录光线信息的部件，它与胶片（film）在渲染中并不完全等价，在渲染器中，sensor收集信息，film决定储存格式，但大多数时候我们认为他们是一种东西</p><p>视场（field of view，FoV）指的是相机的拍摄范围，其大小与传感器大小以及焦距有关</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%A7%86%E5%9C%BA1.png" alt="视场1"></p><p>两个参数共同作用下视场大小是很难被衡量的，所以我们通常固定传感器的大小，通过变换焦距来控制其大小（现实中一般相机通常为35mm），这也是市面上买单反镜头有焦距的区别而没有传感器大小区别的原因</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%A7%86%E5%9C%BA2.png" alt="视场2"></p><p>总结来说，传感器大小相同，焦距越大，视场越窄；焦距相同，传感器越大，视场越宽；视大小相同场，焦距和传感器成比例</p><p>下面一系列参数得到的视场大小是相同的，不同传感器对应了不同的设备</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%A7%86%E5%9C%BA4.png" alt="视场4"></p><h4 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h4><p>理论定义：曝光值$H=T\times E$</p><p>T表示曝光时间，主要由快门控制</p><p>E表示Irradiance，由光圈和焦距共同决定</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%9B%9D%E5%85%89%E5%80%BC%E5%AE%9A%E4%B9%89.png" alt="曝光值定义"></p><p>摄影中控制曝光值主要有三大要素：快门、光圈、感光度</p><h5 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h5><p>快门是用来控制光线照射感光元件的时间的部件</p><p>工作动画：</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%BF%AB%E9%97%A8%E5%8A%A8%E7%94%BB.gif" alt="快门动画"></p><p>快门主要有两个作用：①影响曝光；②影响被摄影物体的形态</p><p><u>影响曝光：</u></p><p>快门打开时间越长（更长的曝光时间），相机记录的光线就越多，照片越亮，反之则光线少，照片较暗</p><p>另外，更长的曝光时间也越容易得到运动模糊的效果，就类似光栅化中的反走样，只不过它是对于时间采样的反走样</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%9B%9D%E5%85%89%E6%97%B6%E9%97%B4.png" alt="曝光时间"></p><p>运动模糊并不总是有害的，有时候我们为了表达被拍摄物体的速度感，会刻意的希望加上一些运动模糊</p><p><u>影响被摄影物体的形态：</u></p><p>快门关闭和打开的过程也是需要时间的，我们定义<strong>快门速度（shutter speed）</strong>这一参数来衡量它</p><p>快门速度越快，被拍摄的高速物体越清晰，反之则会有一定形变</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%BF%AB%E9%97%A8%E9%80%9F%E5%BA%A6.jpg" alt="快门速度"></p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%BF%AB%E9%97%A8%E9%80%9F%E5%BA%A6.png" alt="快门速度"></p><h5 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h5><p>光圈是一种仿照人类瞳孔的仿生学的设计，由多个小叶片相互重叠而成的光孔，调节其开闭可以控制感光元件的受光量</p><p>光圈越大，进光量越多，照片越亮，反之越暗</p><p>一般通过F数来表示其大小，F数的明确定义在后面会提及，这里可以先暂时理解为光圈直径的倒数</p><div class="table-container"><table><thead><tr><th><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E5%9C%881.jpg" alt="光圈1"></th><th><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E5%9C%883.jpg" alt="光圈3"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E5%9C%882.jpg" alt="光圈2"></p><p>除此之外，光圈还会影响画面景深，相关内容在之后薄透镜近似中也会详细说明</p><h5 id="感光度（ISO）"><a href="#感光度（ISO）" class="headerlink" title="感光度（ISO）"></a>感光度（ISO）</h5><p>感光度表示的是相机感光元件对光线的敏感程度</p><p>感光度越高，相机感光元件对光线敏感程度越强，照片越亮；感光度越低，相机感光元件对光线敏感程度越弱，照片越暗</p><p>但是，随着感光度的增加，感光元件对一些噪声的敏感程度也随之增加，画面就会逐渐出现一些噪点</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%84%9F%E5%85%89%E5%BA%A6.png" alt="感光度"></p><p>总结来说，快门、光圈、感光度对曝光的影响总结如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">快门</th><th style="text-align:center">影响曝光和被摄物体形态</th></tr></thead><tbody><tr><td style="text-align:center"><strong>光圈</strong></td><td style="text-align:center"><strong>影响进光量和画面景深</strong></td></tr><tr><td style="text-align:center"><strong>感光度</strong></td><td style="text-align:center"><strong>影响曝光和画质</strong></td></tr></tbody></table></div><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%BD%B1%E5%93%8D%E6%9B%9D%E5%85%89%E4%B8%89%E8%A6%81%E7%B4%A0.png" alt="影响曝光三要素"></p><p>相关概念详细可参考：</p><p><a href="https://zhuanlan.zhihu.com/p/134166476">https://zhuanlan.zhihu.com/p/134166476</a></p><p>光圈和快门共同控制<strong>进光量</strong>：</p><p>以下光圈大小和快门速度参数所控制的进光量相同，可以看到光圈F数的平方与快门速度成正比，因为对于进光量，应该算的是光圈大小，也就是面积，而不是直径</p><script type="math/tex; mode=display">F^2\propto Shutter\ Speed</script><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%BF%9B%E5%85%89%E9%87%8F.png" alt="进光量"></p><p>实际应用方面，在拍摄流光轨迹、延时摄影等慢门题材时，宜用慢速快门和小光圈，而在拍摄高速题材时，宜用高速快门和大光圈，具体可以参照链接最后的部分</p><h3 id="薄透镜近似"><a href="#薄透镜近似" class="headerlink" title="薄透镜近似"></a>薄透镜近似</h3><p>真实的透镜并不会如我们想的那么理想，比如下图中的透镜，它无法正确的将光线聚焦为一点，从而出现像差（Aberrations）</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%83%8F%E5%B7%AE.png" alt="像差"></p><p>并且，现实中我们用的相机一般用的都不是单个透镜，而是一个透镜组，这比理想情况复杂的多，在此不做过多讨论</p><p>这里我们只考虑理想化的透镜：</p><ul><li>所有进入透镜的平行光线都通过透镜的焦点</li><li>穿过焦点的所有光线在通过透镜后将是平行的</li><li>焦距可以任意改变（实际上用透镜组改变焦距)</li></ul><h4 id="薄透镜方程"><a href="#薄透镜方程" class="headerlink" title="薄透镜方程"></a>薄透镜方程</h4><p>这个方程属于初中内容，简单推导如下：</p><div class="table-container"><table><thead><tr><th><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%96%84%E9%80%8F%E9%95%9C%E6%96%B9%E7%A8%8B1.png" alt="薄透镜方程1"></th><th><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%96%84%E9%80%8F%E9%95%9C%E6%96%B9%E7%A8%8B2.png" alt="薄透镜方程2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><script type="math/tex; mode=display">\frac{h_o}{z_o-f}=\frac{h_i}{f}\Rightarrow \frac{h_o}{h_i}=\frac{z_o-f}{f}\ \ ①\\\frac{h_o}{f}=\frac{h_i}{z_i-f}\Rightarrow \frac{h_o}{h_i}=\frac{f}{z_i-f}\ \ ②\\联立①，②:\ \ \frac{z_o-f}{f}=\frac{f}{z_i-f}\\f^2=(z_o-f)(z_i-f)\\z_oz_i-(z_o+z_i)f+f^2=f^2\\\frac{1}{f}=\frac{1}{z_o}+\frac{1}{z_i}</script><p>动态演示链接：</p><p><a href="http://graphics.stanford.edu/courses/cs178-10/applets/gaussian.html">http://graphics.stanford.edu/courses/cs178-10/applets/gaussian.html</a></p><h4 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h4><h5 id="CoC"><a href="#CoC" class="headerlink" title="CoC"></a>CoC</h5><p>当传感器不在物体真正的成像平面上时，光线会继续沿直线传播，在感光元件上形成一个弥散圈，这个圈就叫CoC（Circle of Confusion）</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/CoC.png" alt="CoC"></p><p>上图的关系式告诉我们，光圈越大，越容易出现模糊</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/CoC2.png" alt="CoC2"></p><h5 id="F数"><a href="#F数" class="headerlink" title="F数"></a>F数</h5><p>之前我们简单理解F数为光圈直径的倒数，实际上，其确切的定义是焦距除以光圈直径</p><p>F数为n的光圈一般记作f/n，如下图中F数为2，则记作f/2</p><p>常用的F数还有f/1.4，f/2.8，f/4.6，f/5.0，f/8，f/11，f/16，f/22，f/32等</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/F%E6%95%B01.png" alt="F数1"></p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/F%E6%95%B02.png" alt="F数2"></p><p>上图公式进一步说明，拍摄带有虚化的照片要用大光圈，而拍摄清晰照片要用小光圈</p><h5 id="景深定义"><a href="#景深定义" class="headerlink" title="景深定义"></a>景深定义</h5><p>在实际拍摄过程中，如果要得到足够清晰的像，其实并不需要将物体完美对焦在焦点平面上，只要CoC大致小于胶片传感器上像素的大小，就可以被认为是成功对焦了，如此一来，一个物体可以成功对焦就有了一个距离范围，这个范围就是景深（DoF，depth of field）</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%99%AF%E6%B7%B11.png" alt="景深1"></p><p>景深公式推导如下：</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E6%99%AF%E6%B7%B12.png" alt="景深2"></p><p>动态演示链接：</p><p><a href="http://graphics.stanford.edu/courses/cs178/applets/dof.html">http://graphics.stanford.edu/courses/cs178/applets/dof.html</a></p><h4 id="光线追踪中的薄透镜近似"><a href="#光线追踪中的薄透镜近似" class="headerlink" title="光线追踪中的薄透镜近似"></a>光线追踪中的薄透镜近似</h4><p>之前在做光线追踪的时候我们的相机都是假设为一个小点，即默认小孔成像，如此成像得到的结果是完全清晰、没有景深的</p><p>但现在我们就可以通过模拟薄透镜来近似做出景深的效果，如图</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E8%BF%BD%E8%96%84%E9%80%8F%E9%95%9C%E8%BF%91%E4%BC%BC.png" alt="光追薄透镜近似"></p><p>首先我们要确定薄透镜的大小和位置，由此确定光圈和焦距，然后在透镜和传感器（像素屏幕）上分别采样，并连接成一条线</p><p>这条光线经过折射后偏转，打到物体的x’’’处，计算x‘’‘到x’’的radiance并记录在x’处，这就是一条光追路径的薄透镜近似流程</p><h3 id="光场"><a href="#光场" class="headerlink" title="光场"></a>光场</h3><p>关于光场的英文名称，Light Field / Lumigraph 两个词其实是指的同一个东西，在这里我们用Light Field</p><p>首先来看我们是怎么看这个世界的</p><div class="table-container"><table><thead><tr><th><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E%E5%8E%9F%E7%90%861.png" alt="虚拟现实原理1"></th><th><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E%E5%8E%9F%E7%90%862.png" alt="虚拟现实原理2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>我们眼中的三维世界其实可以类比为一张图片，现实中如果我们在一张图片或者一块幕布上直接记录我们这一刻所看到的所有信息，并把它放在我们的眼前，我们感受到的结果是完全一样的，这也就是虚拟现实的实现原理</p><h4 id="全光函数"><a href="#全光函数" class="headerlink" title="全光函数"></a>全光函数</h4><p>全光函数是记录光线特征信息的函数，一般来说这些特征可以被分为四类：位置，角度，波长，时间</p><div class="table-container"><table><thead><tr><th style="text-align:center">$P(\theta,\phi)$</th><th style="text-align:center">最简单的全光函数</th></tr></thead><tbody><tr><td style="text-align:center">$P(\theta,\phi,\lambda)$</td><td style="text-align:center"><strong>引入颜色</strong></td></tr><tr><td style="text-align:center">$P(\theta,\phi,\lambda,t)$</td><td style="text-align:center"><strong>引入时间，可以类比看电影</strong></td></tr><tr><td style="text-align:center">$P(\theta,\phi,\lambda,t,V_X,V_Y,V_Z)$</td><td style="text-align:center"><strong>引入观测位置坐标，相当于全息电影</strong></td></tr></tbody></table></div><h4 id="采样全光函数"><a href="#采样全光函数" class="headerlink" title="采样全光函数"></a>采样全光函数</h4><p>所谓光场，就是对全光函数的采样，可以理解为全光函数的一个子集，因为现实中光线的颜色特征通常由RGB通道记录，而时间信息通常由动画帧来记录，所以对于光场来说只需要关注方向和位置即可，这样一来，原本七维的信息就被降至为了五维</p><script type="math/tex; mode=display">P(\theta,\phi,V_X,V_Y,V_Z)</script><p>后来，人们发现只需要四维的信息（二维位置信息uv + 二维方向信息θφ）就可以定义光线的方向和位置；再后来，索性方向信息也不要了，直接定义两个平面，两平面上任意两点连线就可以表示空间中任意一条光线</p><div class="table-container"><table><thead><tr><th><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/uvst1.png" alt="uvst1"></th><th><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/uvst2.png" alt="uvst2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>光场降维过程的通俗解释：<a href="https://www.zhihu.com/question/393235387/answer/1215239335">https://www.zhihu.com/question/393235387/answer/1215239335</a></p><p>对相机来说，uv可以理解为传感器 / 成像平面，st可以理解为镜头 / 光圈平面</p><p>进一步用采样来理解这个过程，如图</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/uvst3.png" alt="uvst3"></p><p>1° 固定(u,v)，对st平面采样，此时的采样结果可以理解为从uv上某点沿各个方向观察世界的结果</p><p>2° 固定(s,t)，对uv平面采样，此时的采样结果可以理解为从uv上各个不同的点以不同角度观察世界中某一点的结果</p><p>更多关于这方面的理解可以参考：<a href="https://zhuanlan.zhihu.com/p/24982662">https://zhuanlan.zhihu.com/p/24982662</a></p><p>现实中模拟这种方式记录光场，有斯坦福的相机阵列（Stanford Multi-Camera Array），另外，自然界中苍蝇的复眼也是用类似的方式来感知外界信息的，也就是说苍蝇所接受到的信息不是Irradiance，而是经过复眼分光的Radiance信息</p><h4 id="光场相机"><a href="#光场相机" class="headerlink" title="光场相机"></a>光场相机</h4><p>光场相机顾名思义就是能记录光场的相机，它最重要的功能在于它支持先拍照，然后在后期重新对焦</p><p>原理：将原本的成像面的每个像素都换成微透镜（相当于st），再在成像面后面真正的去使用传感器记录信息（相当于uv）</p><p>其实记录之前还有一个校正的过程，在这里不做细说</p><p><img src="/posts/5531/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E7%9B%B8%E6%9C%BA%EF%BC%8C%E9%80%8F%E9%95%9C%EF%BC%8C%E5%85%89%E5%9C%BA/%E5%85%89%E5%9C%BA%E7%9B%B8%E6%9C%BA%E5%8E%9F%E7%90%86.png" alt="光场相机原理"></p><p>普通相机的传感器像素记录的是irradiance，但是对于光场相机来说，它们记录的分光之后的分量，也就是记录的是Radiance（感觉光场相机就是由昆虫复眼产生的灵感造出来的）</p><p>那么，我们又要怎么通过光场相机记录的光场信息得到最后的相片呢？</p><p>很简单，对于每个微透镜，在经过它的光线中只选择一条，这样每个微透镜就都对应了一个值，然后把这个值作为当前传感器像素的值</p><p>如图所示，可以统一选择最下面的光线，也可以选择中间那根，这样就可以实现虚拟的移动相机的位置，并且这种方式得到的光照信息也是正确的（并不是简简单单的平移图像）</p><p>选光线的步骤称为重新聚焦，可以参考：<a href="https://zhuanlan.zhihu.com/p/24983091">https://zhuanlan.zhihu.com/p/24983091</a></p><p>目前的光场相机也有它的局限：</p><ul><li><p>分辨率不足，光场相机的每个像素都相当于要记录一个像素组，在同样的胶片尺寸下，光场相机的分辨率往往会很低</p></li><li><p>成本高、难设计，对仪器的精密程度大大提高，就比如微透镜组</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（9）-颜色与感知</title>
      <link href="/posts/28984.html"/>
      <url>/posts/28984.html</url>
      
        <content type="html"><![CDATA[<h3 id="颜色的物理学基础"><a href="#颜色的物理学基础" class="headerlink" title="颜色的物理学基础"></a>颜色的物理学基础</h3><p>人们对颜色的研究是从牛顿三棱镜色散实验开始的，自此之后人们就意识到有色光是不同波长的光混合起来的结果这一事实</p><p>光之所以会发生色散是因为不同波长的光具有不同的折射率，所有经过色散得到的单色光按波长大小依次排列频谱称为光谱，而图形学仅关心光谱中的可见光（波长范围400~700nm）</p><p>在光谱的基础上，我们再提出一个更准确的概念，用<strong>谱功率密度</strong>来描述光线在不同波长的强度分布，如图</p><p><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/SPD1.png" alt="SPD1"></p><p>SPD具有==线性的性质==，如果两个不同光线叠加，那么他们的谱功率密度分布就是他们各自的SPD相加的结果</p><p><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/SPD2.png" alt="SPD2"></p><h3 id="颜色的生物学基础"><a href="#颜色的生物学基础" class="headerlink" title="颜色的生物学基础"></a>颜色的生物学基础</h3><p>从生物学角度看色彩，我们发现颜色是人类的感知，而并不是光线本身的属性，同样的光线在其他动物眼里呈现的色彩是不一样的，正是因为人类具有丰富的视觉细胞，才能感受到不同波长的光所组成的多彩的世界</p><p>来看看生物学上关于人类的视觉器官的结构：</p><div class="table-container"><table><thead><tr><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E7%9C%BC%E7%90%83%E7%BB%93%E6%9E%84.png" alt="眼球结构"></th><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E8%A7%86%E8%A7%89%E7%BB%86%E8%83%9E.png" alt="视觉细胞"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>人类眼球可以类比为一个摄像机，晶状体就相当于透镜，视网膜相当于传感器，而调整焦距的过程是由肌肉拉扯晶状体来完成的</p><p>在视网膜上有各种感光细胞，总体上分为视锥细胞和视杆细胞两类，视杆细胞用来感知光强，视锥细胞感知颜色</p><p>视锥细胞还可以进一步分为S，M，L三类，不同的视锥细胞对不同波长的光的敏感度不同，而不同人的这三种视锥细胞的分布也不同，这也说明了在不同人眼里看到的世界是截然不同的</p><div class="table-container"><table><thead><tr><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/SML1.png" alt="SML1"></th><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/SML2.png" alt="SML2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>对于一条光线，人眼这三种视锥细胞感知到的结果，分别都是==细胞对波长的响应程度==和==谱功率密度==乘积的积分</p><p>如此得到对应的SML值后，将其相加混合（格拉斯曼定律），就得到了最后我们感觉到的颜色</p><p><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E4%B8%89%E8%89%B2%E6%BF%80%E5%8A%B11.png" alt="三色激励1"></p><p>人眼处理外界颜色信息的过程：</p><p>光线（带有spd信息）    →    视锥细胞将spd转化成sml    →    大脑将接受到的sml与感觉到的颜色一一对应</p><p><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E4%B8%89%E8%89%B2%E6%BF%80%E5%8A%B12.png" alt="三色激励2"></p><p>也就是说，人所感知到的颜色信息并不是光线本身的spd属性，而是视锥细胞sml所接受到的信息</p><h3 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h3><h4 id="同色异谱"><a href="#同色异谱" class="headerlink" title="同色异谱"></a>同色异谱</h4><p>既然我们感受到的不是spd，那理论上不同spd的光也有可能被人眼处理为相同的颜色，这种现象是实际存在的，即我们所说的“同色异谱”</p><p>正是因为有这个现象，我们才能通过计算机进行颜色匹配，从而调和不同光谱来模拟我们想要得到的颜色</p><p><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E5%90%8C%E8%89%B2%E5%BC%82%E8%B0%B1.png" alt="同色异谱"></p><h4 id="色匹配函数"><a href="#色匹配函数" class="headerlink" title="色匹配函数"></a>色匹配函数</h4><p>色匹配函数其实是建立在实验基础上的</p><p>实验过程大致是，用一块不透明挡板将一个屏幕分割为两个区域，左边照射要被匹配的颜色的光线，右边同时用rgb三种颜色的光同时照射，然后调节右边三种颜色光源的强度，直到左右两边的颜色看上去一样为止，随后记录对应需要的rgb强度，如此反复，将光谱上所有颜色依次匹配，最后得到曲线就是色匹配函数——==CIE-RGB==</p><p><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/CIERGB.png" alt="CIERGB"></p><p>这时候我们发现，红色曲线部分地方出现的负值，这是因为在一些情况下，无论怎么调节右侧的光源强度，都无法得到期望的颜色，只能通过在左边的颜色上加上三色光的一种或几种来完成匹配，在左边加，就等价于在右边减，所以出现负值是在情理之中的</p><h4 id="CIE-XYZ空间"><a href="#CIE-XYZ空间" class="headerlink" title="CIE-XYZ空间"></a>CIE-XYZ空间</h4><p>虽然色匹配函数允许出现负值，但负数的出现多少对计算会造成一些影响，为了消除这种影响，国际照明委员会（CIE）就对原来的色匹配函数做了一次线性变换，提出了一种所有分量都为正值的颜色空间，就是我们所谓的CIE-XYZ空间</p><p><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/CIEXYZ.png" alt="CIEXYZ"></p><p>因为只是在原来基础上做了一次线性空间的变换，所以既然CIE-RGB可以表示所有颜色，CIE-XYZ也可以，二者之间是完全等价的</p><h4 id="色域-amp-屏幕色彩空间"><a href="#色域-amp-屏幕色彩空间" class="headerlink" title="色域&amp;屏幕色彩空间"></a>色域&amp;屏幕色彩空间</h4><p>由上我们知道，任何一个颜色都能被三个参数的线性组合表示出来，也就是说颜色本身属于一种三维的信息</p><p>为了更方便表示，我们通常会将其降至二维，通过归一化使三个参数的和为1，这时候就只需要两个参数就能表示颜色空间中任意一个颜色了，而这种表示方式所得到的颜色集合，我们就称之为色域</p><p><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E8%89%B2%E5%9F%9F.png" alt="色域"></p><p>但是到这里为止，我们还是无法将颜色显示在计算机的屏幕上，因为计算机屏幕并不是人眼，他所支持的色域通常会比可见光色域小得多，那这时候我们就必须把计算得到的 XYZ 转换到屏幕空间中（空间变换和gamma校正），而因为不同设备的转码方式不同，就形成了不同设备各自的色彩空间</p><p>由上图我们可以直观的看到不同色彩空间所能表示的色域范围</p><p>常见的色彩空间有sRGB，Adobe RGB等，还有一些其他的RGB空间，比如用色调、饱和度、亮度表示的色彩空间HSV，和CIE用互补色表示的色彩空间等，就不再一一列举了</p><div class="table-container"><table><thead><tr><th style="text-align:center">HSV</th><th style="text-align:center">CIE-LAB</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/HSV.png" alt="HSV"></td><td style="text-align:center"><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/CIELAB.png" alt="CIELAB"></td></tr></tbody></table></div><p>关于CIE-LAB的互补色，还可以多提几句，美术中的互补色通常指红黄蓝（RYB）色相环中成180°角的两种颜色，这两种颜色放在一起会给人一种强烈对比的色觉，并有时会产生主观上的感知错觉（详例见ppt），这进一步证明色彩是人的感知，而不是光本身的属性</p><p>关于这方面知识更为系统的解释：</p><p><a href="https://zhuanlan.zhihu.com/p/24214731">https://zhuanlan.zhihu.com/p/24214731</a></p><p><a href="https://zhuanlan.zhihu.com/p/24281841">https://zhuanlan.zhihu.com/p/24281841</a></p><p>gamma校正：</p><div class="table-container"><table><thead><tr><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/gamma%20(1" alt="gamma (1)">.jpg)</th><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/gamma%20(3" alt="gamma (3)">.jpg)</th><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/gamma%20(2" alt="gamma (2)">.jpg)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><a href="https://zhuanlan.zhihu.com/p/36581276">https://zhuanlan.zhihu.com/p/36581276</a></p><p><a href="https://blog.csdn.net/candycat1992/article/details/46228771/">https://blog.csdn.net/candycat1992/article/details/46228771/</a></p><p>关于三原色：</p><p>光学三原色和绘画三原色是不一样的，光学三原色是红绿蓝rgb，美术三原色是品红，黄和靛青</p><p>光学三原色是加色模型，美术三原色是减色模型</p><div class="table-container"><table><thead><tr><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E4%B8%89%E5%8E%9F%E8%89%B21.png" alt="三原色1"></th><th><img src="/posts/28984/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p19-%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/%E4%B8%89%E5%8E%9F%E8%89%B22.png" alt="三原色2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>右图为UE中材质结点关于加色模型和减色模型的一个直观展示</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES101个人笔记（10）-动画与仿真</title>
      <link href="/posts/19430.html"/>
      <url>/posts/19430.html</url>
      
        <content type="html"><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><h4 id="动画历史"><a href="#动画历史" class="headerlink" title="动画历史"></a>动画历史</h4><p>动画在最开始是作为一种沟通交流而存在的工具，它所传递的信息更富于美学意义</p><p>在图形学中，动画可以被认为是对3d建模和几何在时间上的拓展（升维）</p><h5 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h5><div class="table-container"><table><thead><tr><th style="text-align:center">3200BC-远古时期</th><th style="text-align:center">人类壁画——Shahr-e Sukhteh, 伊朗</th></tr></thead><tbody><tr><td style="text-align:center">1931</td><td style="text-align:center">Phenakistoscope圆盘，通过转动圆盘来做动画</td></tr><tr><td style="text-align:center">1878</td><td style="text-align:center">第一部电影——Sallie Gardner</td></tr><tr><td style="text-align:center">1937</td><td style="text-align:center">第一部剧场版手绘电影——白雪公主与七个小矮人</td></tr><tr><td style="text-align:center">1963</td><td style="text-align:center">第一个计算机生成的动画</td></tr><tr><td style="text-align:center">1972</td><td style="text-align:center">早期计算机动画，人脸动画</td></tr><tr><td style="text-align:center">1993</td><td style="text-align:center">侏罗纪公园</td></tr><tr><td style="text-align:center">1995</td><td style="text-align:center">第一部完全计算机生成的动画电影——玩具总动员</td></tr><tr><td style="text-align:center">2009</td><td style="text-align:center">天降美食</td></tr><tr><td style="text-align:center">2019</td><td style="text-align:center">冰雪奇缘2</td></tr></tbody></table></div><h4 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h4><p>最早期的动画制作一般由画师画出关键的画面，再由其助手补全关键帧之间的过渡</p><p>所以关键帧动画的主要问题在于使用怎样的插值方法得到更为平滑的过渡</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB1.png" alt="关键帧动画1"></p><p>通常来说线性插值是无法满足平滑过渡的需求的，所以一般会用贝塞尔，b样条之类的几何插值技术</p><div class="table-container"><table><thead><tr><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB2.png" alt="关键帧动画2"></th><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB3.png" alt="关键帧动画3"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h4 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h4><p>物理模拟一般指 通过建立物理模型来还原诸如流体，布料等基于真实情况的动画</p><h5 id="质点弹簧系统"><a href="#质点弹簧系统" class="headerlink" title="质点弹簧系统"></a>质点弹簧系统</h5><p>质点弹簧系统是一系列相互连接的质点和弹簧，最简单的一种是理想弹簧，如图</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E7%90%86%E6%83%B3%E5%BC%B9%E7%B0%A7.png" alt="理想弹簧"></p><p>理想弹簧没有初始长度，且满足牛顿第三定律，用胡克定律求解作用力的大小</p><p>在理想弹簧的基础上引入原长，就变成了非零长弹簧</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%9D%9E%E9%9B%B6%E9%95%BF%E5%BC%B9%E7%B0%A7.png" alt="非零长弹簧"></p><p>其中，$\frac{b-a}{|b-a|}$为归一化的力的方向，由于不考虑能量损失，非零长弹簧会始终保持运动的状态</p><p>如果简单引入摩擦力，则所有运动最后都会停止，如图</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E7%AE%80%E5%8D%95%E5%BC%95%E5%85%A5%E6%91%A9%E6%93%A6%E5%8A%9B.png" alt="简单引入摩擦力"></p><p>$-k_d$表示劲度系数，$\dot{b}$表示速度（x上加一点是导数的牛顿标记法）</p><p>这个模型的主要问题是无法考虑弹簧内部的相互作用力的影响，依然不接近真实情况</p><p>所以我们再引入一个内部的阻尼力</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%BC%95%E5%85%A5%E5%86%85%E9%83%A8%E4%BD%9C%E7%94%A8%E5%8A%9B.png" alt="引入内部作用力"></p><p>红框内表示b与a的相对速度在二者连线方向上的投影，是一个标量，再乘以b到a的归一化方向以及劲度系数，就得到的b上的总阻力</p><p>考虑完两个质点的相互作用，再来考虑弹簧系统，如何用这样一个系统来模拟纸或布料这种具有抗切变性质的材质</p><div class="table-container"><table><thead><tr><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E4%B8%89%E6%AD%A5%E4%BC%98%E5%8C%96%20(1" alt="三步优化 (1)">.png)</th><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E4%B8%89%E6%AD%A5%E4%BC%98%E5%8C%96%20(2" alt="三步优化 (2)">.png)</th><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E4%B8%89%E6%AD%A5%E4%BC%98%E5%8C%96%20(3" alt="三步优化 (3)">.png)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>抗切变：对于平面内的力，普通质点弹簧系统一拉就会变形，而抗切变材质不会；对于非平面力，质点弹簧系统可以做到完美对折，而抗切变材质不会</p><p>为了模拟这种情况，对原本的质点弹簧系统添加两步约束，如上图所示，一个是对角线的强约束，一个是跨顶点的弱约束</p><p>这样一来基本就可以得到物理正确的布料模拟了，但有时依旧不够精确</p><p>在渲染前沿话题中我们提到，布料的组成远比一个质点弹簧系统复杂（纤维，股，线），如果需要更为精确的模拟，首先在模型上的精度就得上去，其次还要得考虑质点间力的传导（有限元法，FEM），这样的模拟比较难做，在此略过</p><h5 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h5><p>粒子系统被广泛应用于图形与游戏行业，系统中每一个粒子的行为都会被一组人为设置的力所定义</p><p>一般来说，粒子生成的步骤如下：</p><p>生成粒子 -&gt; 计算每个粒子的力 -&gt; 更新每个粒子的位置和速度 -&gt; 将死亡的粒子移除 -&gt; 渲染到屏幕</p><p>粒子之间常见的作用力举例：重力，电磁力，摩擦力，空气阻力，粘滞力，碰撞等</p><p>粒子的模拟不仅限于计算机图形，现实中的大自然如鸟群行为，细胞结构都可以通过粒子模拟</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%B8%9F%E7%BE%A4%E8%A1%8C%E4%B8%BA.png" alt="鸟群行为"></p><h4 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h4><p>运动学大致分为正向运动学和逆向运动学</p><p>正向运动学是通过定义一些可活动关节（如铰链），通过计算来控制末端的点的运动</p><div class="table-container"><table><thead><tr><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A61.png" alt="正向运动学1"></th><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A62.png" alt="正向运动学2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>虽然计算简单，但过程太过理性，艺术家习惯直接控制末端的点，而不是控制关节来间接运动</p><p>这种直接控制末端点的运动的方法，称为逆向运动学</p><div class="table-container"><table><thead><tr><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A61.png" alt="逆向运动学1"></th><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A62.png" alt="逆向运动学2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>逆向运动学虽然直观形象，但它有一个很大的问题就是多解问题，要优化解的选择则涉及到深度学习（随机化算法、梯度下降等方法）</p><p><a href="https://zhuanlan.zhihu.com/p/434238743">https://zhuanlan.zhihu.com/p/434238743</a></p><h4 id="角色绑定"><a href="#角色绑定" class="headerlink" title="角色绑定"></a>角色绑定</h4><p>角色绑定（Rigging）是指动画制作中涉及的骨骼创建、约束、蒙皮等操作，可以形象理解为提线木偶，是对逆运动学的一种应用</p><p>角色不同，每个角色的绑骨也都会不同，并且这一流程对后续动画制作会有直接影响，即角色的动作与动作之间原本需要对三维模型进行插值，现在只需要对骨骼插值即可</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E9%AA%A8%E9%AA%BC%E7%BB%91%E5%AE%9A.png" alt="骨骼绑定"></p><p>作为一个绑定师，需要同时具备艺术和技术才能</p><h4 id="动作捕捉"><a href="#动作捕捉" class="headerlink" title="动作捕捉"></a>动作捕捉</h4><p>既然可以通过绑骨来人为规定角色动作，那么这些信息同样也可以被捕捉记录下来，捕捉真实的控制点来生成动画</p><p>这种技术就是动捕技术</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%8A%A8%E4%BD%9C%E6%8D%95%E6%8D%89.png" alt="动作捕捉"></p><p>动作捕捉的数据采集有不同的方法，一种是光学动捕，在动捕演员的关键位置设置信号源，还有诸如应用了电磁波的或是直接纯机械的动捕，都可以达到最终目的</p><p>但是，动作捕捉在采集真实信息的时候也有一些技术难点，比如遮挡、环境影响等，这会导致采集的信息良莠不齐</p><p>另外该项技术对硬件的要求比较高，操作也非常复杂，是一个高成本动画制作方案</p><h4 id="动画制作流程"><a href="#动画制作流程" class="headerlink" title="动画制作流程"></a>动画制作流程</h4><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p20-%E5%8A%A8%E7%94%BB/%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="动画制作流程"></p><h3 id="模拟方法"><a href="#模拟方法" class="headerlink" title="模拟方法"></a>模拟方法</h3><h4 id="单粒子模拟"><a href="#单粒子模拟" class="headerlink" title="单粒子模拟"></a>单粒子模拟</h4><p>为了模拟一个粒子的运动，我们需要获取其任意时间的位置信息</p><p>为了达到这个目的，我们可以假定一个速度场，在场内使用一阶常微分方程来得到其速度信息</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E5%8D%95%E7%B2%92%E5%AD%90%E6%A8%A1%E6%8B%9F.png" alt="单粒子模拟"></p><p>计算得到速度之后，再用欧拉方法等各种手段，解出位置信息，得到模拟结果</p><h5 id="欧拉方法"><a href="#欧拉方法" class="headerlink" title="欧拉方法"></a>欧拉方法</h5><p>即对时间进行离散化，以一定步长细分时间，并每次用前一帧的计算结果更新当前帧的位置信息（前项欧拉）</p><script type="math/tex; mode=display">前项欧拉:\ x^{t+\triangle t}=x^t+\triangle t \dot{x}^t\\非前项欧拉:\ \dot{x}^{t+\triangle t}=\dot{x}^t+\triangle t \ddot{x}^t</script><p>不过，这么做容易造成很大的误差，并且稳定性也非常差，如图</p><p>一旦步长低于一定精度，这种模拟就显得非常粗糙</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95%E8%AF%AF%E5%B7%AE%E5%A4%A7.png" alt="欧拉方法误差大"></p><p>而在一些速度场中，产生的误差会被无限放大，出现正反馈现象</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%B7%AE.png" alt="欧拉方法稳定性差"></p><p>为了改善这种模拟方法的不足之处，可以采用其他模拟方法，如下面介绍的中点法，自适应步长方法，隐式欧拉方法，龙格库塔方法等</p><h5 id="中点法"><a href="#中点法" class="headerlink" title="中点法"></a>中点法</h5><p>中点法其实就是做了两次欧拉方法，第一次欧拉方法获得中点位置，在取中点位置的速度，再代入算一遍欧拉方法</p><div class="table-container"><table><thead><tr><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E4%B8%AD%E7%82%B9%E6%B3%951.png" alt="中点法1"></th><th><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E4%B8%AD%E7%82%B9%E6%B3%952.png" alt="中点法2"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>最后的形式有点像泰勒的样子，就是多了一个二次项</p><p>理解的话，可以用初中物理的平均速度概念，自己推一遍加速度方程，$\dot{x}$是速度，$\ddot{x}$是加速度</p><h5 id="自适应步长方法"><a href="#自适应步长方法" class="headerlink" title="自适应步长方法"></a>自适应步长方法</h5><p>这种方法也是算两遍欧拉，第一遍用$\triangle t$算，第二遍用$\frac{\triangle t}{2}$算，算完之后检验两次计算结果，如果偏差较大，则步长减半重新计算</p><p>这与直接减小步长的最大差别就是，他可以根据计算结果判断哪里应该用小步长，哪里用大步长，这就是所谓的“自适应”</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E8%87%AA%E9%80%82%E5%BA%94%E6%AD%A5%E9%95%BF%E6%B3%95.png" alt="自适应步长法"></p><h5 id="隐式欧拉方法"><a href="#隐式欧拉方法" class="headerlink" title="隐式欧拉方法"></a>隐式欧拉方法</h5><p>又称后向欧拉方法，前向欧拉是每次计算都用前一帧数据，那后向计算顾名思义就是用未来的数据</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E9%9A%90%E5%BC%8F%E7%9A%84%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95.png" alt="隐式的欧拉方法"></p><p>这种方法需要求解非线性方程组，会用到牛顿法等求根算法，计算会慢，但稳定性相应也高</p><p>如何定义稳定性：</p><p>考虑截断误差和总体误差，我们习惯用$O(h)$表示当步长减小为原来的一半，误差会相应减少为原来一半，用$O(h^2)$表示当步长减小为原来的一半，误差会相应减少为原来$\frac{1}4$……（h为步长）</p><p>对于隐式欧拉方法来说，它是一阶稳定的，截断误差满足$O(h^2)$，总体误差满足$O(h)$</p><h5 id="Runge-Kutta-Family"><a href="#Runge-Kutta-Family" class="headerlink" title="Runge-Kutta Family"></a>Runge-Kutta Family</h5><p>是一种四阶的方法，稳定性非常好</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E9%BE%99%E6%A0%BC%E5%BA%93%E5%A1%94.png" alt="龙格库塔"></p><p>公式推导会涉及很多数值分析的内容，还没学到，先放一放</p><h5 id="非物理方法"><a href="#非物理方法" class="headerlink" title="非物理方法"></a>非物理方法</h5><p>如位置调整法，韦尔莱积分等，这些方法通过调整粒子的位置使其满足一些特定性质，虽然不太物理（不满足能量守恒）也不太稳定，但实现起来比较简单，计算也比较快</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E9%9D%9E%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95.png" alt="非物理方法"></p><h4 id="刚体模拟"><a href="#刚体模拟" class="headerlink" title="刚体模拟"></a>刚体模拟</h4><p>主要思想是刚体不会发生形变，并且内部所有粒子都以同一种运动方式运动</p><p>那么相对于粒子模拟只考虑位置和速度，刚体模拟会考虑更多的参数，如角度和角速度，角速度和角加速度等这些的对应关系</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E5%88%9A%E4%BD%93%E6%A8%A1%E6%8B%9F.png" alt="刚体模拟"></p><h4 id="流体模拟"><a href="#流体模拟" class="headerlink" title="流体模拟"></a>流体模拟</h4><p>流体模拟算是一种典型的非物理方法粒子模拟</p><p>与刚体模拟一样，流体模拟同样认为流体粒子不可压缩，且密度处处相等（变化前后密度也保持不变），那么任何时刻，任意位置的流体粒子发生运动都会导致其周围粒子的密度发生变化（马尔科夫链），而要使运动前后密度不变，就需要通过改变流体粒子位置来修正</p><p>这个修正过程，就是流体模拟的过程</p><p>修正方法用到了深度学习的梯度下降法</p><p>注意，流体模拟的过程会有永动的情况出现，这时候可以人为加入外力消耗能量，使其最后稳定下来</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F1.png" alt="流体模拟1"></p><h4 id="模拟思想总结"><a href="#模拟思想总结" class="headerlink" title="模拟思想总结"></a>模拟思想总结</h4><p>有两种主流的模拟思想，拉格朗日视角（质点法）和欧拉视角（网格法），前一种是逐个进行单粒子模拟，后一种是将空间定义为多个网格单元，通过观察网格来决定如何模拟，关于这两种方法会在GAMES201物理引擎实战中有详细讲解</p><p>将上述两种思想结合，就是现在流行的材质点方法（MPM）</p><p>具体做法是，先将属性参数储存在粒子上（拉格朗日视角），再在模拟变换的过程中运用欧拉视角进行模拟计算，最后将每一个时刻网格的信息写回网格内的粒子上，并渲染到屏幕上</p><p><img src="/posts/19430/-STUDY-/college/%E9%97%AB%E4%BB%A4%E7%90%AA_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/101/%E5%9B%BE%E7%89%87/p21-%E5%8A%A8%E7%94%BB%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/MPM.png" alt="MPM"></p><p>【END】</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> GAMES101 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
